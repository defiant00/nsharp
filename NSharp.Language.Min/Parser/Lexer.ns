use NSharp.Core
use NSharp.Language.Min.TokenTree

ns NSharp.Language.Min

public class Lexer
    public fn Tokens TokenTree.File = new()
    public fn Diagnostics List{Diagnostic} = new()

    private val EOL char = '\0'
    private val OPERATOR_CHARACTERS str = "()[]{{}}<>:?!=+-*/%,.&|^~"
    private val REPEATED_ESCAPE_STRING_CHARACTERS str = "{{}}"""

    private del StateFunction() ?StateFunction

    private fn Line str = str.Empty
    private fn LineNumber int = 0
    private fn StartIndex int
    private fn CurrentIndex int
    private fn State ?StateFunction
    private fn IndentationLevels Stack{int} = new()
    private fn HeldIndents Queue{int} = new()
    private fn HeldEols int = 0
    private fn LastEmittedWasLineContinuation bool = false
    private fn StringTerminators Stack{TokenType} = new()
    private fn CurrentNode Node

    public fn new()
        IndentationLevels.Push(0)
        CurrentNode = Tokens

    public fn Lex(line str)
        LineNumber += 1
        Line = line
        StartIndex = 0
        CurrentIndex = 0
        State = LexIndent

        for State != null
            State = State()

    public fn EndOfFile()
        EmitIndent(0)
        EmitHeld(false)
    
    private fn AddError(position Position, code str, message str)
        Diagnostics.Add(new Diagnostic(Severity.Error, code, message, position))

    ; Identifiers can start with a letter, _, or ` to indicate an identifier that matches a keyword
    private fn IsValidIdentifierStart(c char) bool is char.IsLetter(c) or c == '_' or c == Constant.IDENTIFIER_INDICATOR

    ; Identifiers can contain letters, numbers, and _
    private fn IsValidIdentifier(c char) bool is char.IsLetter(c) or c == '_' or char.IsDigit(c)

    private fn IsValidOperator(c char) bool is OPERATOR_CHARACTERS.IndexOf(c) >= 0

    private fn IsLineEnd(c char) bool is c == EOL or c == '\r' or c == '\n'

    private fn IsValidBinary(c char) bool is c == '0' or c == '1'

    private fn IsValidHex(c char) bool is char.IsDigit(c) or (c >= 'a' and c <= 'f') or (c >= 'A' and c <= 'F')

    private fn CurrentPosition Position is new Position() { Line = LineNumber, Column = StartIndex + 1 }

    private fn CurrentValue str is Line.Substring(StartIndex, CurrentLength)

    private fn CurrentLength int is CurrentIndex - StartIndex

    private fn Next() char
        var next = Peek
        CurrentIndex += 1
        ret next
    
    private fn Peek char is (CurrentIndex >= Line.Length) ? EOL : Line[CurrentIndex]

    private fn PeekNext char is ((CurrentIndex + 1) >= Line.Length) ? EOL : Line[CurrentIndex + 1]

    private fn PeekNextNext char is ((CurrentIndex + 2) >= Line.Length) ? EOL : Line[CurrentIndex + 2]

    private fn Backup() is CurrentIndex -= 1

    private fn Discard(increment int = 0)
        CurrentIndex += increment
        StartIndex = CurrentIndex

    private fn Accept(valid str) bool
        if valid.IndexOf(Next()) >= 0
            ret true
        Backup()
        ret false

    private fn AcceptRun(valid str)
        for valid.IndexOf(Next()) >= 0
            ; empty
        Backup()
    
    private fn StartsWithThenNotIdentifier(value str) bool
        if CurrentIndex + value.Length > Line.Length
            ret false
        for i = 0, i < value.Length, i += 1
            if value[i] != Line[CurrentIndex + i]
                ret false
        if CurrentIndex + value.Length < Line.Length
            ret !IsValidIdentifier(Line[CurrentIndex + value.Length])
        ret true

    private fn VerifyUpTo(target Node)
        var current = CurrentNode
        for current != target and current.Parent != null
            if current is BracketGroup
                AddError(current.Position, "code", "unclosed [")
            else if current is CurlyGroup
                AddError(current.Position, "code", "unclosed {{")
            else if current is ParenthesisGroup
                AddError(current.Position, "code", "unclosed (")
            else if current is StringGroup
                AddError(current.Position, "code", "unclosed """)
            current = current.Parent
        if current != target
            throw new Exception("Unable to verify to {target}")
    
    private fn AddEol()
        if CurrentNode is Block b
            b.Children.Add(new Line(CurrentPosition, b))
        else if block = CurrentNode.FirstBlock, block != null
            VerifyUpTo(block)
            CurrentNode = block
        else
            throw new Exception("block is null for eol")
    
    private fn AddIndent()
        if block = CurrentNode.FirstBlock, block != null
            VerifyUpTo(block)
            var indent = new IndentBlock(CurrentPosition, block)
            block.Children.Add(indent)
            CurrentNode = indent
        else
            throw new Exception("block is null for indent")
    
    private fn AddDedent()
        if block = CurrentNode.FirstBlock, block != null and block is IndentBlock and block.Parent != null
            VerifyUpTo(block.Parent)
            CurrentNode = block.Parent
        else
            throw new Exception("dedent?")
    
    private fn EnsureGroup()
        if CurrentNode is Block block
            var line = new Line(CurrentPosition, block)
            block.Children.Add(line)
            CurrentNode = line

    private fn AddToken(token Token)
        token.Parent = CurrentNode
        if token.Type
            is TokenType.LeftBracket
                EnsureGroup()
                var group = new BracketGroup(token.Position, CurrentNode)
                (CurrentNode as Group).Children.Add(group)
                CurrentNode = group
            is TokenType.RightBracket
                if group = CurrentNode.FirstBracketGroup, group?.Parent != null
                    VerifyUpTo(group)
                    CurrentNode = group.Parent
                else
                    AddError(token.Position, "code", "unexpected ]")
            is TokenType.LeftCurly
                EnsureGroup()
                var group = new CurlyGroup(token.Position, CurrentNode)
                (CurrentNode as Group).Children.Add(group)
                CurrentNode = group
            is TokenType.RightCurly
                if group = CurrentNode.FirstCurlyGroup, group?.Parent != null
                    VerifyUpTo(group)
                    CurrentNode = group.Parent
                else
                    AddError(token.Position, "code", "unexpected }")
            is TokenType.LeftParenthesis
                EnsureGroup()
                var group = new ParenthesisGroup(token.Position, CurrentNode)
                (CurrentNode as Group).Children.Add(group)
                CurrentNode = group
            is TokenType.RightParenthesis
                if group = CurrentNode.FirstParenthesisGroup, group?.Parent != null
                    VerifyUpTo(group)
                    CurrentNode = group.Parent
                else
                    AddError(token.Position, "code", "unexpected )")
            is TokenType.StringStart
                EnsureGroup()
                var group = new StringGroup(token.Position, CurrentNode)
                (CurrentNode as Group).Children.Add(group)
                CurrentNode = group
            is TokenType.StringEnd
                if group = CurrentNode.FirstStringGroup, group?.Parent != null
                    VerifyUpTo(group)
                    CurrentNode = group.Parent
                else
                    AddError(token.Position, "code", "unexpected """)
            is _
                EnsureGroup()
                (CurrentNode as Group).Children.Add(token)

    private fn EmitEol() is HeldEols += 1
    
    private fn EmitIndent(indent int) is HeldIndents.Enqueue(indent)

    private fn EmitHeld(needsDedent bool)
        ; Emit any held tokens.
        ; For normal code we emit:
        ;   [first EOL] [dedents] [remaining EOLs]
        ; If the token needs a dedent (such as an else) emit:
        ;   [first EOL] [all but the last dedent] [remaining EOLs] [last dedent]

        ; add the first EOL
        if HeldEols > 0
            AddEol()
        var emitFinalDedent = false
        for HeldIndents.Any()
            var indent = HeldIndents.Dequeue()
            var currentIndent = IndentationLevels.Peek()
            if indent > currentIndent
                AddIndent()
                IndentationLevels.Push(indent)
            else
                for IndentationLevels.Any() and indent < currentIndent
                    if needsDedent
                        if emitFinalDedent
                            AddDedent()
                        emitFinalDedent = true
                    else
                        AddDedent()
                    IndentationLevels.Pop()
                    currentIndent = IndentationLevels.Peek()
                if !IndentationLevels.Any() or currentIndent != indent
                    AddError(CurrentPosition, "code", "mismatched indentation level")
        ; add any remaining EOLs
        for i = 1, i < HeldEols, i += 1
            AddEol()
        HeldEols = 0
        
        if emitFinalDedent
            AddDedent()

    private fn MoveEmit(count int, token TokenType)
        CurrentIndex += count
        Emit(token)

    private fn Emit(token TokenType)
        ; If the previous or current token is a line continuation, clear the held tokens.
        if LastEmittedWasLineContinuation or token.IsLineContinuationPrefix()
            HeldIndents.Clear()
            HeldEols = 0
        else
            EmitHeld(token.NeedsDedent())

        ; String terminators.
        if token == TokenType.LeftCurly
            StringTerminators.Push(TokenType.RightCurly)
        else if token == TokenType.StringStart
            StringTerminators.Push(TokenType.StringEnd)
        else if StringTerminators.Any() and StringTerminators.Peek() == token
            StringTerminators.Pop()

        ; Emit the current token.
        var curVal = CurrentValue
        if token == TokenType.StringLiteral
            curVal = curVal.Unescape()
        AddToken(new Token(CurrentPosition, token, curVal))

        LastEmittedWasLineContinuation = token.IsLineContinuationPostfix()

        StartIndex = CurrentIndex

    private fn LexIndent() ?StateFunction
        var indent = 0
        for
            if Next()
                is EOL
                is '\r'
                is '\n'
                    Backup()
                    Discard()
                    EmitEol()
                    ret null
                is ' '
                    indent += 1
                is '\t'
                    indent += 4
                is _
                    Backup()
                    Discard()
                    EmitIndent(indent)
                    ret LexStatement

    private fn LexStatement() ?StateFunction
        for
            if peekVal = Peek, peekVal
                is ' '
                is '\t'
                    Discard(1)
                is EOL
                is '\r'
                is '\n'
                    Discard()
                    EmitEol()
                    ret null
                is ';'
                    ret LexComment
                is '\''
                    ret LexCharacter
                is '"'
                    ret LexString
                is _
                    if peekVal == '}' and StringTerminators.Any() and StringTerminators.Peek() == TokenType.RightCurly
                        ret LexString
                    else if StartsWithThenNotIdentifier(Constant.FUNCTION_END)
                        Discard()
                        MoveEmit(Constant.FUNCTION_END.Length, TokenType.FunctionEnd)
                    else if IsValidIdentifierStart(peekVal)
                        ret LexIdentifier
                    else if char.IsDigit(peekVal)
                        ret LexNumber
                    else if IsValidOperator(peekVal)
                        ret LexOperator
                    else
                        AddError(CurrentPosition, "code", "Invalid character '{peekVal}'")
                        Discard(1)

    private fn LexCharacter() ?StateFunction
        ; discard the '
        Discard(1)

        if c = Next(), IsLineEnd(c)
            AddError(CurrentPosition, "code", "unclosed '")
            ret LexStatement
        else if c == '\\'
            c = Next()
            if IsLineEnd(c)
                AddError(CurrentPosition, "code", "unclosed '")
                ret LexStatement

        if Peek != '\''
            AddError(CurrentPosition, "code", "unclosed '")
        else
            Emit(TokenType.CharacterLiteral)
            Discard(1)

        ret LexStatement

    private fn LexComment() ?StateFunction
        ; discard the ;
        Discard(1)

        for c = Peek, !IsLineEnd(c), c = Peek
            Next()
        Emit(TokenType.Comment)
        EmitEol()
        ret null

    private fn LexIdentifier() ?StateFunction
        ; discard any leading whitespace
        Discard()

        ; accept the starting identifier character
        var isIdentifier = Next() == Constant.IDENTIFIER_INDICATOR
        ; if it starts with ` discard it
        if isIdentifier
            Discard()

        for c = Peek, IsValidIdentifier(c), c = Peek
            Next()

        if CurrentLength == 0
            AddError(CurrentPosition, "code", "an identifier must have a value")
        else if isIdentifier
            Emit(TokenType.Identifier)
        else
            var tokenType TokenType
            var found = TokenHelper.KeywordTokens.TryGetValue(CurrentValue, out tokenType)
            Emit(found ? tokenType : TokenType.Identifier)
        ret LexStatement

    private fn LexNumber() ?StateFunction
        ; discard any leading whitespace
        Discard()

        if Peek == '0'
            Next()
            if Peek == 'b'
                ; binary
                Next()
                for c = Peek, IsValidBinary(c), c = Peek
                    Next()
                Emit(TokenType.NumberLiteral)
                ret LexStatement
            else if Peek == 'x'
                ; hex
                Next()
                for c = Peek, IsValidHex(c), c = Peek
                    Next()
                Emit(TokenType.NumberLiteral)
                ret LexStatement
        for c = Peek, char.IsDigit(c), c = Peek
            Next()
        if Accept(".")
            var foundDigitsAfterDecimal = false
            for c = Peek, char.IsDigit(c), c = Peek
                Next()
                foundDigitsAfterDecimal = true
            ; Put the decimal back if there are no numbers after it
            if !foundDigitsAfterDecimal
                Backup()
        Emit(TokenType.NumberLiteral)
        ret LexStatement

    private fn LexOperator() ?StateFunction
        ; discard any leading whitespace
        Discard()

        if Peek
            is '.'
                if PeekNext == '.'
                    MoveEmit(2, TokenType.DoubleDot)
                else
                    MoveEmit(1, TokenType.Dot)
            is ','
                MoveEmit(1, TokenType.Comma)
            is '?'
                if next = PeekNext, next == '.'
                    MoveEmit(2, TokenType.NullDot)
                else if next == '?'
                    if PeekNextNext == '='
                        MoveEmit(3, TokenType.NullCoalesceAssign)
                    else
                        MoveEmit(2, TokenType.NullCoalesce)
                else
                    MoveEmit(1, TokenType.Question)
            is ':'
                if PeekNext == ':'
                    MoveEmit(2, TokenType.DoubleColon)
                else
                    MoveEmit(1, TokenType.Colon)
            is '='
                if PeekNext == '='
                    MoveEmit(2, TokenType.Equal)
                else
                    MoveEmit(1, TokenType.Assign)
            is '!'
                if PeekNext == '='
                    MoveEmit(2, TokenType.NotEqual)
                else
                    MoveEmit(1, TokenType.Not)
            is '<'
                if next = PeekNext, next == '<'
                    if PeekNextNext == '='
                        MoveEmit(3, TokenType.LeftShiftAssign)
                    else
                        MoveEmit(2, TokenType.LeftShift)
                else if next == '='
                    MoveEmit(2, TokenType.LessThanOrEqual)
                else
                    MoveEmit(1, TokenType.LessThan)
            is '>'
                if next = PeekNext, next == '>'
                    if PeekNextNext == '='
                        MoveEmit(3, TokenType.RightShiftAssign)
                    else
                        MoveEmit(2, TokenType.RightShift)
                else if next == '='
                    MoveEmit(2, TokenType.GreaterThanOrEqual)
                else
                    MoveEmit(1, TokenType.GreaterThan)
            is '+'
                if PeekNext == '='
                    MoveEmit(2, TokenType.AddAssign)
                else
                    MoveEmit(1, TokenType.Add)
            is '-'
                if PeekNext == '='
                    MoveEmit(2, TokenType.SubtractAssign)
                else
                    MoveEmit(1, TokenType.Subtract)
            is '*'
                if PeekNext == '='
                    MoveEmit(2, TokenType.MultiplyAssign)
                else
                    MoveEmit(1, TokenType.Multiply)
            is '/'
                if PeekNext == '='
                    MoveEmit(2, TokenType.DivideAssign)
                else
                    MoveEmit(1, TokenType.Divide)
            is '%'
                if PeekNext == '='
                    MoveEmit(2, TokenType.ModulusAssign)
                else
                    MoveEmit(1, TokenType.Modulus)
            is '&'
                if PeekNext == '='
                    MoveEmit(2, TokenType.BitwiseAndAssign)
                else
                    MoveEmit(1, TokenType.BitwiseAnd)
            is '|'
                if PeekNext == '='
                    MoveEmit(2, TokenType.BitwiseOrAssign)
                else
                    MoveEmit(1, TokenType.BitwiseOr)
            is '^'
                if PeekNext == '='
                    MoveEmit(2, TokenType.BitwiseXorAssign)
                else
                    MoveEmit(1, TokenType.BitwiseXor)
            is '~'
                MoveEmit(1, TokenType.BitwiseNot)
            is '('
                MoveEmit(1, TokenType.LeftParenthesis)
            is ')'
                MoveEmit(1, TokenType.RightParenthesis)
            is '['
                MoveEmit(1, TokenType.LeftBracket)
            is ']'
                MoveEmit(1, TokenType.RightBracket)
            is '{'
                MoveEmit(1, TokenType.LeftCurly)
            is '}'
                MoveEmit(1, TokenType.RightCurly)

        ; todo - error handling

        ret LexStatement

    private fn LexString() ?StateFunction
        ; discard any leading whitespace
        Discard()
        
        ; accept the " or }
        if Next() == '"'
            Emit(TokenType.StringStart)
        else
            Emit(TokenType.RightCurly)

        for StringTerminators.Any() and StringTerminators.Peek() == TokenType.StringEnd
            ; Repeated '"', '{', '}' are accepted as literals
            if c = Peek, REPEATED_ESCAPE_STRING_CHARACTERS.IndexOf(c) >= 0 and c == PeekNext
                Next()
            else if c == '"'
                if CurrentLength > 0
                    Emit(TokenType.StringLiteral)
                ; accept the "
                Next()
                Emit(TokenType.StringEnd)
                break
            else if c == '{'
                if CurrentLength > 0
                    Emit(TokenType.StringLiteral)
                break
            else if c == '\\'
                Next()
                if IsLineEnd(Peek)
                    break
            else if IsLineEnd(c)
                break
            Next()

        ret LexStatement
