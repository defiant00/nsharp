use NSharp.Core
use NSharp.Language.Min.TokenTree

ns NSharp.Language.Min

public class TokenTreeBuilder
    public fn TokenTree Group = new(default, TokenType.FileBlock, null)

    private fn Diagnostics List{Diagnostic}
    private fn CurrentGroup Group
    private fn Tokens List{Token}
    private fn CurrentIndex int = 0

    private fn More bool is CurrentIndex < Tokens.Count

    private fn Peek Token is More ? Tokens[CurrentIndex] : Token.MISSING_TOKEN

    private fn Next() Token
        var token = Peek
        CurrentIndex += 1
        ret token

    public fn new(fileName str, settings Settings, diagnostics List{Diagnostic})
        Diagnostics = diagnostics
        CurrentGroup = TokenTree

        var lexer = new Lexer(fileName, settings, diagnostics)
        Tokens = lexer.Tokens

        for More
            Add(Next())

        if settings.PrintTokenTree
            TokenTree.Print(0)

    private fn AddError(position Position, code str, message str)
        Diagnostics.Add(new Diagnostic(Severity.Error, code, message, position))

    private fn VerifyUpTo(target Token)
        var current = CurrentGroup
        for current != target and current.Parent != null
            if current.Type == TokenType.BracketGroup
                AddError(current.Position, "code", "unclosed [")
            else if current.Type == TokenType.CurlyGroup
                AddError(current.Position, "code", "unclosed {{")
            else if current.Type == TokenType.ParenthesisGroup
                AddError(current.Position, "code", "unclosed (")
            else if current.Type == TokenType.StringGroup
                AddError(current.Position, "code", "unclosed """)
            else if current.Type == TokenType.FunctionBlock
                AddError(current.Position, "code", "unclosed fn")
            current = current.Parent
        if current != target
            throw new Exception("Unable to verify to {target}")
    
    private fn AddEol(position Position)
        if CurrentGroup.IsBlock()
            EnsureTokenList(position)
        else if block = CurrentGroup.FirstBlock, block != null
            VerifyUpTo(block)
            CurrentGroup = block
            EnsureTokenList(position)
        else
            throw new Exception("block is null for eol")
    
    private fn AddIndent(position Position)
        if block = CurrentGroup.FirstBlock, block != null
            VerifyUpTo(block)
            var indent = new Group(position, TokenType.IndentBlock, block)
            block.Tokens.Add(indent)
            CurrentGroup = indent
        else
            throw new Exception("block is null for indent")
    
    private fn AddDedent()
        if block = CurrentGroup.FirstBlock, block != null and block.Type == TokenType.IndentBlock and block.Parent != null
            VerifyUpTo(block.Parent)
            CurrentGroup = block.Parent
        else
            throw new Exception("dedent?")
    
    private fn EnsureTokenList(position Position)
        if CurrentGroup.IsBlock()
            var line = new Group(position, TokenType.Line, CurrentGroup)
            CurrentGroup.Tokens.Add(line)
            CurrentGroup = line
    
    private fn EnsureAddGroup(group Group)
        EnsureTokenList(group.Position)
        CurrentGroup.Tokens.Add(group)
        CurrentGroup = group
    
    private fn FinishGroup(tokenType TokenType, position Position, code str, message str)
        if group = CurrentGroup.FirstGroup(tokenType), group?.Parent != null
            VerifyUpTo(group)
            CurrentGroup = group.Parent
        else
            AddError(position, code, message)

    private fn Add(token Token)
        if token.Type
            is TokenType.EOL
                AddEol(token.Position)
            is TokenType.Indent
                AddIndent(token.Position)
            is TokenType.Dedent
                AddDedent()
            is TokenType.LeftBracket
                EnsureAddGroup(new Group(token.Position, TokenType.BracketGroup, CurrentGroup))
            is TokenType.RightBracket
                FinishGroup(TokenType.BracketGroup, token.Position, "code", "unexpected ]")
            is TokenType.LeftCurly
                EnsureAddGroup(new Group(token.Position, TokenType.CurlyGroup, CurrentGroup))
            is TokenType.RightCurly
                FinishGroup(TokenType.CurlyGroup, token.Position, "code", "unexpected }")
            is TokenType.LeftParenthesis
                EnsureAddGroup(new Group(token.Position, TokenType.ParenthesisGroup, CurrentGroup))
            is TokenType.RightParenthesis
                FinishGroup(TokenType.ParenthesisGroup, token.Position, "code", "unexpected )")
            is TokenType.StringStart
                EnsureAddGroup(new Group(token.Position, TokenType.StringGroup, CurrentGroup))
            is TokenType.StringEnd
                FinishGroup(TokenType.StringGroup, token.Position, "code", "unexpected """)
            is TokenType.FunctionStart
                EnsureAddGroup(new Group(token.Position, TokenType.FunctionBlock, CurrentGroup))
            is TokenType.FunctionEnd
                FinishGroup(TokenType.FunctionBlock, token.Position, "code", "unexpected /fn")
            is _
                EnsureTokenList(token.Position)
                token.Parent = CurrentGroup
                CurrentGroup.Tokens.Add(token)
