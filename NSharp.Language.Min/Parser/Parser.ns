use NSharp.Core
use NSharp.Core.SyntaxTree
use NSharp.Language.Min.TokenTree

ns NSharp.Language.Min

public class Parser
    private fn Settings Settings
    private fn Result LoadResult
    private fn CurrentIndex int = 0

    public fn new(settings Settings, result LoadResult)
        Settings = settings
        Result = result
    
    private fn AddError(code str, message str, position Position)
        Result.Diagnostics.Add(new Diagnostic(Severity.Error, code, message, position))
    
    private fn InvalidToken(group Group, type str, result AcceptResult)
        var token = group.ErrorToken(result)
        var missed = result.MissedTokenType
        var error = "Invalid token in {type} when looking for {missed}: {token}"
        AddError("[code]", error, token.Position)
    
    private fn AdvanceLine(group Group)
        EnsureNoExtraTokens(group)
        group.AdvanceParent()
    
    private fn EnsureNoExtraTokens(group Group)
        for i = group.CurrentIndex, i < group.Tokens.Count, i += 1
            AddError("[code]", "extra token {group.Tokens[i]}", group.Tokens[i].Position)

    public fn Parse(fileName str) Core.SyntaxTree.File
        var builder = new TokenTreeBuilder(fileName, Settings, Result.Diagnostics)

        var file = ParseFile(builder.TokenTree, fileName)

        if Settings.PrintSyntaxTree
            file.Accept(new SyntaxTreePrinterVisitor())

        ret file
    
    private fn ParseAnonymousFunction(group Group) Expression
        ; "fn" "(" [params] ")" [type] ":" statement
        ; "fn" "(" [params] ")" [type]
        ;     {statements}
        ; "/fn"
        var anonFnExpr = new AnonymousFunction(group.Peek.Position)

        if next = group.Next(), next.Type == TokenType.Function
            ; parameters
            if !ParseParameters(group, anonFnExpr.Parameters)
                AddError("[code]", "missing parameters", anonFnExpr.Position)

            ; optional return type
            if group.More and group.Peek.Type != TokenType.Colon
                anonFnExpr.ReturnType = ParseType(group)
            
            ; ":" statement
            if group.Accept(TokenType.Colon).Success
                anonFnExpr.Statements.Add(ParseMethodStatementShort(group, false))
            
        else if next is Group fnBlock and fnBlock.Type == TokenType.FunctionBlock and fnBlock.Peek is Group line and line.Type == TokenType.Line
            ; parameters
            if !ParseParameters(line, anonFnExpr.Parameters)
                AddError("[code]", "missing parameters", anonFnExpr.Position)
            
            ; optional return type
            if line.More
                anonFnExpr.ReturnType = ParseType(line)

            ; {statements}
            AdvanceLine(line)
            ParseIndentBlock(line, anonFnExpr.Statements, ParseMethodStatement)
        else
            AddError("[code]", "missing fn", anonFnExpr.Position)

        ret anonFnExpr

    private fn ParseArrayLiteral(group Group) Expression
        ; "[" [expressions] "]"
        if next = group.Next(), next.Type == TokenType.BracketGroup and next is Group bracketGroup
            var arrayExpr = new ArrayLiteral(bracketGroup.Position)
            if bracketGroup.More
                arrayExpr.Values.Add(ParseExpression(bracketGroup))
                for bracketGroup.Accept(TokenType.Comma).Success and bracketGroup.More
                    arrayExpr.Values.Add(ParseExpression(bracketGroup))
            EnsureNoExtraTokens(bracketGroup)
            ret arrayExpr
        ret new BadExpressionToken()
    
    private fn ParseArgument(group Group) Expression
        ; [name "="] ["out" | "ref"] expression
        var startPos = group.Peek.Position
        var name ?Token = null
        if res = group.Accept(TokenType.Identifier, TokenType.Assign), res.Success
            name = group.Token(res)
        
        ; modifiers
        var modifiers = new List{ArgumentModifierToken}()
        for group.Peek.Type.IsArgumentModifier()
            modifiers.Add(group.Next().ToArgumentModifierToken())
        
        var argStmt = new Argument(startPos, modifiers, ParseExpression(group))
        if name != null
            argStmt.Name = name.ToIdentifierToken()
        
        ret argStmt

    private fn ParseArguments(group Group, args List{Expression}) bool
        ; "(" [arguments] ")"
        if group.Peek.Type == TokenType.ParenthesisGroup and group.Next() is Group parenthesisGroup
            if parenthesisGroup.More
                args.Add(ParseArgument(parenthesisGroup))
                for parenthesisGroup.Accept(TokenType.Comma).Success and parenthesisGroup.More
                    args.Add(ParseArgument(parenthesisGroup))
            EnsureNoExtraTokens(parenthesisGroup)
            ret true
        ret false

    private fn ParseArrayType(group Group) Expression
        ; "[]" type
        if next = group.Next(), next.Type == TokenType.BracketGroup and next is Group bracketGroup
            if !bracketGroup.Tokens.Any()
                ret new ArrayType(bracketGroup.Position, ParseType(group))
            else
                AddError("[code]", "an array type shouldn't have anything in the []s", bracketGroup.Position)
        ret new BadExpressionToken()

    private fn ParseAssignment(group Group, left Expression, moveNextLine bool = true) Statement
        var op = group.Next().ToAssignmentOperatorToken()
        var right = ParseExpression(group)
        if moveNextLine
            AdvanceLine(group)
        ret new Assignment(left.Position, left, op, right)
    
    private fn ParseAttribute(group Group) Expression
        ; [qualifier ":"] expression
        var start = group.Peek.Position
        var res = group.Accept(TokenType.Identifier, TokenType.Colon)
        var attributeExpr = new Core.SyntaxTree.Attribute(start, ParsePrimaryExpression(group))
        if res.Success
            attributeExpr.Qualifier = group.Token(res).ToIdentifierToken()
        ret attributeExpr

    private fn ParseAttributeBlock(group Group, stmtFn Func{Group, Statement}) Statement
        ; {attrs}
        ;     {statements}
        var attributeBlockStmt = new AttributeBlock(group.Peek.Position)
        var currentLine = group
        for
            for currentLine.Peek.Type == TokenType.Identifier
                attributeBlockStmt.Attributes.Add(ParseAttribute(currentLine))
            if currentLine.More
                ; {attrs} statement
                attributeBlockStmt.Statements.Add(stmtFn(currentLine))
                ret attributeBlockStmt
            else
                AdvanceLine(currentLine)
                if currentLine.CurrentParentToken is Group nextLine
                    ; {attrs}
                    if nextLine.Type == TokenType.Line
                        currentLine = nextLine
                    else if nextLine.Type == TokenType.IndentBlock
                        ParseIndentBlock(nextLine, attributeBlockStmt.Statements, stmtFn)
                        ret attributeBlockStmt
                    else
                        AddError("[code]", "invalid block type {nextLine.Type} in attribute block", nextLine.Position)
                        ret attributeBlockStmt
                else
                    AddError("[code]", "invalid block type {currentLine.CurrentParentToken.Type} in attribute block",
                        currentLine.CurrentParentToken.Position)
                    ret attributeBlockStmt

    private fn ParseBinaryOperatorRightSide(group Group, leftPrecedence int, left Expression) Expression
        for
            var tokenPrecedence = group.Peek.Precedence()

            ; If this is a binary operator that binds at least as tightly as the
            ; current operator then consume it, otherwise we're done.
            if tokenPrecedence < leftPrecedence
                ret left

            var op = group.Next()
            var right = op.Type.IsOperatorCanThrow() ? ParseThrowOr(ParsePrimaryExpression, group) : ParsePrimaryExpression(group)
            
            ; If it's a named expression (currently only 'is') then accept the
            ; next token as the name if it's a literal.
            if op.Type == TokenType.Is and group.Peek.Type == TokenType.Identifier
                right = new NamedExpression(right.Position, right, group.Next().ToIdentifierToken())

            ; If the binary operator binds less tightly with the right than the operator
            ; after the right, let the pending operator take the right as its left.
            if tokenPrecedence < group.Peek.Precedence()
                right = ParseBinaryOperatorRightSide(group, tokenPrecedence + 1, right)

            ; Merge left and right.
            left = new BinaryOperator(left.Position, left, op.ToBinaryOperatorToken(), right)

    private fn ParseBlock(group Group) Statement
        var blockStmt = new Core.SyntaxTree.Block(group.Peek.Position)
        if res = group.Accept(TokenType.DoubleColon), res.Failure
            InvalidToken(group, "block", res)
        AdvanceLine(group)
        ParseIndentBlock(group, blockStmt.Statements, ParseMethodStatement)
        ret blockStmt

    private fn ParseBreak(group Group, moveNextLine bool = true) Statement
        if res = group.Accept(TokenType.Break), res.Success
            if moveNextLine
                AdvanceLine(group)
            ret new BreakToken(group.Token(res).Position)
        else
            InvalidToken(group, "break", res)
            AdvanceLine(group)
            ret new BadStatementToken()

    private fn ParseClass(group Group) Statement
        ; "class" name "(" {params} ")" ["is" base] ["has" interfaces]
        var res = group.Accept(TokenType.Class, TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "class", res)
            group.Advance()
            ret new BadStatementToken()
        
        var classStmt = new Class(group.Token(res).Position, group.Token(res, 1).ToIdentifierToken())

        ParseGenericDefinition(group, classStmt.Generics)

        if group.Accept(TokenType.Is).Success
            classStmt.Base = ParseType(group)

        if group.Accept(TokenType.Has).Success
            classStmt.Interfaces.Add(ParseType(group))
            for group.Accept(TokenType.Comma).Success
                classStmt.Interfaces.Add(ParseType(group))

        AdvanceLine(group)

        ParseIndentBlock(group, classStmt.Statements, ParseClassStatement)

        ret classStmt
    
    private fn ParseClassStatement(group Group) Statement
        if !group.Tokens.Any()
            ret ParseSpace(group)
        if group.Peek.Type
            is TokenType.Class
                ret ParseClass(group)
            is TokenType.Comment
                ret ParseComment(group)
            is TokenType.Delegate
                ret ParseDelegate(group)
            is TokenType.Enum
                ret ParseEnum(group)
            is TokenType.Function
                ret ParseMethodOrProperty(group)
            is TokenType.Value
                ret ParseConstant(group)
            is TokenType.Variable
                ret ParseField(group)
            is _
                ret ParseAttributeBlock(group, ParseClassStatement)
        
        ; todo -     is TokenType.Interface
        ; todo -         ret ParseInterface(modifiers)
        ; todo -     is TokenType.Struct
        ; todo -         ret ParseStruct(modifiers)

    private fn ParseComment(group Group, moveNextLine bool = true) Statement
        ; ";" comment
        if res = group.Accept(TokenType.Comment), res.Failure
            InvalidToken(group, "comment", res)
            AdvanceLine(group)
            ret new BadStatementToken()
        else
            var commentStmt = new CommentToken(group.Token(res).Position, group.Token(res).Value)
            if commentStmt.Value.StartsWith(";")
                commentStmt.Value = commentStmt.Value.Substring(1)
                commentStmt.IsDocumentation = true
            if moveNextLine
                AdvanceLine(group)
            ret commentStmt
    
    private fn ParseCondition(group Group) Statement
        var expr = ParseExpression(group)

        if res = group.Accept(TokenType.Colon), res.Failure
            InvalidToken(group, "condition", res)
            group.Advance()
            ret new BadStatementToken()
        
        ; Condition results can be a throw.
        var result = ParseThrowOr(ParseExpression, group)

        ret new Condition(expr.Position, expr, result)
    
    private fn ParseConditional(group Group, expr Expression) Expression
        ; expr "?" true expr ":" false expr
        ; expr "?" "{" value ":" result {"," value ":" result} "}"
        if res = group.Accept(TokenType.Question), res.Failure
            InvalidToken(group, "conditional", res)
            group.Advance()
            ret new BadExpressionToken()
        
        var conditionalExpr = new Conditional(expr.Position, expr)

        if group.Peek.Type != TokenType.CurlyGroup
            ; Condition results can be a throw.
            var trueRes = ParseThrowOr(ParseExpression, group)
            conditionalExpr.Conditions.Add(new Condition(
                trueRes.Position,
                new LiteralToken(trueRes.Position, LiteralType.True),
                trueRes
            ))

            if res = group.Accept(TokenType.Colon), res.Failure
                InvalidToken(group, "conditional", res)
                group.Advance()
                ret conditionalExpr
            
            ; Condition results can be a throw.
            var falseRes = ParseThrowOr(ParseExpression, group)
            conditionalExpr.Conditions.Add(new Condition(
                falseRes.Position,
                new LiteralToken(falseRes.Position, LiteralType.False),
                falseRes
            ))
        else
            var curlyGroup = group.Next() as Group
            if curlyGroup.More
                conditionalExpr.Conditions.Add(ParseCondition(curlyGroup))
                for curlyGroup.Accept(TokenType.Comma).Success and curlyGroup.More
                    conditionalExpr.Conditions.Add(ParseCondition(curlyGroup))
            else
                AddError("[code]", "a conditional should have at least one condition", curlyGroup.Position)
            EnsureNoExtraTokens(curlyGroup)
        
        ret conditionalExpr

    private fn ParseConstant(group Group) Statement
        ; "val" name type ["=" expr]
        var res = group.Accept(TokenType.Value, TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "constant", res)
            AdvanceLine(group)
            ret new BadStatementToken()

        var constStmt = new Core.SyntaxTree.Constant(group.Token(res).Position,
            group.Token(res, 1).ToIdentifierToken(),
            ParseType(group)
        )

        if group.Accept(TokenType.Assign).Success
            constStmt.Value = ParseExpression(group)
        
        AdvanceLine(group)
        ret constStmt

    private fn ParseConstructorCall(group Group) Expression
        ; "new" [type] "(" [args] ")" ["{" [initializers] "}"]
        var res = group.Accept(TokenType.New)
        if res.Failure
            InvalidToken(group, "constructor call", res)
            group.Advance()
            ret new BadExpressionToken()
        
        var ctorExpr = new ConstructorCall(group.Token(res).Position)

        if group.More and group.Peek.Type != TokenType.CurlyGroup and group.Peek.Type != TokenType.ParenthesisGroup
            ctorExpr.Type = ParseType(group)
        
        ParseArguments(group, ctorExpr.Arguments)
        ParseInitializers(group, ctorExpr.Initializers)

        ret ctorExpr

    private fn ParseConstructorDefinition(group Group, start Token) Statement
        ; "fn" "new" "(" {params} ")" ["base" "(" {exprs} ")"] [":" statement]
        ; "fn" "new" "(" {params} ")" ["base" "(" {exprs} ")"]
        ;     {statements}
        if res = group.Accept(TokenType.New), res.Failure
            InvalidToken(group, "constructor", res)
            AdvanceLine(group)
            ret new BadStatementToken()
    
        var ctorStmt = new ConstructorDefinition(start.Position)

        if !ParseParameters(group, ctorStmt.Parameters)
            AddError("[code]", "missing parameters", start.Position)

        ; "base" "(" {exprs} ")"
        if group.Accept(TokenType.Base).Success
            if !ParseArguments(group, ctorStmt.BaseArguments)
                AddError("[code]", "missing base parameters", start.Position)
        
        ParseStatementOrIndentBlock(group, ctorStmt.Statements)

        ret ctorStmt

    private fn ParseContinue(group Group, moveNextLine bool = true) Statement
        if res = group.Accept(TokenType.Continue), res.Success
            if moveNextLine
                AdvanceLine(group)
            ret new ContinueToken(group.Token(res).Position)
        else
            InvalidToken(group, "continue", res)
            AdvanceLine(group)
            ret new BadStatementToken()

    private fn ParseDelegate(group Group) Statement
        ; "del" name "(" {params} ")" [type]
        var res = group.Accept(TokenType.Delegate, TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "delegate", res)
            AdvanceLine(group)
            ret new BadStatementToken()

        var delegateStmt = new Core.SyntaxTree.Delegate(group.Token(res).Position, group.Token(res, 1).ToIdentifierToken())

        ParseGenericDefinition(group, delegateStmt.Generics)
        
        if !ParseParameters(group, delegateStmt.Parameters)
            AddError("[code]", "missing parameters", delegateStmt.Position)
        
        if group.More
            delegateStmt.ReturnType = ParseType(group)
        
        AdvanceLine(group)
        ret delegateStmt

    private fn ParseElse(group Group, ifStmt If)
        if group.Accept(TokenType.Else).Success
            if group.Peek.Type == TokenType.If
                ifStmt.ElseStatements.Add(ParseIf(group))
            else
                ParseStatementOrIndentBlock(group, ifStmt.ElseStatements)

    private fn ParseEnum(group Group) Statement
        ; "enum" name
        ;     name ["=" value] [";" comment]
        var res = group.Accept(TokenType.Enum, TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "enum", res)
            AdvanceLine(group)
            ret new BadStatementToken()
        
        var enumStmt = new Enumeration(group.Token(res).Position, group.Token(res, 1).ToIdentifierToken())

        AdvanceLine(group)
        ParseIndentBlock(group, enumStmt.Values, ParseEnumerationItem)

        ret enumStmt
    
    private fn ParseEnumerationItem(group Group) Statement
        ; name ["=" value] [";" comment]
        var res = group.Accept(TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "enumeration item", res)
            AdvanceLine(group)
            ret new BadStatementToken()
        
        var enumItemStmt = new EnumerationItem(group.Token(res).Position, group.Token(res).ToIdentifierToken())

        if group.Accept(TokenType.Assign).Success
            enumItemStmt.Value = ParseExpression(group)
        
        if group.Peek.Type == TokenType.Comment
            enumItemStmt.Comment = ParseComment(group)
        else
            AdvanceLine(group)
        
        ret enumItemStmt

    private fn ParseExpression(group Group) Expression
        var left = ParsePrimaryExpression(group)
        ret ParseBinaryOperatorRightSide(group, 0, left)
    
    private fn ParseExpressionStatement(group Group, moveNextLine bool = true) Statement
        var expr = ParseExpression(group)

        if group.Peek.Type.IsAssignment()
            ret ParseAssignment(group, expr, moveNextLine)

        if moveNextLine
            AdvanceLine(group)
        ret new ExpressionStatement(expr.Position, expr)

    private fn ParseField(group Group) Statement
        ; "var" name type ["=" expr]
        var res = group.Accept(TokenType.Variable, TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "field", res)
            AdvanceLine(group)
            ret new BadStatementToken()

        var fieldStmt = new Field(group.Token(res).Position,
            group.Token(res, 1).ToIdentifierToken(),
            ParseType(group)
        )

        if group.Accept(TokenType.Assign).Success
            fieldStmt.Value = ParseExpression(group)
        
        AdvanceLine(group)
        ret fieldStmt

    private fn ParseFile(tokenTree Group, fileName str) Core.SyntaxTree.File
        var file = new Core.SyntaxTree.File(Path.GetFileName(fileName))

        ; A file can contain lines and blocks.
        ; However, a block on its own is an error.
        for tokenTree.More
            if tokenTree.Peek.Type == TokenType.Line
                file.Statements.Add(ParseFileStatement(tokenTree.Peek as Group))
            else
                AddError("[code]", "unused block", tokenTree.Peek.Position)
                tokenTree.Advance()

        ret file
    
    private fn ParseFileStatement(group Group) Statement
        if !group.Tokens.Any()
            ret ParseSpace(group)
        if group.Peek.Type
            is TokenType.Class
                ret ParseClass(group)
            is TokenType.Comment
                ret ParseComment(group)
            is TokenType.Delegate
                ret ParseDelegate(group)
            is TokenType.Enum
                ret ParseEnum(group)
            is TokenType.Namespace
                ret ParseNamespace(group)
            is TokenType.Use
                ret ParseImport(group)
            is _
                ret ParseAttributeBlock(group, ParseFileStatement)
            
        ; todo - is TokenType.Interface
        ; todo - is TokenType.Struct
        ; todo -     file.Statements.Add(ParseFileModifiableStatement().Result)

    private fn ParseFor(group Group) Statement
        ; "for" name "in" expr [":" statement]
        ;     {statements}
        ; "for" [name "=" expr ","] [condition] [":" statement]
        ;     {statements}
        var start = group.Peek.Position

        if res = group.Accept(TokenType.For), res.Failure
            InvalidToken(group, "for", res)
            AdvanceLine(group)
            ret new BadStatementToken()
        
        if res = group.Accept(TokenType.Identifier, TokenType.In), res.Success
            ; "for" name "in" expr [":" statement]
            ;     {statements}
            var nameIdentifierToken = group.Token(res).ToIdentifierToken()
            var forEachStmt = new ForEach(start, nameIdentifierToken, ParseExpression(group))
            ParseStatementOrIndentBlock(group, forEachStmt.Statements)
            ret forEachStmt
        else if res2 = group.Accept(TokenType.Identifier, TokenType.Assign), res2.Success
            ; "for" name "=" expr "," condition [":" statement]
            ;     {statements}
            var forStmt = new For(start)
            forStmt.Name = group.Token(res2).ToIdentifierToken()
            forStmt.Init = ParseExpression(group)

            if group.Accept(TokenType.Comma).Failure
                AdvanceLine(group)
                AddError("[code]", "incomplete for", forStmt.Position)
                ret forStmt

            forStmt.Condition = ParseExpression(group)
            ParseStatementOrIndentBlock(group, forStmt.Statements)
            ret forStmt
        else
            ; "for" [condition] [":" statement]
            ;     {statements}
            var forStmt = new For(start)
            if group.More and group.Peek.Type != TokenType.Colon
                forStmt.Condition = ParseExpression(group)
            ParseStatementOrIndentBlock(group, forStmt.Statements)
            ret forStmt

    private fn ParseGenericArguments(group Group, expr Expression) Expression
        ; "{" {arguments} "}"
        var argsExpr = new Arguments(group.Peek.Position, expr)
        if group.Peek.Type == TokenType.CurlyGroup and group.Next() is Group curlyGroup
            if curlyGroup.More
                argsExpr.Values.Add(ParseType(curlyGroup))
                for curlyGroup.Accept(TokenType.Comma).Success and curlyGroup.More
                    argsExpr.Values.Add(ParseType(curlyGroup))
            else
                AddError("[code]", "generics must have an argument", curlyGroup.Position)
            EnsureNoExtraTokens(curlyGroup)
        ret argsExpr

    private fn ParseGenericDefinition(group Group, generics List{Statement}) bool
        ; "{" item {"," item} "}"
        if group.Peek.Type == TokenType.CurlyGroup and group.Next() is Group curlyGroup
            if curlyGroup.More
                generics.Add(ParseGenericDefinitionItem(curlyGroup))
                for curlyGroup.Accept(TokenType.Comma).Success and curlyGroup.More
                    generics.Add(ParseGenericDefinitionItem(curlyGroup))
            EnsureNoExtraTokens(curlyGroup)
            ret true
        ret false
    
    private fn ParseGenericDefinitionItem(group Group) Statement
        ; name ["class"] ["default"] ["in"] ["new"] ["!null"] ["?class"] ["out"] ["struct"] ["val"] [class] {interfaces}
        if res = group.Accept(TokenType.Identifier), res.Failure
            InvalidToken(group, "generic", res)
            group.Advance()
            ret new BadStatementToken()
        else
            var genericStmt = new Generic(group.Token(res).Position, group.Token(res).ToIdentifierToken())
            for group.More and group.Peek.Type != TokenType.Comma
                var position = group.Peek.Position
                if group.Peek.Type
                    is TokenType.Class
                        genericStmt.Constraints.Add(new GenericConstraintToken(position, GenericConstraintType.Class))
                        group.Next()
                    is TokenType.Default
                        genericStmt.Constraints.Add(new GenericConstraintToken(position, GenericConstraintType.Default))
                        group.Next()
                    is TokenType.In
                        genericStmt.Constraints.Add(new GenericConstraintToken(position, GenericConstraintType.In))
                        group.Next()
                    is TokenType.New
                        genericStmt.Constraints.Add(new GenericConstraintToken(position, GenericConstraintType.New))
                        group.Next()
                    is TokenType.Out
                        genericStmt.Constraints.Add(new GenericConstraintToken(position, GenericConstraintType.Out))
                        group.Next()
                    is TokenType.Struct
                        genericStmt.Constraints.Add(new GenericConstraintToken(position, GenericConstraintType.Struct))
                        group.Next()
                    is TokenType.Value
                        genericStmt.Constraints.Add(new GenericConstraintToken(position, GenericConstraintType.Value))
                        group.Next()
                    is _
                        if group.Accept(TokenType.Not, TokenType.Null).Success
                            genericStmt.Constraints.Add(new GenericConstraintToken(position, GenericConstraintType.NotNull))
                        else if group.Accept(TokenType.Question, TokenType.Class).Success
                            genericStmt.Constraints.Add(new GenericConstraintToken(position, GenericConstraintType.NullableClass))
                        else
                            genericStmt.Constraints.Add(ParseType(group))

            ret genericStmt

    private fn ParseIdentifier(group Group) Expression
        if res = group.Accept(TokenType.Identifier), res.Failure
            InvalidToken(group, "identifier", res)
            group.Advance()
            ret new BadExpressionToken()
        else
            ret group.Token(res).ToIdentifierToken()

    private fn ParseIf(group Group) Statement
        var start = group.Peek.Position

        if res = group.Accept(TokenType.If), res.Failure
            InvalidToken(group, "if", res)
            AdvanceLine(group)
            ret new BadStatementToken()
        
        ; "if" [name "=" expr ","] expr [":" statement]
        var name ?IdentifierToken = null
        var value ?Expression = null
        if res = group.Accept(TokenType.Identifier, TokenType.Assign), res.Success
            name = group.Token(res).ToIdentifierToken()
            value = ParseExpression(group)
            if commaRes = group.Accept(TokenType.Comma), commaRes.Failure
                InvalidToken(group, "if", commaRes)
                AdvanceLine(group)
                ret new BadStatementToken()
        
        var condition = ParseExpression(group)

        if group.Accept(TokenType.Colon).Success
            var ifStmt = new If(start, condition){LocalName = name, LocalValue = value}
            ifStmt.Statements.Add(ParseMethodStatementShort(group, true))
            if group.CurrentParentToken is Group pt
                ParseElse(pt, ifStmt)
            ret ifStmt

        AdvanceLine(group)
        if group.CurrentParentToken is Group indentBlock and indentBlock.Type == TokenType.IndentBlock and indentBlock.Peek is Group curLine
            if curLine.Peek.Type == TokenType.Is
                ;     "is" expr [":" statement]
                ;         {statements}
                var switchStmt = new Switch(start, condition){LocalName = name, LocalValue = value}
                for isRes = curLine.Accept(TokenType.Is), isRes.Success, isRes = curLine.Accept(TokenType.Is)
                    var caseExpr = ParseExpression(curLine)
                    var caseStmt = new Case(curLine.Token(isRes).Position, caseExpr)
                    switchStmt.Cases.Add(caseStmt)
                    ParseStatementOrIndentBlock(curLine, caseStmt.Statements)

                    if curLine.CurrentParentToken is Group pt
                        curLine = pt
                    else
                        break

                AdvanceLine(indentBlock)
                ret switchStmt
            else
                ;     {statements}
                var ifStmt = new If(start, condition){LocalName = name, LocalValue = value}
                for indentBlock.More
                    if indentBlock.Peek.IsGroup()
                        ifStmt.Statements.Add(ParseMethodStatement(indentBlock.Peek as Group))
                    else
                        throw new InvalidItemException()
                AdvanceLine(indentBlock)
                if group.CurrentParentToken is Group pt
                    ParseElse(pt, ifStmt)
                ret ifStmt

        ret new If(start, condition){LocalName = name, LocalValue = value}

    private fn ParseImport(group Group) ImportToken
        ; "use" name
        var importToken = new ImportToken(group.Position)

        if res = group.Accept(TokenType.Use, TokenType.Identifier), res.Failure
            InvalidToken(group, "use", res)
            group.Advance()
            ret importToken
        else
            importToken.Position = group.Token(res).Position
            importToken.NameParts.Add(group.Token(res, 1).Value)

        for res = group.Accept(TokenType.Dot, TokenType.Identifier),
                res.Success,
                res = group.Accept(TokenType.Dot, TokenType.Identifier)
            importToken.NameParts.Add(group.Token(res, 1).Value)

        AdvanceLine(group)

        ret importToken
    
    private fn ParseIndentBlock(group Group, statements List{Statement}, stmtFn Func{Group, Statement}) bool
        if group.Parent != null and group.Parent.Peek.Type == TokenType.IndentBlock and group.Parent.Peek is Group indentBlock
            for indentBlock.More
                if indentBlock.Peek.IsGroup()
                    statements.Add(stmtFn(indentBlock.Peek as Group))
                else
                    throw new InvalidItemException()
            group.Parent.Advance()
            ret true
        ret false

    private fn ParseIndexer(group Group, expr Expression) Expression
        ; "[" {arguments} "]"
        var argsExpr = new Arguments(group.Peek.Position, expr)
        if next = group.Next(), next.Type == TokenType.BracketGroup and next is Group bracketGroup
            if bracketGroup.More
                argsExpr.Values.Add(ParseExpression(bracketGroup))
                for bracketGroup.Accept(TokenType.Comma).Success and bracketGroup.More
                    argsExpr.Values.Add(ParseExpression(bracketGroup))
            else
                AddError("[code]", "indexer must have an argument", bracketGroup.Position)
            EnsureNoExtraTokens(bracketGroup)
        ret argsExpr

    private fn ParseInitializer(group Group) Statement
        ; name "=" expression
        if res = group.Accept(TokenType.Identifier, TokenType.Assign), res.Failure
            InvalidToken(group, "initializer", res)
            group.Advance()
            ret new BadStatementToken()
        else
            ret new Initializer(group.Token(res).Position, group.Token(res).ToIdentifierToken(), ParseExpression(group))

    private fn ParseInitializers(group Group, inits List{Statement})
        ; "{" {initializers} "}"
        if group.Peek.Type == TokenType.CurlyGroup and group.Next() is Group curlyGroup
            if curlyGroup.More
                inits.Add(ParseInitializer(curlyGroup))
                for curlyGroup.Accept(TokenType.Comma).Success and curlyGroup.More
                    inits.Add(ParseInitializer(curlyGroup))
            EnsureNoExtraTokens(curlyGroup)

    private fn ParseLocalConstant(group Group) Statement
        ; "val" name "=" expr
        var res = group.Accept(TokenType.Value, TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "val", res)
            AdvanceLine(group)
            ret new BadStatementToken()
        
        var position = group.Token(res).Position
        var nameIdentifierToken = group.Token(res, 1).ToIdentifierToken()

        if group.Accept(TokenType.Assign).Failure
            InvalidToken(group, "val", res)
            AdvanceLine(group)
            ret new BadStatementToken()
        
        var value = ParseExpression(group)

        AdvanceLine(group)
        ret new LocalConstant(position, nameIdentifierToken, value)

    private fn ParseLocalVariable(group Group) Statement
        ; "var" name [type] ["=" expr]
        var res = group.Accept(TokenType.Variable, TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "var", res)
            AdvanceLine(group)
            ret new BadStatementToken()
        
        var varStmt = new LocalVariable(group.Token(res).Position, group.Token(res, 1).ToIdentifierToken())

        if group.More and group.Peek.Type != TokenType.Assign
            varStmt.Type = ParseType(group)

        if group.Accept(TokenType.Assign).Success
            varStmt.Value = ParseExpression(group)

        AdvanceLine(group)
        ret varStmt

    private fn ParseMethodCall(group Group, expr Expression) Expression
        ; method "(" {arguments} ")"
        var argsExpr = new Arguments(group.Peek.Position, expr)
        if !ParseArguments(group, argsExpr.Values)
            AddError("[code]", "missing arguments", argsExpr.Position)
        ret argsExpr

    private fn ParseMethodDefinition(group Group, nameIdentifierToken IdentifierToken, generics List{Statement}) Statement
        ; "fn" name ["{" generics "}"] "(" {params} ")" [type] [":" statement]
        ;     {statements}
        var methodStmt = new Method(nameIdentifierToken.Position, nameIdentifierToken){Generics = generics}

        if !ParseParameters(group, methodStmt.Parameters)
            AddError("[code]", "missing parameters", nameIdentifierToken.Position)
        
        if group.More and group.Peek.Type != TokenType.Colon
            methodStmt.ReturnType = ParseType(group)
        
        ParseStatementOrIndentBlock(group, methodStmt.Statements)
        
        ret methodStmt

    private fn ParseMethodOrProperty(group Group) Statement
        var start = group.Peek
        var res = group.Accept(TokenType.Function)
        if res.Failure
            InvalidToken(group, "method or property", res)
            AdvanceLine(group)
            ret new BadStatementToken()

        if group.Peek.Type == TokenType.New
            ret ParseConstructorDefinition(group, start)
        
        res = group.Accept(TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "method or property", res)
            AdvanceLine(group)
            ret new BadStatementToken()
        
        var nameIdentifierToken = group.Token(res).ToIdentifierToken()
        var generics = new List{Statement}()
        ParseGenericDefinition(group, generics)

        if group.Peek.Type == TokenType.ParenthesisGroup
            ret ParseMethodDefinition(group, nameIdentifierToken, generics)
        
        ; todo - ret ParseProperty(group, nameIdentifierToken)

        AdvanceLine(group)
        ret new BadStatementToken()

    private fn ParseMethodStatement(group Group) Statement
        if !group.Tokens.Any()
            ret ParseSpace(group)
        ret group.Peek.Type ?
        {
            TokenType.Break is ParseBreak(group),
            TokenType.Comment is ParseComment(group),
            TokenType.Continue is ParseContinue(group),
            TokenType.DoubleColon is ParseBlock(group),
            TokenType.For is ParseFor(group),
            TokenType.If is ParseIf(group),
            TokenType.Return is ParseReturn(group),
            TokenType.Use is ParseUsing(group),
            TokenType.Value is ParseLocalConstant(group),
            TokenType.Variable is ParseLocalVariable(group),
            _ is ParseExpressionStatement(group),
        }
        ; todo - TokenType.Try is ParseTry(),
    
    private fn ParseMethodStatementShort(group Group, moveNextLine bool) Statement is group.Peek.Type ?
    {
        TokenType.Break is ParseBreak(group, moveNextLine),
        TokenType.Comment is ParseComment(group, moveNextLine),
        TokenType.Continue is ParseContinue(group, moveNextLine),
        TokenType.Return is ParseReturn(group, moveNextLine),
        _ is ParseExpressionStatement(group, moveNextLine),
    }

    private fn ParseNamespace(group Group) NamespaceToken
        ; "ns" namespace
        var namespaceToken = new NamespaceToken(group.Position)

        if res = group.Accept(TokenType.Namespace, TokenType.Identifier), res.Failure
            InvalidToken(group, "namespace", res)
            group.Advance()
        else
            namespaceToken.Position = group.Token(res).Position
            namespaceToken.NameParts.Add(group.Token(res, 1).Value)
        
        for res = group.Accept(TokenType.Dot, TokenType.Identifier),
                res.Success,
                res = group.Accept(TokenType.Dot, TokenType.Identifier)
            namespaceToken.NameParts.Add(group.Token(res, 1).Value)
        
        AdvanceLine(group)

        ret namespaceToken
    
    private fn ParseNullableType(group Group) Expression
        ; "?" type
        if res = group.Accept(TokenType.Question), res.Failure
            InvalidToken(group, "nullable type", res)
            group.Advance()
            ret new BadExpressionToken()
        else
            ret new NullableType(group.Token(res).Position, ParseType(group))
    
    private fn ParseNumber(group Group) Expression
        if res = group.Accept(TokenType.NumberLiteral), res.Success
            var numVal = group.Token(res).Value
            var numType = NumberType.Decimal

            if numVal.StartsWith("0b")
                numVal = numVal.Substring(2)
                numType = NumberType.Binary
            else if numVal.StartsWith("0x")
                numVal = numVal.Substring(2)
                numType = NumberType.Hexadecimal
            
            ret new NumberToken(group.Token(res).Position, numType, numVal)
        
        group.Advance()
        ret new BadExpressionToken()

    private fn ParseParameter(group Group) Statement
        ; name {modifiers} [type] ["=" expression]
        var res = group.Accept(TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "parameter", res)
        
        var paramStmt = new Parameter(group.Token(res).Position, group.Token(res).ToIdentifierToken())

        ; modifiers
        for group.Peek.Type.IsParameterModifier()
            paramStmt.Modifiers.Add(group.Next().ToParameterModifierToken())
        
        ; type
        if group.More and group.Peek.Type != TokenType.Comma and group.Peek.Type != TokenType.Assign
            paramStmt.Type = ParseType(group)
        
        ; default value
        if group.Accept(TokenType.Assign).Success
            paramStmt.Value = ParseExpression(group)
        
        ret paramStmt

    private fn ParseParameters(group Group, parameters List{Statement}) bool
        ; "(" {parameters} ")"
        if group.Peek.Type == TokenType.ParenthesisGroup and group.Next() is Group parenthesisGroup
            if parenthesisGroup.More
                parameters.Add(ParseParameter(parenthesisGroup))
                for parenthesisGroup.Accept(TokenType.Comma).Success and parenthesisGroup.More
                    parameters.Add(ParseParameter(parenthesisGroup))
            EnsureNoExtraTokens(parenthesisGroup)
            ret true
        ret false

    private fn ParseParenthesizedExpression(group Group) Expression
        if next = group.Next(), next.Type == TokenType.ParenthesisGroup
            ret ParseExpression(next as Group)
        ret new BadExpressionToken()
    
    private fn ParsePrimaryExpression(group Group) Expression
        var expr Expression
        if peekType = group.Peek.Type, peekType
            is TokenType.BracketGroup
                var bracketGroup = group.Peek as Group
                if bracketGroup.Tokens.Any()
                    expr = ParseArrayLiteral(group)
                else
                    expr = ParseArrayType(group)
            is TokenType.Function
            is TokenType.FunctionBlock
                expr = ParseAnonymousFunction(group)
            is TokenType.Identifier
                expr = ParseIdentifier(group)
            is TokenType.New
                expr = ParseConstructorCall(group)
            is TokenType.NumberLiteral
                expr = ParseNumber(group)
            is TokenType.ParenthesisGroup
                expr = ParseParenthesizedExpression(group)
            is TokenType.Question
                expr = ParseNullableType(group)
            is TokenType.StringGroup
                expr = ParseString(group)
            is _
                if peekType.IsType()
                    expr = ParseTypeToken(group)
                else if peekType.IsUnaryOperator()
                    expr = ParseUnaryOperator(group)
                else
                    var token = group.Next()
                    expr = token.Type ?
                    {
                        TokenType.Base is new BaseClassToken(token.Position),
                        TokenType.CharacterLiteral is new CharacterToken(token.Position, token.Value),
                        TokenType.Default is new DefaultValueToken(token.Position),
                        TokenType.Discard is new DiscardToken(token.Position),
                        TokenType.False is new LiteralToken(token.Position, LiteralType.False),
                        TokenType.Null is new LiteralToken(token.Position, LiteralType.Null),
                        TokenType.This is new CurrentObjectInstanceToken(token.Position),
                        TokenType.True is new LiteralToken(token.Position, LiteralType.True),
                        _ is new BadExpressionToken()
                    }
        
        var loop = true
        for loop
            if res = group.Accept(TokenType.Dot, TokenType.Identifier), res.Success
                expr = new BinaryOperator(expr.Position, expr,
                    group.Token(res).ToBinaryOperatorToken(),
                    group.Token(res, 1).ToIdentifierToken())
            else if ndRes = group.Accept(TokenType.NullDot, TokenType.Identifier), ndRes.Success
                expr = new BinaryOperator(expr.Position, expr,
                    group.Token(res).ToBinaryOperatorToken(),
                    group.Token(res, 1).ToIdentifierToken())
            else
                if token = group.Peek, token.Type
                    is TokenType.BracketGroup
                        expr = ParseIndexer(group, expr)
                    is TokenType.CurlyGroup
                        expr = ParseGenericArguments(group, expr)
                    is TokenType.ParenthesisGroup
                        expr = ParseMethodCall(group, expr)
                    is TokenType.Question
                        expr = ParseConditional(group, expr)
                    is _
                        loop = false
        ret expr

    private fn ParseReturn(group Group, moveNextLine bool = true) Statement
        ; "ret" [expr]
        if res = group.Accept(TokenType.Return), res.Failure
            InvalidToken(group, "return", res)
            AdvanceLine(group)
            ret new BadStatementToken()
        else
            var returnStmt = new Return(group.Token(res).Position)
            if group.More
                returnStmt.Value = ParseExpression(group)
            if moveNextLine
                AdvanceLine(group)
            ret returnStmt

    private fn ParseSpace(group Group) Statement
        if group.Parent != null and group.Parent.IsBlock() and group.Parent is Group block
            var size = 1
            block.Advance()
            for block.Peek is Group line and line.Type == TokenType.Line and !line.Tokens.Any()
                size += 1
                block.Advance()
            ret new SpaceToken(group.Position, size)
        AddError("[code]", "wasn't a block while parsing space", group.Position)
        ret new BadStatementToken()
    
    private fn ParseStatementOrIndentBlock(group Group, statements List{Statement})
        ; ":" statement
        if group.Accept(TokenType.Colon).Success
            statements.Add(ParseMethodStatementShort(group, true))
        else
            ; {statements}
            AdvanceLine(group)
            ParseIndentBlock(group, statements, ParseMethodStatement)

    private fn ParseString(group Group) Expression
        if next = group.Next(), next.Type == TokenType.StringGroup and next is Group stringGroup
            var stringExpr = new Core.SyntaxTree.String(group.Peek.Position)
            stringExpr.Lines.Add(ParseStringLine(stringGroup))
            for res = group.Accept(TokenType.DoubleDot, TokenType.StringGroup), res.Success,
                    res = group.Accept(TokenType.DoubleDot, TokenType.StringGroup)
                stringExpr.Lines.Add(ParseStringLine(group.Token(res, 1) as Group))
            ret stringExpr
        ret new BadExpressionToken()
    
    private fn ParseStringLine(group Group) List{Expression}
        var line = new List{Expression}()
        var loop = true
        for group.More and loop
            if token = group.Next(), token.Type
                is TokenType.StringLiteral
                    line.Add(new StringToken(token.Position, token.Value))
                is TokenType.CurlyGroup
                    var curlyGroup = token as Group
                    line.Add(ParseExpression(curlyGroup))
                    EnsureNoExtraTokens(curlyGroup)
                is _
                    loop = false
                    AddError("[code]", "invalid token in string: {token}", token.Position)
        EnsureNoExtraTokens(group)
        ret line

    private fn ParseThrowOr(parseFn Func{Group, Expression}, group Group) Expression
        if group.Peek.Type != TokenType.Throw
            ret parseFn(group)

        ; accept throw
        var start = group.Next()
        ret new Throw(start.Position, ParseExpression(group))

    private fn ParseType(group Group) Expression
        var typeExpr Expression
        if group.Peek.Type
            is TokenType.BracketGroup
                ret ParseArrayType(group)
            is TokenType.Identifier
                typeExpr = ParseIdentifier(group)
            is TokenType.Question
                ret ParseNullableType(group)
            is _
                if group.Peek.Type.IsType()
                    typeExpr = ParseTypeToken(group)
                else
                    AddError("code", "invalid token in type: {group.Peek}", group.Peek.Position)
                    ret new BadExpressionToken()
        
        var loop = true
        for loop
            if group.Peek.Type == TokenType.CurlyGroup
                typeExpr = ParseGenericArguments(group, typeExpr)
            else if res = group.Accept(TokenType.Dot, TokenType.Identifier), res.Success
                typeExpr = new BinaryOperator(
                    typeExpr.Position,
                    typeExpr,
                    new BinaryOperatorToken(group.Token(res).Position, BinaryOperatorType.Dot),
                    group.Token(res, 1).ToIdentifierToken()
                )
            else
                loop = false
        
        ret typeExpr

    private fn ParseTypeToken(group Group) Expression
        var pos = group.Peek.Position
        var ident = new IdentifierToken(pos, group.Peek.Type ?
            {
                TokenType.String is "String",
                TokenType.Character is "Char",
                TokenType.Boolean is "Boolean",
                TokenType.I8 is "SByte",
                TokenType.I16 is "Int16",
                TokenType.I32 is "Int32",
                TokenType.I64 is "Int64",
                TokenType.U8 is "Byte",
                TokenType.U16 is "UInt16",
                TokenType.U32 is "UInt32",
                TokenType.U64 is "UInt64",
                TokenType.F32 is "Single",
                TokenType.F64 is "Double",
                TokenType.Decimal is "Decimal",
                _ is "Error",
            })
        group.Advance()
        ret new BinaryOperator(pos, new IdentifierToken(pos, "System"), new BinaryOperatorToken(pos, BinaryOperatorType.Dot), ident)

    private fn ParseUnaryOperator(group Group) Expression
        ret new UnaryOperator(group.Peek.Position, group.Next().ToUnaryOperatorToken(), ParsePrimaryExpression(group))

    private fn ParseUsing(group Group) Statement
        ; "use" name "=" expr [":" statement]
        ;     {statements}
        var res = group.Accept(TokenType.Use, TokenType.Identifier, TokenType.Assign)
        if res.Failure
            InvalidToken(group, "using", res)
            AdvanceLine(group)
            ret new BadStatementToken()

        var usingStmt = new Using(
            group.Token(res).Position,
            group.Token(res, 1).ToIdentifierToken(),
            ParseExpression(group)
        )

        ParseStatementOrIndentBlock(group, usingStmt.Statements)

        ret usingStmt

;     ; Returns the error parse result, or null on success.
;     private fn ParseGetSet(propDef Property) ?ParseResult{Statement}
;         var res AcceptResult
;         if Peek.Type == TokenType.Get
;             if Accept(TokenType.Get, TokenType.Is).Success
;                 ; get is [expr]

;                 var exprResult = ParseExpression()
;                 if exprResult.Error and exprResult.Result is ErrorExpression exp
;                     ret ErrorStatement(exp)
;                 propDef.GetStatements.Add(new Return(exprResult.Result.Position) { Value = exprResult.Result })
;                 res = Accept(TokenType.EOL)
;                 if res.Failure
;                     ret InvalidTokenErrorStatement("Invalid token in get", res)
;             else
;                 ; get
;                 ;     [statements]

;                 res = Accept(TokenType.Get, TokenType.EOL, TokenType.Indent)
;                 if res.Failure
;                     ret InvalidTokenErrorStatement("Invalid token in get", res)

;                 for Peek.Type != TokenType.Dedent
;                     var stmt = ParseMethodStatement()
;                     if stmt.Error
;                         ret stmt
;                     propDef.GetStatements.Add(stmt.Result)

;                 res = Accept(TokenType.Dedent)
;                 if res.Failure
;                     ret InvalidTokenErrorStatement("Invalid token in get", res)
;         else
;             res = Accept(TokenType.Set, TokenType.LeftParenthesis, TokenType.Identifier, TokenType.RightParenthesis)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in set", res)
;             propDef.SetParameterName = GetToken(res, 2).Value

;             if Accept(TokenType.Is).Success
;                 ; set(v) is [statement]

;                 var stmtResult = ParseMethodStatement()
;                 if stmtResult.Error
;                     ret stmtResult
;                 propDef.SetStatements.Add(stmtResult.Result)
;             else
;                 ; set(v)
;                 ;     [statements]

;                 res = Accept(TokenType.EOL, TokenType.Indent)
;                 if res.Failure
;                     ret InvalidTokenErrorStatement("Invalid token in set", res)

;                 for Peek.Type != TokenType.Dedent
;                     var stmt = ParseMethodStatement()
;                     if stmt.Error
;                         ret stmt
;                     propDef.SetStatements.Add(stmt.Result)

;                 res = Accept(TokenType.Dedent)
;                 if res.Failure
;                     ret InvalidTokenErrorStatement("Invalid token in set", res)

;         ret null

;     private fn ParseInterface(modifiers List{Modifier}) ParseResult{Statement}
;         var res = Accept(TokenType.Interface, TokenType.Identifier)

;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in interface", res)

;         var intf = new Interface(GetToken(res, 1).Position, modifiers, GetToken(res, 1).Value)

;         ParseGenericNames(intf.GenericNames)

;         if Accept(TokenType.Has).Success
;             var interfaceType = ParseType()
;             if !interfaceType.Error
;                 intf.Interfaces.Add(interfaceType.Result)

;             for Accept(TokenType.Comma).Success
;                 interfaceType = ParseType()
;                 if !interfaceType.Error
;                     intf.Interfaces.Add(interfaceType.Result)

;         res = Accept(TokenType.EOL, TokenType.Indent)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in interface", res)

;         for Peek.Type != TokenType.Dedent
;             var ist = ParseInterfaceStatement()
;             if ist.Error
;                 ret ist
;             intf.Statements.Add(ist.Result)

;         res = Accept(TokenType.Dedent)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in interface", res)

;         ret new ParseResult{Statement}(intf)

;     private fn ParseInterfaceStatement() ParseResult{Statement}
;         var startToken = Peek
;         var size = 0
;         for Peek.Type == TokenType.EOL
;             Next()
;             size += 1

;         if size > 0
;             ret new ParseResult{Statement}(new Space(startToken.Position, size))

;         if Peek.Type == TokenType.Comment
;             ret ParseComment()

;         var modifiers = new List{Modifier}()
;         var modRes = ParseModifiers(modifiers)
;         if modRes != null
;             ret modRes

;         var res = Accept(TokenType.Function, TokenType.Identifier)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in interface", res)

;         var fnPos = GetToken(res).Position
;         var name = GetToken(res, 1).Value

;         if Peek.Type == TokenType.LeftParenthesis or Peek.Type == TokenType.LeftCurly
;             ret ParseMethodSignature(modifiers, fnPos, name)

;         ret ParsePropertySignature(modifiers, fnPos, name)

;     private fn ParseMethodSignature(modifiers List{Modifier}, pos Position, name str) ParseResult{Statement}
;         ; [modifiers] fn [name]([params])
;         ; [modifiers] fn [name]([params]) [type]

;         var methodSig = new MethodSignature(pos, modifiers, name)

;         ParseGenericNames(methodSig.GenericNames)
;         ParseParameters(methodSig.Parameters)

;         ; return type
;         if Peek.Type != TokenType.EOL
;             var typeResult = ParseType()
;             if typeResult.Error and typeResult.Result is ErrorExpression ex
;                 ret ErrorStatement(ex)
;             methodSig.ReturnType = typeResult.Result

;         var res = Accept(TokenType.EOL)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in method signature", res)

;         ret new ParseResult{Statement}(methodSig)

;     ; Returns null on success, or the error statement.
;     private fn ParseModifiers(modifiers List{Modifier}) ?ParseResult{Statement}
;         for Peek.Type.IsModifier()
;             var mod = new Modifier(Peek.Position, Peek.Type.ToModifier())
;             modifiers.Add(mod)
;             Next()
;             if Accept(TokenType.LeftCurly).Success
;                 var typeRes = ParseType()
;                 if typeRes.Error and typeRes.Result is ErrorExpression ex
;                     ret ErrorStatement(ex)

;                 mod.Argument = typeRes.Result

;                 var res = Accept(TokenType.RightCurly)
;                 if res.Failure
;                     ret InvalidTokenErrorStatement("Invalid token in modifier", res)

;         ret null

;     private fn ParseNestedPrimaryExpression() ParseResult{Expression}
;         var leftResult ParseResult{Expression}
;         if Peek.Type == TokenType.Identifier
;             leftResult = ParseIdentifier()
;         else if Peek.Type == TokenType.LeftParenthesis
;             leftResult = ParseMethodCall(null)
;         else if Peek.Type == TokenType.LeftBracket
;             leftResult = ParseIndexer(null)
;         else if Peek.Type == TokenType.LeftCurly
;             leftResult = ParseGeneric(null)
;         else
;             var token = Next()
;             ret ErrorExpression("Invalid token in nested expression: " + token, token.Position)
        
;         if leftResult.Error
;             ret leftResult

;         var loop bool
;         for
;             loop = true
;             var res = Accept(TokenType.Dot, TokenType.Identifier)
;             if res.Success
;                 leftResult = new ParseResult{Expression}(new BinaryOperator(
;                     leftResult.Result.Position,
;                     leftResult.Result,
;                     BinaryOperatorType.Dot,
;                     new Identifier(GetToken(res, 1).Position, GetToken(res, 1).Value)
;                 ))
;             else
;                 res = Accept(TokenType.NullDot, TokenType.Identifier)
;                 if res.Success
;                     leftResult = new ParseResult{Expression}(new BinaryOperator(
;                         leftResult.Result.Position,
;                         leftResult.Result,
;                         BinaryOperatorType.NullDot,
;                         new Identifier(GetToken(res, 1).Position, GetToken(res, 1).Value)
;                     ))
;                 else if Peek.Type == TokenType.LeftParenthesis
;                     leftResult = ParseMethodCall(leftResult.Result)
;                 else if Peek.Type == TokenType.LeftBracket
;                     leftResult = ParseIndexer(leftResult.Result)
;                 else if Peek.Type == TokenType.LeftCurly
;                     leftResult = ParseGeneric(leftResult.Result)
;                 else if Peek.Type == TokenType.Question
;                     leftResult = ParseConditional(leftResult.Result)
;                 else
;                     loop = false
            
;             if !loop
;                 break

;         ret leftResult

;     private fn ParseProperty(modifiers List{Modifier}, nameToken Token) ParseResult{Statement}
;         ; property
;         ; [modifiers] fn [name] [type] [= [expr]]
;         ; [modifiers] fn [name] [type] [get and/or set] [= [expr]]
;         ; [modifiers] fn [name] [type] is [expr]
;         ; [modifiers] fn [name] [type]
;         ;     [statements]
;         ; [modifiers] fn [name] [type] [= [expr]]
;         ;     get is [expr]
;         ;     set is [statement]
;         ; [modifiers] fn [name] [type] [= [expr]]
;         ;     get
;         ;         [statements]
;         ;     set(v)
;         ;         [statements]

;         var res AcceptResult

;         var typeResult = ParseType()
;         if typeResult.Error and typeResult.Result is ErrorExpression ex
;             ret ErrorStatement(ex)

;         var propDef = new Property(nameToken.Position, modifiers, nameToken.Value, typeResult.Result)

;         ; [modifiers] fn [name] [type] [get and/or set]
;         if Peek.Type == TokenType.Get or Peek.Type == TokenType.Set
;             var getSet = Next()
;             var other = TokenType.Set
;             if getSet.Type == TokenType.Get
;                 propDef.SetSpecified = false
;             else
;                 propDef.GetSpecified = false
;                 other = TokenType.Get

;             res = Accept(TokenType.Comma, other)
;             if res.Success
;                 if GetToken(res, 1).Type == TokenType.Get
;                     propDef.GetSpecified = true
;                 else
;                     propDef.SetSpecified = true
;         else if Accept(TokenType.Is).Success
;             ; [is [expr]]

;             var exprResult = ParseExpression()
;             if exprResult.Error and exprResult.Result is ErrorExpression exp
;                 ret ErrorStatement(exp)
;             propDef.GetStatements.Add(new Return(exprResult.Result.Position) { Value = exprResult.Result })
;             res = Accept(TokenType.EOL)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in property", res)
;             ret new ParseResult{Statement}(propDef)

;         ; [= [expr]]
;         if Accept(TokenType.Assign).Success
;             var exprResult = ParseExpression()
;             if exprResult.Error and exprResult.Result is ErrorExpression exp
;                 ret ErrorStatement(exp)
;             propDef.Value = exprResult.Result

;         res = Accept(TokenType.EOL)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in property", res)

;         if Accept(TokenType.Indent).Success
;             if Peek.Type == TokenType.Get or Peek.Type == TokenType.Set
;                 ; [modifiers] fn [name] [type]
;                 ;     get is [expr]
;                 ;     set(v) is [statement]
;                 ; [modifiers] fn [name] [type]
;                 ;     get
;                 ;         [statements]
;                 ;     set(v)
;                 ;         [statements]

;                 var other = Peek.Type == TokenType.Get ? TokenType.Set : TokenType.Get

;                 var getSetResult = ParseGetSet(propDef)
;                 if getSetResult != null
;                     ret getSetResult

;                 if Peek.Type == other
;                     getSetResult = ParseGetSet(propDef)
;                     if getSetResult != null
;                         ret getSetResult
;             else
;                 ; [modifiers] fn [name] [type]
;                 ;     [statements]

;                 for Peek.Type != TokenType.Dedent
;                     var stmt = ParseMethodStatement()
;                     if stmt.Error
;                         ret stmt
;                     propDef.GetStatements.Add(stmt.Result)

;             res = Accept(TokenType.Dedent)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in property", res)

;         ret new ParseResult{Statement}(propDef)

;     private fn ParsePropertySignature(modifiers List{Modifier}, pos Position, name str) ParseResult{Statement}
;         ; [modifiers] fn [name] [type]
;         ; [modifiers] fn [name] [type] [get and/or set]

;         var res AcceptResult

;         var typeResult = ParseType()
;         if typeResult.Error and typeResult.Result is ErrorExpression ex
;             ret ErrorStatement(ex)

;         var propSig = new PropertySignature(pos, modifiers, name, typeResult.Result)

;         if Peek.Type == TokenType.Get or Peek.Type == TokenType.Set
;             var getSet = Next()
;             var other = TokenType.Set
;             if getSet.Type == TokenType.Get
;                 propSig.SetSpecified = false
;             else
;                 propSig.GetSpecified = false
;                 other = TokenType.Get

;             res = Accept(TokenType.Comma, other)
;             if res.Success
;                 if GetToken(res, 1).Type == TokenType.Get
;                     propSig.GetSpecified = true
;                 else
;                     propSig.SetSpecified = true

;         res = Accept(TokenType.EOL)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in property signature", res)

;         ret new ParseResult{Statement}(propSig)

;     private fn ParseStruct(modifiers List{Modifier}) ParseResult{Statement}
;         var res = Accept(TokenType.Struct, TokenType.Identifier)

;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in struct", res)

;         var structRes = new Struct(GetToken(res, 1).Position, modifiers, GetToken(res, 1).Value)

;         ParseGenericNames(structRes.GenericNames)

;         if Accept(TokenType.Has).Success
;             var interfaceType = ParseType()
;             if !interfaceType.Error
;                 structRes.Interfaces.Add(interfaceType.Result)

;             for Accept(TokenType.Comma).Success
;                 interfaceType = ParseType()
;                 if !interfaceType.Error
;                     structRes.Interfaces.Add(interfaceType.Result)

;         res = Accept(TokenType.EOL, TokenType.Indent)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in struct", res)

;         for Peek.Type != TokenType.Dedent
;             var stmt = ParseClassStatement()
;             if stmt.Error
;                 ret stmt
;             structRes.Statements.Add(stmt.Result)

;         res = Accept(TokenType.Dedent)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in struct {structRes.Name}", res)

;         ret new ParseResult{Statement}(structRes)

;     private fn ParseTry() ParseResult{Statement}
;         ; try
;         ;     [statements]
;         ; catch
;         ; catch [type]
;         ; catch [type] [name]
;         ;     [statements]
;         ; fin
;         ;     [statements]

;         var res = Accept(TokenType.Try, TokenType.EOL, TokenType.Indent)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in try", res)

;         var tryDef = new Try(GetToken(res).Position)

;         for Peek.Type != TokenType.Dedent
;             var stmt = ParseMethodStatement()
;             if stmt.Error
;                 ret stmt
;             tryDef.Statements.Add(stmt.Result)

;         res = Accept(TokenType.Dedent)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in try", res)

;         var catchRes = Accept(TokenType.Catch)
;         for catchRes.Success
;             var catchStmt = new Catch(GetToken(catchRes).Position)
;             tryDef.Catches.Add(catchStmt)

;             if Peek.Type != TokenType.EOL
;                 var typeRes = ParseType()
;                 if typeRes.Error and typeRes.Result is ErrorExpression ex
;                     ret ErrorStatement(ex)

;                 catchStmt.Type = typeRes.Result
;                 res = Accept(TokenType.Identifier)
;                 if res.Success
;                     catchStmt.Name = GetToken(res).Value

;             res = Accept(TokenType.EOL, TokenType.Indent)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in catch", res)

;             for Peek.Type != TokenType.Dedent
;                 var stmt = ParseMethodStatement()
;                 if stmt.Error
;                     ret stmt
;                 catchStmt.Statements.Add(stmt.Result)

;             res = Accept(TokenType.Dedent)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in catch", res)

;             catchRes = Accept(TokenType.Catch)

;         if Accept(TokenType.Finally, TokenType.EOL, TokenType.Indent).Success
;             for Peek.Type != TokenType.Dedent
;                 var stmt = ParseMethodStatement()
;                 if stmt.Error
;                     ret stmt
;                 tryDef.FinallyStatements.Add(stmt.Result)

;             res = Accept(TokenType.Dedent)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in finally", res)

;         ret new ParseResult{Statement}(tryDef)
