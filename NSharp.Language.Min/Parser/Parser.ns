use NSharp.Core
use NSharp.Core.SyntaxTree
use NSharp.Language.Min.TokenTree

ns NSharp.Language.Min

public class Parser
    private fn Settings Settings
    private fn Result LoadResult
    private fn CurrentIndex int = 0

    public fn new(settings Settings, result LoadResult)
        Settings = settings
        Result = result
    
    private fn AddError(code str, message str, position Position)
        Result.Diagnostics.Add(new Diagnostic(Severity.Error, code, message, position))
    
    private fn InvalidToken(group Group, type str, result AcceptResult)
        var token = group.ErrorToken(result)
        var missed = result.MissedTokenType
        var error = "Invalid token in {type} when looking for {missed}: {token}"
        AddError("[code]", error, token.Position)
    
    private fn AdvanceLine(group Group)
        EnsureNoExtraTokens(group)
        group.AdvanceParent()
    
    private fn EnsureNoExtraTokens(group Group)
        for i = group.CurrentIndex, i < group.Tokens.Count, i += 1
            AddError("[code]", "extra token {group.Tokens[i]}", group.Tokens[i].Position)

    public fn Parse(fileName str) Core.SyntaxTree.File
        var builder = new TokenTreeBuilder(fileName, Settings, Result.Diagnostics)

        var file = ParseFile(builder.TokenTree, fileName)

        if Settings.PrintSyntaxTree
            file.Accept(new SyntaxTreePrinterVisitor())

        return file
    
    private fn ParseAnonymousFunction(group Group) Expression
        ; "fn" "(" [params] ")" [type] ":" statement
        ; "fn" "(" [params] ")" [type]
        ;     {statements}
        ; "/fn"
        var anonFnExpr = new AnonymousFunction(group.Peek.Position)

        if next = group.Next(), next.Type == TokenType.Function
            ; parameters
            if !ParseParameters(group, anonFnExpr.Parameters)
                AddError("[code]", "missing parameters", anonFnExpr.Position)

            ; optional return type
            if group.More and group.Peek.Type != TokenType.Colon
                anonFnExpr.ReturnType = ParseType(group)
            
            ; ":" statement
            if group.Accept(TokenType.Colon).Success
                anonFnExpr.Statements.Add(ParseMethodStatementShort(group, false))
            
        else if next is Group fnBlock and fnBlock.Type == TokenType.FunctionBlock and fnBlock.Peek is Group line and line.Type == TokenType.Line
            ; parameters
            if !ParseParameters(line, anonFnExpr.Parameters)
                AddError("[code]", "missing parameters", anonFnExpr.Position)
            
            ; optional return type
            if line.More
                anonFnExpr.ReturnType = ParseType(line)

            ; {statements}
            AdvanceLine(line)
            ParseIndentBlock(line, anonFnExpr.Statements, ParseMethodStatement)
        else
            AddError("[code]", "missing fn", anonFnExpr.Position)

        return anonFnExpr

    private fn ParseArrayLiteral(group Group) Expression
        ; "[" [expressions] "]"
        if next = group.Next(), next.Type == TokenType.BracketGroup and next is Group bracketGroup
            var arrayExpr = new ArrayLiteral(bracketGroup.Position)
            if bracketGroup.More
                arrayExpr.Values.Add(ParseExpression(bracketGroup))
                for bracketGroup.Accept(TokenType.Comma).Success and bracketGroup.More
                    arrayExpr.Values.Add(ParseExpression(bracketGroup))
            EnsureNoExtraTokens(bracketGroup)
            return arrayExpr
        return new BadExpressionToken()
    
    private fn ParseArgument(group Group) Expression
        ; [name "="] ["out" | "ref"] expression
        var startPos = group.Peek.Position
        var name ?Token = null
        if res = group.Accept(TokenType.Identifier, TokenType.Assign), res.Success
            name = group.Token(res)
        
        ; modifiers
        var modifiers = new List{ArgumentModifierToken}()
        for group.Peek.Type.IsArgumentModifier()
            modifiers.Add(group.Next().ToArgumentModifierToken())
        
        var argStmt = new Argument(startPos, modifiers, ParseExpression(group))
        if name != null
            argStmt.Name = name.ToIdentifierToken()
        
        return argStmt

    private fn ParseArguments(group Group, args List{Expression}) bool
        ; "(" {arguments} ")"
        if group.Peek.Type == TokenType.ParenthesisGroup and group.Next() is Group parenthesisGroup
            if parenthesisGroup.More
                args.Add(ParseArgument(parenthesisGroup))
                for parenthesisGroup.Accept(TokenType.Comma).Success and parenthesisGroup.More
                    args.Add(ParseArgument(parenthesisGroup))
            EnsureNoExtraTokens(parenthesisGroup)
            return true
        return false

    private fn ParseArrayType(group Group) Expression
        ; "[" {,} "]" type
        if next = group.Next(), next.Type == TokenType.BracketGroup and next is Group bracketGroup
            if bracketGroup.Tokens.All(fn(t) : t.Type == TokenType.Comma)
                return new ArrayType(bracketGroup.Position, ParseType(group), bracketGroup.Tokens.Count + 1)
            else
                AddError("[code]", "an array type should only have commas in the []s", bracketGroup.Position)
        return new BadExpressionToken()

    private fn ParseAssignment(group Group, left Expression, moveNextLine bool = true) Statement
        var op = group.Next().ToAssignmentOperatorToken()
        var right = ParseExpression(group)
        if moveNextLine
            AdvanceLine(group)
        return new Assignment(left.Position, left, op, right)
    
    private fn ParseAttribute(group Group) Expression
        ; [qualifier ":"] expression
        var start = group.Peek.Position
        var res = group.Accept(TokenType.Identifier, TokenType.Colon)
        var attributeExpr = new Core.SyntaxTree.Attribute(start, ParsePrimaryExpression(group))
        if res.Success
            attributeExpr.Qualifier = group.Token(res).ToIdentifierToken()
        return attributeExpr

    private fn ParseAttributeBlock(group Group, stmtFn Func{Group, Statement}) Statement
        ; {attrs}
        ;     {statements}
        var attributeBlockStmt = new AttributeBlock(group.Peek.Position)
        var currentLine = group
        for
            for currentLine.Peek.Type == TokenType.Identifier
                attributeBlockStmt.Attributes.Add(ParseAttribute(currentLine))
            if currentLine.More
                ; {attrs} statement
                attributeBlockStmt.Statements.Add(stmtFn(currentLine))
                return attributeBlockStmt
            else
                AdvanceLine(currentLine)
                if currentLine.CurrentParentToken is Group nextLine
                    ; {attrs}
                    if nextLine.Type == TokenType.Line
                        currentLine = nextLine
                    else if nextLine.Type == TokenType.IndentBlock
                        ParseIndentBlock(nextLine, attributeBlockStmt.Statements, stmtFn)
                        return attributeBlockStmt
                    else
                        AddError("[code]", "invalid block type {nextLine.Type} in attribute block", nextLine.Position)
                        return attributeBlockStmt
                else
                    AddError("[code]", "invalid block type {currentLine.CurrentParentToken.Type} in attribute block",
                        currentLine.CurrentParentToken.Position)
                    return attributeBlockStmt

    private fn ParseBinaryOperatorRightSide(group Group, leftPrecedence int, left Expression) Expression
        for
            var tokenPrecedence = group.Peek.Precedence()

            ; If this is a binary operator that binds at least as tightly as the
            ; current operator then consume it, otherwise we're done.
            if tokenPrecedence < leftPrecedence
                return left

            var op = group.Next()
            var right = op.Type.IsOperatorCanThrow() ? ParseThrowOr(ParsePrimaryExpression, group) : ParsePrimaryExpression(group)
            
            ; If it's a named expression (currently only 'is') then accept the
            ; next token as the name if it's a literal.
            if op.Type == TokenType.Is and group.Peek.Type == TokenType.Identifier
                right = new NamedExpression(right.Position, right, group.Next().ToIdentifierToken())

            ; If the binary operator binds less tightly with the right than the operator
            ; after the right, let the pending operator take the right as its left.
            if tokenPrecedence < group.Peek.Precedence()
                right = ParseBinaryOperatorRightSide(group, tokenPrecedence + 1, right)

            ; Merge left and right.
            left = new BinaryOperator(left.Position, left, op.ToBinaryOperatorToken(), right)

    private fn ParseBlock(group Group) Statement
        var blockStmt = new Core.SyntaxTree.Block(group.Peek.Position)
        if res = group.Accept(TokenType.DoubleColon), res.Failure
            InvalidToken(group, "block", res)
        AdvanceLine(group)
        ParseIndentBlock(group, blockStmt.Statements, ParseMethodStatement)
        return blockStmt

    private fn ParseBreak(group Group, moveNextLine bool = true) Statement
        if res = group.Accept(TokenType.Break), res.Success
            if moveNextLine
                AdvanceLine(group)
            return new BreakToken(group.Token(res).Position)
        else
            InvalidToken(group, "break", res)
            AdvanceLine(group)
            return new BadStatementToken()

    private fn ParseClass(group Group) Statement
        ; "class" name ["{" {generics} "}"] ["is" base] ["has" interfaces]
        var res = group.Accept(TokenType.Class, TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "class", res)
            group.Advance()
            return new BadStatementToken()
        
        var classStmt = new Class(group.Token(res).Position, group.Token(res, 1).ToIdentifierToken())

        ParseGenericDefinition(group, classStmt.Generics)

        if group.Accept(TokenType.Is).Success
            classStmt.Base = ParseType(group)

        if group.Accept(TokenType.Has).Success
            classStmt.Interfaces.Add(ParseType(group))
            for group.Accept(TokenType.Comma).Success
                classStmt.Interfaces.Add(ParseType(group))

        AdvanceLine(group)

        ParseIndentBlock(group, classStmt.Statements, ParseClassStatement)

        return classStmt
    
    private fn ParseClassStatement(group Group) Statement
        if !group.Tokens.Any()
            return ParseSpace(group)
        if group.Peek.Type
            is TokenType.Class
                return ParseClass(group)
            is TokenType.Comment
                return ParseComment(group)
            is TokenType.Delegate
                return ParseDelegate(group)
            is TokenType.Enum
                return ParseEnum(group)
            is TokenType.Function
                return ParseMethodOrPropertyDefinition(group)
            is TokenType.Interface
                return ParseInterface(group)
            is TokenType.Struct
                return ParseStruct(group)
            is TokenType.Value
                return ParseConstant(group)
            is TokenType.Variable
                return ParseField(group)
            is _
                return ParseAttributeBlock(group, ParseClassStatement)

    private fn ParseComment(group Group, moveNextLine bool = true) Statement
        ; ";" comment
        if res = group.Accept(TokenType.Comment), res.Failure
            InvalidToken(group, "comment", res)
            AdvanceLine(group)
            return new BadStatementToken()
        else
            var commentStmt = new CommentToken(group.Token(res).Position, group.Token(res).Value)
            if commentStmt.Value.StartsWith(";")
                commentStmt.Value = commentStmt.Value.Substring(1)
                commentStmt.IsDocumentation = true
            if moveNextLine
                AdvanceLine(group)
            return commentStmt
    
    private fn ParseCondition(group Group) Statement
        var expr = ParseExpression(group)

        if res = group.Accept(TokenType.Colon), res.Failure
            InvalidToken(group, "condition", res)
            group.Advance()
            return new BadStatementToken()
        
        ; Condition results can be a throw.
        var result = ParseThrowOr(ParseExpression, group)

        return new Condition(expr.Position, expr, result)
    
    private fn ParseConditional(group Group, expr Expression) Expression
        ; expr "?" true expr ":" false expr
        ; expr "?" "{" value ":" result {"," value ":" result} "}"
        if res = group.Accept(TokenType.Question), res.Failure
            InvalidToken(group, "conditional", res)
            group.Advance()
            return new BadExpressionToken()
        
        var conditionalExpr = new Conditional(expr.Position, expr)

        if group.Peek.Type != TokenType.CurlyGroup
            ; Condition results can be a throw.
            var trueRes = ParseThrowOr(ParseExpression, group)
            conditionalExpr.Conditions.Add(new Condition(
                trueRes.Position,
                new LiteralToken(trueRes.Position, LiteralType.True),
                trueRes
            ))

            if res = group.Accept(TokenType.Colon), res.Failure
                InvalidToken(group, "conditional", res)
                group.Advance()
                return conditionalExpr
            
            ; Condition results can be a throw.
            var falseRes = ParseThrowOr(ParseExpression, group)
            conditionalExpr.Conditions.Add(new Condition(
                falseRes.Position,
                new LiteralToken(falseRes.Position, LiteralType.False),
                falseRes
            ))
        else
            var curlyGroup = group.Next() as Group
            if curlyGroup.More
                conditionalExpr.Conditions.Add(ParseCondition(curlyGroup))
                for curlyGroup.Accept(TokenType.Comma).Success and curlyGroup.More
                    conditionalExpr.Conditions.Add(ParseCondition(curlyGroup))
            else
                AddError("[code]", "a conditional should have at least one condition", curlyGroup.Position)
            EnsureNoExtraTokens(curlyGroup)
        
        return conditionalExpr

    private fn ParseConstant(group Group) Statement
        ; "val" name type ["=" expr]
        var res = group.Accept(TokenType.Value, TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "constant", res)
            AdvanceLine(group)
            return new BadStatementToken()

        var constStmt = new Core.SyntaxTree.Constant(group.Token(res).Position,
            group.Token(res, 1).ToIdentifierToken(),
            ParseType(group)
        )

        if group.Accept(TokenType.Assign).Success
            constStmt.Value = ParseExpression(group)
        
        AdvanceLine(group)
        return constStmt

    private fn ParseConstructorCall(group Group) Expression
        ; "new" [type] "(" [args] ")" ["{" [initializers] "}"]
        var res = group.Accept(TokenType.New)
        if res.Failure
            InvalidToken(group, "constructor call", res)
            group.Advance()
            return new BadExpressionToken()
        
        var ctorExpr = new ConstructorCall(group.Token(res).Position)

        if group.More and group.Peek.Type != TokenType.CurlyGroup and group.Peek.Type != TokenType.ParenthesisGroup
            ctorExpr.Type = ParseType(group)
        
        ParseArguments(group, ctorExpr.Arguments)
        ParseInitializers(group, ctorExpr.Initializers)

        return ctorExpr

    private fn ParseConstructorDefinition(group Group, start Token) Statement
        ; "fn" "new" "(" {params} ")" ["base" "(" {exprs} ")"] [":" statement]
        ; "fn" "new" "(" {params} ")" ["base" "(" {exprs} ")"]
        ;     {statements}
        if res = group.Accept(TokenType.New), res.Failure
            InvalidToken(group, "constructor", res)
            AdvanceLine(group)
            return new BadStatementToken()
    
        var ctorStmt = new ConstructorDefinition(start.Position)

        if !ParseParameters(group, ctorStmt.Parameters)
            AddError("[code]", "missing parameters", start.Position)

        ; "base" "(" {exprs} ")"
        if group.Accept(TokenType.Base).Success
            if !ParseArguments(group, ctorStmt.BaseArguments)
                AddError("[code]", "missing base parameters", start.Position)
        
        ParseStatementOrIndentBlock(group, ctorStmt.Statements)

        return ctorStmt

    private fn ParseContinue(group Group, moveNextLine bool = true) Statement
        if res = group.Accept(TokenType.Continue), res.Success
            if moveNextLine
                AdvanceLine(group)
            return new ContinueToken(group.Token(res).Position)
        else
            InvalidToken(group, "continue", res)
            AdvanceLine(group)
            return new BadStatementToken()

    private fn ParseDelegate(group Group) Statement
        ; "del" name "(" {params} ")" [type]
        var res = group.Accept(TokenType.Delegate, TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "delegate", res)
            AdvanceLine(group)
            return new BadStatementToken()

        var delegateStmt = new Core.SyntaxTree.Delegate(group.Token(res).Position, group.Token(res, 1).ToIdentifierToken())

        ParseGenericDefinition(group, delegateStmt.Generics)
        
        if !ParseParameters(group, delegateStmt.Parameters)
            AddError("[code]", "missing parameters", delegateStmt.Position)
        
        if group.More
            delegateStmt.ReturnType = ParseType(group)
        
        AdvanceLine(group)
        return delegateStmt

    private fn ParseElse(group Group, ifStmt If)
        if group.Accept(TokenType.Else).Success
            if group.Peek.Type == TokenType.If
                ifStmt.ElseStatements.Add(ParseIf(group))
            else
                ParseStatementOrIndentBlock(group, ifStmt.ElseStatements)

    private fn ParseEnum(group Group) Statement
        ; "enum" name
        ;     name ["=" value] [";" comment]
        var res = group.Accept(TokenType.Enum, TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "enum", res)
            AdvanceLine(group)
            return new BadStatementToken()
        
        var enumStmt = new Enumeration(group.Token(res).Position, group.Token(res, 1).ToIdentifierToken())

        AdvanceLine(group)
        ParseIndentBlock(group, enumStmt.Statements, ParseEnumStatement)

        return enumStmt
    
    private fn ParseEnumItem(group Group) Statement
        ; name ["=" value] [";" comment]
        var res = group.Accept(TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "enumeration item", res)
            AdvanceLine(group)
            return new BadStatementToken()
        
        var enumItemStmt = new EnumerationItem(group.Token(res).Position, group.Token(res).ToIdentifierToken())

        if group.Accept(TokenType.Assign).Success
            enumItemStmt.Value = ParseExpression(group)
        
        if group.Peek.Type == TokenType.Comment
            enumItemStmt.Comment = ParseComment(group)
        else
            AdvanceLine(group)
        
        return enumItemStmt
    
    private fn ParseEnumStatement(group Group) Statement
        if !group.Tokens.Any()
            return ParseSpace(group)
        if group.Peek.Type
            is TokenType.Comment
                return ParseComment(group)
            is _
                return ParseEnumItem(group)

    private fn ParseExpression(group Group) Expression
        var left = ParsePrimaryExpression(group)
        return ParseBinaryOperatorRightSide(group, 0, left)
    
    private fn ParseExpressionStatement(group Group, moveNextLine bool = true) Statement
        var expr = ParseExpression(group)

        if group.Peek.Type.IsAssignment()
            return ParseAssignment(group, expr, moveNextLine)

        if moveNextLine
            AdvanceLine(group)
        return new ExpressionStatement(expr.Position, expr)

    private fn ParseField(group Group) Statement
        ; "var" name type ["=" expr]
        var res = group.Accept(TokenType.Variable, TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "field", res)
            AdvanceLine(group)
            return new BadStatementToken()

        var fieldStmt = new Field(group.Token(res).Position,
            group.Token(res, 1).ToIdentifierToken(),
            ParseType(group)
        )

        if group.Accept(TokenType.Assign).Success
            fieldStmt.Value = ParseExpression(group)
        
        AdvanceLine(group)
        return fieldStmt

    private fn ParseFile(tokenTree Group, fileName str) Core.SyntaxTree.File
        var file = new Core.SyntaxTree.File(Path.GetFileName(fileName))

        ; A file can contain lines and blocks.
        ; However, a block on its own is an error.
        for tokenTree.More
            if tokenTree.Peek.Type == TokenType.Line
                file.Statements.Add(ParseFileStatement(tokenTree.Peek as Group))
            else
                AddError("[code]", "unused block", tokenTree.Peek.Position)
                tokenTree.Advance()

        return file
    
    private fn ParseFileStatement(group Group) Statement
        if !group.Tokens.Any()
            return ParseSpace(group)
        if group.Peek.Type
            is TokenType.Class
                return ParseClass(group)
            is TokenType.Comment
                return ParseComment(group)
            is TokenType.Delegate
                return ParseDelegate(group)
            is TokenType.Enum
                return ParseEnum(group)
            is TokenType.Interface
                return ParseInterface(group)
            is TokenType.Namespace
                return ParseNamespace(group)
            is TokenType.Struct
                return ParseStruct(group)
            is TokenType.Use
                return ParseImport(group)
            is _
                return ParseAttributeBlock(group, ParseFileStatement)

    private fn ParseFor(group Group) Statement
        ; "for" name "in" expr [":" statement]
        ;     {statements}
        ; "for" [name "=" expr ","] [condition] [":" statement]
        ;     {statements}
        var start = group.Peek.Position

        if res = group.Accept(TokenType.For), res.Failure
            InvalidToken(group, "for", res)
            AdvanceLine(group)
            return new BadStatementToken()
        
        if res = group.Accept(TokenType.Identifier, TokenType.In), res.Success
            ; "for" name "in" expr [":" statement]
            ;     {statements}
            var nameIdentifierToken = group.Token(res).ToIdentifierToken()
            var forEachStmt = new ForEach(start, nameIdentifierToken, ParseExpression(group))
            ParseStatementOrIndentBlock(group, forEachStmt.Statements)
            return forEachStmt
        else if res2 = group.Accept(TokenType.Identifier, TokenType.Assign), res2.Success
            ; "for" name "=" expr "," condition [":" statement]
            ;     {statements}
            var forStmt = new For(start)
            forStmt.Name = group.Token(res2).ToIdentifierToken()
            forStmt.Init = ParseExpression(group)

            if group.Accept(TokenType.Comma).Failure
                AdvanceLine(group)
                AddError("[code]", "incomplete for", forStmt.Position)
                return forStmt

            forStmt.Condition = ParseExpression(group)
            ParseStatementOrIndentBlock(group, forStmt.Statements)
            return forStmt
        else
            ; "for" [condition] [":" statement]
            ;     {statements}
            var forStmt = new For(start)
            if group.More and group.Peek.Type != TokenType.Colon
                forStmt.Condition = ParseExpression(group)
            ParseStatementOrIndentBlock(group, forStmt.Statements)
            return forStmt

    private fn ParseGenericArguments(group Group, expr Expression) Expression
        ; "{" {arguments} "}"
        var argsExpr = new Arguments(group.Peek.Position, expr)
        if group.Peek.Type == TokenType.CurlyGroup and group.Next() is Group curlyGroup
            if curlyGroup.More
                argsExpr.Values.Add(ParseType(curlyGroup))
                for curlyGroup.Accept(TokenType.Comma).Success and curlyGroup.More
                    argsExpr.Values.Add(ParseType(curlyGroup))
            else
                AddError("[code]", "generics must have an argument", curlyGroup.Position)
            EnsureNoExtraTokens(curlyGroup)
        return argsExpr

    private fn ParseGenericDefinition(group Group, generics List{Statement}) bool
        ; "{" item {"," item} "}"
        if group.Peek.Type == TokenType.CurlyGroup and group.Next() is Group curlyGroup
            if curlyGroup.More
                generics.Add(ParseGenericDefinitionItem(curlyGroup))
                for curlyGroup.Accept(TokenType.Comma).Success and curlyGroup.More
                    generics.Add(ParseGenericDefinitionItem(curlyGroup))
            EnsureNoExtraTokens(curlyGroup)
            return true
        return false
    
    private fn ParseGenericDefinitionItem(group Group) Statement
        ; name ["class"] ["default"] ["in"] ["new"] ["!null"] ["?class"] ["out"] ["struct"] ["val"] [class] {interfaces}
        if res = group.Accept(TokenType.Identifier), res.Failure
            InvalidToken(group, "generic", res)
            group.Advance()
            return new BadStatementToken()
        else
            var genericStmt = new Generic(group.Token(res).Position, group.Token(res).ToIdentifierToken())
            for group.More and group.Peek.Type != TokenType.Comma
                var position = group.Peek.Position
                if group.Peek.Type
                    is TokenType.Class
                        genericStmt.Constraints.Add(new GenericConstraintToken(position, GenericConstraintType.Class))
                        group.Next()
                    is TokenType.Default
                        genericStmt.Constraints.Add(new GenericConstraintToken(position, GenericConstraintType.Default))
                        group.Next()
                    is TokenType.In
                        genericStmt.Constraints.Add(new GenericConstraintToken(position, GenericConstraintType.In))
                        group.Next()
                    is TokenType.New
                        genericStmt.Constraints.Add(new GenericConstraintToken(position, GenericConstraintType.New))
                        group.Next()
                    is TokenType.Out
                        genericStmt.Constraints.Add(new GenericConstraintToken(position, GenericConstraintType.Out))
                        group.Next()
                    is TokenType.Struct
                        genericStmt.Constraints.Add(new GenericConstraintToken(position, GenericConstraintType.Struct))
                        group.Next()
                    is TokenType.Value
                        genericStmt.Constraints.Add(new GenericConstraintToken(position, GenericConstraintType.Value))
                        group.Next()
                    is _
                        if group.Accept(TokenType.Not, TokenType.Null).Success
                            genericStmt.Constraints.Add(new GenericConstraintToken(position, GenericConstraintType.NotNull))
                        else if group.Accept(TokenType.Question, TokenType.Class).Success
                            genericStmt.Constraints.Add(new GenericConstraintToken(position, GenericConstraintType.NullableClass))
                        else
                            genericStmt.Constraints.Add(ParseType(group))

            return genericStmt

    private fn ParseIdentifier(group Group) Expression
        if res = group.Accept(TokenType.Identifier), res.Failure
            InvalidToken(group, "identifier", res)
            group.Advance()
            return new BadExpressionToken()
        else
            return group.Token(res).ToIdentifierToken()

    private fn ParseIf(group Group) Statement
        var start = group.Peek.Position

        if res = group.Accept(TokenType.If), res.Failure
            InvalidToken(group, "if", res)
            AdvanceLine(group)
            return new BadStatementToken()
        
        ; "if" [name "=" expr ","] expr [":" statement]
        var name ?IdentifierToken = null
        var value ?Expression = null
        if res = group.Accept(TokenType.Identifier, TokenType.Assign), res.Success
            name = group.Token(res).ToIdentifierToken()
            value = ParseExpression(group)
            if commaRes = group.Accept(TokenType.Comma), commaRes.Failure
                InvalidToken(group, "if", commaRes)
                AdvanceLine(group)
                return new BadStatementToken()
        
        var condition = ParseExpression(group)

        if group.Accept(TokenType.Colon).Success
            var ifStmt = new If(start, condition){LocalName = name, LocalValue = value}
            ifStmt.Statements.Add(ParseMethodStatementShort(group, true))
            if group.CurrentParentToken is Group pt
                ParseElse(pt, ifStmt)
            return ifStmt

        AdvanceLine(group)
        if group.CurrentParentToken is Group indentBlock and indentBlock.Type == TokenType.IndentBlock and indentBlock.Peek is Group curLine
            if curLine.Peek.Type == TokenType.Is
                ;     "is" expr [name] [":" statement]
                ;         {statements}
                var switchStmt = new Switch(start, condition){LocalName = name, LocalValue = value}
                for isRes = curLine.Accept(TokenType.Is), isRes.Success, isRes = curLine.Accept(TokenType.Is)
                    var caseExpr = ParseExpression(curLine)
                    if nameRes = curLine.Accept(TokenType.Identifier), nameRes.Success
                        caseExpr = new NamedExpression(caseExpr.Position, caseExpr, curLine.Token(nameRes).ToIdentifierToken())
                    var caseStmt = new Case(curLine.Token(isRes).Position, caseExpr)
                    switchStmt.Cases.Add(caseStmt)
                    ParseStatementOrIndentBlock(curLine, caseStmt.Statements)

                    if curLine.CurrentParentToken is Group pt
                        curLine = pt
                    else
                        break

                AdvanceLine(indentBlock)
                return switchStmt
            else
                ;     {statements}
                var ifStmt = new If(start, condition){LocalName = name, LocalValue = value}
                for indentBlock.More
                    if indentBlock.Peek.IsGroup()
                        ifStmt.Statements.Add(ParseMethodStatement(indentBlock.Peek as Group))
                    else
                        throw new InvalidItemException()
                AdvanceLine(indentBlock)
                if group.CurrentParentToken is Group pt
                    ParseElse(pt, ifStmt)
                return ifStmt

        return new If(start, condition){LocalName = name, LocalValue = value}

    private fn ParseImport(group Group) ImportToken
        ; "use" name
        var importToken = new ImportToken(group.Position)

        if res = group.Accept(TokenType.Use, TokenType.Identifier), res.Failure
            InvalidToken(group, "use", res)
            group.Advance()
            return importToken
        else
            importToken.Position = group.Token(res).Position
            importToken.NameParts.Add(group.Token(res, 1).Value)

        for res = group.Accept(TokenType.Dot, TokenType.Identifier),
                res.Success,
                res = group.Accept(TokenType.Dot, TokenType.Identifier)
            importToken.NameParts.Add(group.Token(res, 1).Value)

        AdvanceLine(group)

        return importToken
    
    private fn ParseIndentBlock(group Group, statements List{Statement}, stmtFn Func{Group, Statement}) bool
        if group.Parent != null and group.Parent.Peek.Type == TokenType.IndentBlock and group.Parent.Peek is Group indentBlock
            for indentBlock.More
                if indentBlock.Peek.IsGroup()
                    statements.Add(stmtFn(indentBlock.Peek as Group))
                else
                    throw new InvalidItemException()
            group.Parent.Advance()
            return true
        return false

    private fn ParseIndexer(group Group, expr Expression) Expression
        ; "[" {arguments} "]"
        var argsExpr = new Arguments(group.Peek.Position, expr)
        if next = group.Next(), next.Type == TokenType.BracketGroup and next is Group bracketGroup
            if bracketGroup.More
                argsExpr.Values.Add(ParseExpression(bracketGroup))
                for bracketGroup.Accept(TokenType.Comma).Success and bracketGroup.More
                    argsExpr.Values.Add(ParseExpression(bracketGroup))
            else
                AddError("[code]", "indexer must have an argument", bracketGroup.Position)
            EnsureNoExtraTokens(bracketGroup)
        return argsExpr

    private fn ParseInitializer(group Group) Statement
        ; name "=" expression
        if res = group.Accept(TokenType.Identifier, TokenType.Assign), res.Failure
            InvalidToken(group, "initializer", res)
            group.Advance()
            return new BadStatementToken()
        else
            return new Initializer(group.Token(res).Position, group.Token(res).ToIdentifierToken(), ParseExpression(group))

    private fn ParseInitializers(group Group, inits List{Statement})
        ; "{" {initializers} "}"
        if group.Peek.Type == TokenType.CurlyGroup and group.Next() is Group curlyGroup
            if curlyGroup.More
                inits.Add(ParseInitializer(curlyGroup))
                for curlyGroup.Accept(TokenType.Comma).Success and curlyGroup.More
                    inits.Add(ParseInitializer(curlyGroup))
            EnsureNoExtraTokens(curlyGroup)

    private fn ParseInterface(group Group) Statement
        ; "interface" name ["{" {generics} "}"] ["has" interfaces]
        var res = group.Accept(TokenType.Interface, TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "interface", res)
            group.Advance()
            return new BadStatementToken()
        
        var interfaceStmt = new Interface(group.Token(res).Position, group.Token(res, 1).ToIdentifierToken())

        ParseGenericDefinition(group, interfaceStmt.Generics)

        if group.Accept(TokenType.Has).Success
            interfaceStmt.Interfaces.Add(ParseType(group))
            for group.Accept(TokenType.Comma).Success
                interfaceStmt.Interfaces.Add(ParseType(group))

        AdvanceLine(group)

        ParseIndentBlock(group, interfaceStmt.Statements, ParseInterfaceStatement)

        return interfaceStmt
    
    private fn ParseInterfaceStatement(group Group) Statement
        if !group.Tokens.Any()
            return ParseSpace(group)
        if group.Peek.Type
            is TokenType.Class
                return ParseClass(group)
            is TokenType.Comment
                return ParseComment(group)
            is TokenType.Delegate
                return ParseDelegate(group)
            is TokenType.Enum
                return ParseEnum(group)
            is TokenType.Function
                return ParseMethodOrPropertyDefinition(group)
            is TokenType.Interface
                return ParseInterface(group)
            is TokenType.Signature
                return ParseMethodOrPropertySignature(group)
            is TokenType.Struct
                return ParseStruct(group)
            is _
                return ParseAttributeBlock(group, ParseInterfaceStatement)

    private fn ParseLocalConstant(group Group) Statement
        ; "val" name "=" expr
        var res = group.Accept(TokenType.Value, TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "val", res)
            AdvanceLine(group)
            return new BadStatementToken()
        
        var position = group.Token(res).Position
        var nameIdentifierToken = group.Token(res, 1).ToIdentifierToken()

        if group.Accept(TokenType.Assign).Failure
            InvalidToken(group, "val", res)
            AdvanceLine(group)
            return new BadStatementToken()
        
        var value = ParseExpression(group)

        AdvanceLine(group)
        return new LocalConstant(position, nameIdentifierToken, value)

    private fn ParseLocalVariable(group Group) Statement
        ; "var" name [type] ["=" expr]
        var res = group.Accept(TokenType.Variable, TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "var", res)
            AdvanceLine(group)
            return new BadStatementToken()
        
        var varStmt = new LocalVariable(group.Token(res).Position, group.Token(res, 1).ToIdentifierToken())

        if group.More and group.Peek.Type != TokenType.Assign
            varStmt.Type = ParseType(group)

        if group.Accept(TokenType.Assign).Success
            varStmt.Value = ParseExpression(group)

        AdvanceLine(group)
        return varStmt

    private fn ParseMethodCall(group Group, expr Expression) Expression
        ; method "(" {arguments} ")"
        var argsExpr = new Arguments(group.Peek.Position, expr)
        if !ParseArguments(group, argsExpr.Values)
            AddError("[code]", "missing arguments", argsExpr.Position)
        return argsExpr

    private fn ParseMethodDefinition(group Group, nameIdentifierToken IdentifierToken, generics List{Statement}) Statement
        ; "fn" name ["{" generics "}"] "(" {params} ")" [type] [":" statement]
        ;     {statements}
        var methodStmt = new MethodDefinition(nameIdentifierToken.Position, nameIdentifierToken, generics)

        if !ParseParameters(group, methodStmt.Parameters)
            AddError("[code]", "missing parameters", nameIdentifierToken.Position)
        
        if group.More and group.Peek.Type != TokenType.Colon
            methodStmt.ReturnType = ParseType(group)
        
        ParseStatementOrIndentBlock(group, methodStmt.Statements)
        
        return methodStmt
    
    private fn ParseMethodSignature(group Group, nameIdentifierToken IdentifierToken, generics List{Statement}) Statement
        ; "sig" name ["{" generics "}"] "(" {params} ")" [type]
        var methodSigStmt = new MethodSignature(nameIdentifierToken.Position, nameIdentifierToken, generics)

        if !ParseParameters(group, methodSigStmt.Parameters)
            AddError("[code]", "missing parameters", nameIdentifierToken.Position)
        
        if group.More
            methodSigStmt.ReturnType = ParseType(group)
        
        AdvanceLine(group)
        return methodSigStmt

    private fn ParseMethodOrPropertyDefinition(group Group) Statement
        var start = group.Peek
        var res = group.Accept(TokenType.Function)
        if res.Failure
            InvalidToken(group, "method or property", res)
            AdvanceLine(group)
            return new BadStatementToken()

        if group.Peek.Type == TokenType.New
            return ParseConstructorDefinition(group, start)
        
        res = group.Accept(TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "method or property", res)
            AdvanceLine(group)
            return new BadStatementToken()
        
        var nameIdentifierToken = group.Token(res).ToIdentifierToken()
        var generics = new List{Statement}()
        ParseGenericDefinition(group, generics)

        if group.Peek.Type == TokenType.ParenthesisGroup
            return ParseMethodDefinition(group, nameIdentifierToken, generics)
        
        return ParsePropertyDefinition(group, nameIdentifierToken, generics)
    
    private fn ParseMethodOrPropertySignature(group Group) Statement
        var res = group.Accept(TokenType.Signature, TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "method or property signature", res)
            AdvanceLine(group)
            return new BadStatementToken()
        
        var nameIdentifierToken = group.Token(res, 1).ToIdentifierToken()
        var generics = new List{Statement}()
        ParseGenericDefinition(group, generics)

        if group.Peek.Type == TokenType.ParenthesisGroup
            return ParseMethodSignature(group, nameIdentifierToken, generics)
        
        return ParsePropertySignature(group, nameIdentifierToken, generics)

    private fn ParseMethodStatement(group Group) Statement
        if !group.Tokens.Any()
            return ParseSpace(group)
        return group.Peek.Type ?
        {
            TokenType.Break : ParseBreak(group),
            TokenType.Comment : ParseComment(group),
            TokenType.Continue : ParseContinue(group),
            TokenType.DoubleColon : ParseBlock(group),
            TokenType.For : ParseFor(group),
            TokenType.If : ParseIf(group),
            TokenType.Return : ParseReturn(group),
            TokenType.Try : ParseTry(group),
            TokenType.Use : ParseUsing(group),
            TokenType.Value : ParseLocalConstant(group),
            TokenType.Variable : ParseLocalVariable(group),
            _ : ParseExpressionStatement(group),
        }
    
    private fn ParseMethodStatementShort(group Group, moveNextLine bool) Statement : group.Peek.Type ?
    {
        TokenType.Break : ParseBreak(group, moveNextLine),
        TokenType.Comment : ParseComment(group, moveNextLine),
        TokenType.Continue : ParseContinue(group, moveNextLine),
        TokenType.Return : ParseReturn(group, moveNextLine),
        _ : ParseExpressionStatement(group, moveNextLine),
    }

    private fn ParseNamespace(group Group) NamespaceToken
        ; "ns" namespace
        var namespaceToken = new NamespaceToken(group.Position)

        if res = group.Accept(TokenType.Namespace, TokenType.Identifier), res.Failure
            InvalidToken(group, "namespace", res)
            group.Advance()
        else
            namespaceToken.Position = group.Token(res).Position
            namespaceToken.NameParts.Add(group.Token(res, 1).Value)
        
        for res = group.Accept(TokenType.Dot, TokenType.Identifier),
                res.Success,
                res = group.Accept(TokenType.Dot, TokenType.Identifier)
            namespaceToken.NameParts.Add(group.Token(res, 1).Value)
        
        AdvanceLine(group)

        return namespaceToken
    
    private fn ParseNullableType(group Group) Expression
        ; "?" type
        if res = group.Accept(TokenType.Question), res.Failure
            InvalidToken(group, "nullable type", res)
            group.Advance()
            return new BadExpressionToken()
        else
            return new NullableType(group.Token(res).Position, ParseType(group))
    
    private fn ParseNumber(group Group) Expression
        if res = group.Accept(TokenType.NumberLiteral), res.Success
            var numVal = group.Token(res).Value
            var numType = NumberType.Decimal

            if numVal.StartsWith("0b")
                numVal = numVal.Substring(2)
                numType = NumberType.Binary
            else if numVal.StartsWith("0x")
                numVal = numVal.Substring(2)
                numType = NumberType.Hexadecimal
            
            return new NumberToken(group.Token(res).Position, numType, numVal)
        
        group.Advance()
        return new BadExpressionToken()

    private fn ParseParameter(group Group) Statement
        ; name {modifiers} [type] ["=" expression]
        var res = group.Accept(TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "parameter", res)
        
        var paramStmt = new Parameter(group.Token(res).Position, group.Token(res).ToIdentifierToken())

        ; modifiers
        for group.Peek.Type.IsParameterModifier()
            paramStmt.Modifiers.Add(group.Next().ToParameterModifierToken())
        
        ; type
        if group.More and group.Peek.Type != TokenType.Comma and group.Peek.Type != TokenType.Assign
            paramStmt.Type = ParseType(group)
        
        ; default value
        if group.Accept(TokenType.Assign).Success
            paramStmt.Value = ParseExpression(group)
        
        return paramStmt

    private fn ParseParameters(group Group, parameters List{Statement}) bool
        ; "(" {parameters} ")"
        if group.Peek.Type == TokenType.ParenthesisGroup and group.Next() is Group parenthesisGroup
            if parenthesisGroup.More
                parameters.Add(ParseParameter(parenthesisGroup))
                for parenthesisGroup.Accept(TokenType.Comma).Success and parenthesisGroup.More
                    parameters.Add(ParseParameter(parenthesisGroup))
            EnsureNoExtraTokens(parenthesisGroup)
            return true
        return false

    private fn ParseParenthesizedExpression(group Group) Expression
        if next = group.Next(), next.Type == TokenType.ParenthesisGroup
            return ParseExpression(next as Group)
        return new BadExpressionToken()
    
    private fn ParsePrimaryExpression(group Group) Expression
        var expr Expression
        if peekType = group.Peek.Type, peekType
            is TokenType.BracketGroup
                var bracketGroup = group.Peek as Group
                if bracketGroup.Tokens.Any(fn(t) : t.Type != TokenType.Comma)
                    expr = ParseArrayLiteral(group)
                else
                    expr = ParseArrayType(group)
            is TokenType.Function
            is TokenType.FunctionBlock
                expr = ParseAnonymousFunction(group)
            is TokenType.Identifier
                expr = ParseIdentifier(group)
            is TokenType.New
                expr = ParseConstructorCall(group)
            is TokenType.NumberLiteral
                expr = ParseNumber(group)
            is TokenType.ParenthesisGroup
                expr = ParseParenthesizedExpression(group)
            is TokenType.Question
                expr = ParseNullableType(group)
            is TokenType.StringGroup
                expr = ParseString(group)
            is _
                if peekType.IsType()
                    expr = ParseTypeToken(group)
                else if peekType.IsUnaryOperator()
                    expr = ParseUnaryOperator(group)
                else
                    var token = group.Next()
                    expr = token.Type ?
                    {
                        TokenType.Base : new BaseClassToken(token.Position),
                        TokenType.CharacterLiteral : new CharacterToken(token.Position, token.Value),
                        TokenType.Default : new DefaultValueToken(token.Position),
                        TokenType.Discard : new DiscardToken(token.Position),
                        TokenType.False : new LiteralToken(token.Position, LiteralType.False),
                        TokenType.Null : new LiteralToken(token.Position, LiteralType.Null),
                        TokenType.This : new CurrentObjectInstanceToken(token.Position),
                        TokenType.True : new LiteralToken(token.Position, LiteralType.True),
                        _ : new BadExpressionToken()
                    }
        
        var loop = true
        for loop
            if res = group.Accept(TokenType.Dot, TokenType.Identifier), res.Success
                expr = new BinaryOperator(expr.Position, expr,
                    group.Token(res).ToBinaryOperatorToken(),
                    group.Token(res, 1).ToIdentifierToken())
            else if ndRes = group.Accept(TokenType.NullDot, TokenType.Identifier), ndRes.Success
                expr = new BinaryOperator(expr.Position, expr,
                    group.Token(res).ToBinaryOperatorToken(),
                    group.Token(res, 1).ToIdentifierToken())
            else
                if token = group.Peek, token.Type
                    is TokenType.BracketGroup
                        expr = ParseIndexer(group, expr)
                    is TokenType.CurlyGroup
                        expr = ParseGenericArguments(group, expr)
                    is TokenType.ParenthesisGroup
                        expr = ParseMethodCall(group, expr)
                    is TokenType.Question
                        expr = ParseConditional(group, expr)
                    is _
                        loop = false
        return expr

    private fn ParsePropertyDefinition(group Group, nameIdentifierToken IdentifierToken, generics List{Statement}) Statement
        ; "fn" name ["{" {generics} "}"] [type] ["get" and/or "set"] ["=" expr]
        ; "fn" name ["{" {generics} "}"] [type] [":" statement]
        ;     {statements}
        ; "fn" name ["{" {generics} "}"] [type]
        ;     "get" [":" statement]
        ;         {statements}
        ;     "set" name [":" statement]
        ;         {statements}
        var propertyStmt = new PropertyDefinition(nameIdentifierToken.Position, nameIdentifierToken, generics)

        ; type
        if peek = group.Peek, group.More and
                peek.Type != TokenType.Get and
                peek.Type != TokenType.Set and
                peek.Type != TokenType.Assign and
                peek.Type != TokenType.Colon
            propertyStmt.Type = ParseType(group)

        ; get and/or set
        if group.Accept(TokenType.Get).Success
            propertyStmt.GetSpecified = true
            if group.Accept(TokenType.Comma, TokenType.Set).Success
                propertyStmt.SetSpecified = true
        else if group.Accept(TokenType.Set).Success
            propertyStmt.SetSpecified = true
            if group.Accept(TokenType.Comma, TokenType.Get).Success
                propertyStmt.GetSpecified = true
        else
            propertyStmt.GetSpecified = true
            propertyStmt.SetSpecified = true

        if group.Accept(TokenType.Assign).Success
            ; "=" expr
            propertyStmt.Value = ParseExpression(group)
            AdvanceLine(group)
            return propertyStmt
        else if group.Accept(TokenType.Colon).Success
            ; ":" statement
            propertyStmt.SetSpecified = false
            propertyStmt.GetStatements.Add(ParseMethodStatementShort(group, true))
            return propertyStmt

        ; get and set on separate lines
        AdvanceLine(group)
        if group.CurrentParentToken is Group indentBlock and indentBlock.Type == TokenType.IndentBlock and indentBlock.Peek is Group line
            if line.Accept(TokenType.Get).Success
                propertyStmt.SetSpecified = false
                ParseStatementOrIndentBlock(line, propertyStmt.GetStatements)
                if line.CurrentParentToken is Group nextLine and nextLine.Peek.Type == TokenType.Set
                    if res = nextLine.Accept(TokenType.Set, TokenType.Identifier), res.Failure
                        InvalidToken(nextLine, "set", res)
                        AdvanceLine(nextLine)
                    else
                        propertyStmt.SetSpecified = true
                        propertyStmt.SetParameterName = nextLine.Token(res, 1).ToIdentifierToken()
                        ParseStatementOrIndentBlock(nextLine, propertyStmt.SetStatements)
                AdvanceLine(indentBlock)
            else if line.Peek.Type == TokenType.Set
                if res = line.Accept(TokenType.Set, TokenType.Identifier), res.Failure
                    InvalidToken(line, "set", res)
                    AdvanceLine(line)
                else
                    propertyStmt.GetSpecified = false
                    propertyStmt.SetParameterName = line.Token(res, 1).ToIdentifierToken()
                    ParseStatementOrIndentBlock(line, propertyStmt.SetStatements)
                    if line.CurrentParentToken is Group nextLine and nextLine.Accept(TokenType.Get).Success
                        propertyStmt.GetSpecified = true
                        ParseStatementOrIndentBlock(nextLine, propertyStmt.GetStatements)
                AdvanceLine(indentBlock)
            else
                propertyStmt.SetSpecified = false
                ParseIndentBlock(group, propertyStmt.GetStatements, ParseMethodStatement)

        return propertyStmt

    private fn ParsePropertySignature(group Group, nameIdentifierToken IdentifierToken, generics List{Statement}) Statement
        ; "sig" name ["{" {generics} "}"] type ["get" and/or "set"]
        var type = ParseType(group)
        var propertySigStmt = new PropertySignature(nameIdentifierToken.Position, nameIdentifierToken, type, generics)

        ; get and/or set
        if group.Accept(TokenType.Get).Success
            propertySigStmt.GetSpecified = true
            if group.Accept(TokenType.Comma, TokenType.Set).Success
                propertySigStmt.SetSpecified = true
        else if group.Accept(TokenType.Set).Success
            propertySigStmt.SetSpecified = true
            if group.Accept(TokenType.Comma, TokenType.Get).Success
                propertySigStmt.GetSpecified = true
        else
            propertySigStmt.GetSpecified = true
            propertySigStmt.SetSpecified = true

        AdvanceLine(group)
        return propertySigStmt

    private fn ParseReturn(group Group, moveNextLine bool = true) Statement
        ; "return" [expr]
        if res = group.Accept(TokenType.Return), res.Failure
            InvalidToken(group, "return", res)
            AdvanceLine(group)
            return new BadStatementToken()
        else
            var returnStmt = new Return(group.Token(res).Position)
            if group.More
                returnStmt.Value = ParseExpression(group)
            if moveNextLine
                AdvanceLine(group)
            return returnStmt

    private fn ParseSpace(group Group) Statement
        if group.Parent != null and group.Parent.IsBlock() and group.Parent is Group block
            var size = 1
            block.Advance()
            for block.Peek is Group line and line.Type == TokenType.Line and !line.Tokens.Any()
                size += 1
                block.Advance()
            return new SpaceToken(group.Position, size)
        AddError("[code]", "wasn't a block while parsing space", group.Position)
        return new BadStatementToken()
    
    private fn ParseStatementOrIndentBlock(group Group, statements List{Statement})
        ; ":" statement
        if group.Accept(TokenType.Colon).Success
            statements.Add(ParseMethodStatementShort(group, true))
        else
            ; {statements}
            AdvanceLine(group)
            ParseIndentBlock(group, statements, ParseMethodStatement)

    private fn ParseString(group Group) Expression
        if next = group.Next(), next.Type == TokenType.StringGroup and next is Group stringGroup
            var stringExpr = new Core.SyntaxTree.String(group.Peek.Position)
            stringExpr.Lines.Add(ParseStringLine(stringGroup))
            for res = group.Accept(TokenType.DoubleDot, TokenType.StringGroup), res.Success,
                    res = group.Accept(TokenType.DoubleDot, TokenType.StringGroup)
                stringExpr.Lines.Add(ParseStringLine(group.Token(res, 1) as Group))
            return stringExpr
        return new BadExpressionToken()
    
    private fn ParseStringLine(group Group) List{Expression}
        var line = new List{Expression}()
        var loop = true
        for group.More and loop
            if token = group.Next(), token.Type
                is TokenType.StringLiteral
                    line.Add(new StringToken(token.Position, token.Value))
                is TokenType.CurlyGroup
                    var curlyGroup = token as Group
                    line.Add(ParseExpression(curlyGroup))
                    EnsureNoExtraTokens(curlyGroup)
                is _
                    loop = false
                    AddError("[code]", "invalid token in string: {token}", token.Position)
        EnsureNoExtraTokens(group)
        return line

    private fn ParseStruct(group Group) Statement
        ; "struct" name ["{" {generics} "}"] ["has" interfaces]
        var res = group.Accept(TokenType.Struct, TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "struct", res)
            group.Advance()
            return new BadStatementToken()

        var structStmt = new Struct(group.Token(res).Position, group.Token(res, 1).ToIdentifierToken())

        ParseGenericDefinition(group, structStmt.Generics)

        if group.Accept(TokenType.Has).Success
            structStmt.Interfaces.Add(ParseType(group))
            for group.Accept(TokenType.Comma).Success
                structStmt.Interfaces.Add(ParseType(group))
        
        AdvanceLine(group)

        ParseIndentBlock(group, structStmt.Statements, ParseStructStatement)

        return structStmt
    
    private fn ParseStructStatement(group Group) Statement : ParseClassStatement(group)
    
    private fn ParseThrowOr(parseFn Func{Group, Expression}, group Group) Expression
        if group.Peek.Type != TokenType.Throw
            return parseFn(group)

        ; accept throw
        var start = group.Next()
        return new Throw(start.Position, ParseExpression(group))

    private fn ParseTry(group Group) Statement
        ; "try" [":" statement]
        ;     {statements}
        ; ["catch" [type [name]] [":" statement]]
        ;     {statements}
        ; ["finally" [":" statement]]
        ;     {statements}
        var start = group.Peek.Position
        if res = group.Accept(TokenType.Try), res.Failure
            InvalidToken(group, "try", res)
            group.Advance()
            return new BadStatementToken()
        
        var tryStmt = new Try(start)
        ParseStatementOrIndentBlock(group, tryStmt.Statements)

        for group.CurrentParentToken is Group line and line.Type == TokenType.Line
            if res = line.Accept(TokenType.Catch), res.Success
                var catchStmt = new Catch(line.Token(res).Position)
                tryStmt.Catches.Add(catchStmt)
                if line.More and line.Peek.Type != TokenType.Colon
                    var catchVal = ParseType(line)
                    if nameRes = line.Accept(TokenType.Identifier), nameRes.Success
                        catchVal = new NamedExpression(catchVal.Position, catchVal, line.Token(nameRes).ToIdentifierToken())
                    catchStmt.Value = catchVal
                ParseStatementOrIndentBlock(line, catchStmt.Statements)
            else if line.Accept(TokenType.Finally).Success
                ParseStatementOrIndentBlock(line, tryStmt.FinallyStatements)
                break
            else
                break

        return tryStmt

    private fn ParseType(group Group) Expression
        var typeExpr Expression
        if group.Peek.Type
            is TokenType.BracketGroup
                return ParseArrayType(group)
            is TokenType.Identifier
                typeExpr = ParseIdentifier(group)
            is TokenType.Question
                return ParseNullableType(group)
            is _
                if group.Peek.Type.IsType()
                    typeExpr = ParseTypeToken(group)
                else
                    AddError("code", "invalid token in type: {group.Peek}", group.Peek.Position)
                    return new BadExpressionToken()
        
        var loop = true
        for loop
            if group.Peek.Type == TokenType.CurlyGroup
                typeExpr = ParseGenericArguments(group, typeExpr)
            else if res = group.Accept(TokenType.Dot, TokenType.Identifier), res.Success
                typeExpr = new BinaryOperator(
                    typeExpr.Position,
                    typeExpr,
                    new BinaryOperatorToken(group.Token(res).Position, BinaryOperatorType.Dot),
                    group.Token(res, 1).ToIdentifierToken()
                )
            else
                loop = false
        
        return typeExpr

    private fn ParseTypeToken(group Group) Expression
        var pos = group.Peek.Position
        var ident = new IdentifierToken(pos, group.Peek.Type ?
            {
                TokenType.String : "String",
                TokenType.Character : "Char",
                TokenType.Boolean : "Boolean",
                TokenType.I8 : "SByte",
                TokenType.I16 : "Int16",
                TokenType.I32 : "Int32",
                TokenType.I64 : "Int64",
                TokenType.U8 : "Byte",
                TokenType.U16 : "UInt16",
                TokenType.U32 : "UInt32",
                TokenType.U64 : "UInt64",
                TokenType.F32 : "Single",
                TokenType.F64 : "Double",
                TokenType.F128 : "Decimal",
                _ : "Error",
            })
        group.Advance()
        return new BinaryOperator(pos, new IdentifierToken(pos, "System"), new BinaryOperatorToken(pos, BinaryOperatorType.Dot), ident)

    private fn ParseUnaryOperator(group Group) Expression
        return new UnaryOperator(group.Peek.Position, group.Next().ToUnaryOperatorToken(), ParsePrimaryExpression(group))

    private fn ParseUsing(group Group) Statement
        ; "use" name "=" expr [":" statement]
        ;     {statements}
        var res = group.Accept(TokenType.Use, TokenType.Identifier, TokenType.Assign)
        if res.Failure
            InvalidToken(group, "using", res)
            AdvanceLine(group)
            return new BadStatementToken()

        var usingStmt = new Using(
            group.Token(res).Position,
            group.Token(res, 1).ToIdentifierToken(),
            ParseExpression(group)
        )

        ParseStatementOrIndentBlock(group, usingStmt.Statements)

        return usingStmt
