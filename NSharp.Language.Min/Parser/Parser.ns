use NSharp.Core
use NSharp.Core.SyntaxTree
use NSharp.Language.Min.TokenTree

ns NSharp.Language.Min

public class Parser
    private fn Settings Settings
    private fn Result LoadResult
    private fn CurrentIndex int = 0

    public fn new(settings Settings, result LoadResult)
        Settings = settings
        Result = result
    
    private fn AddError(code str, message str, position Position)
        Result.Diagnostics.Add(new Diagnostic(Severity.Error, code, message, position))
    
    private fn InvalidToken(group Group, type str, result AcceptResult)
        var token = group.ErrorToken(result)
        var missed = result.MissedTokenType
        var error = "Invalid token in {type} when looking for {missed}: {token}"
        AddError("[code]", error, token.Position)
    
    private fn AdvanceLine(group Group)
        EnsureNoExtraTokens(group)
        group.AdvanceParent()
    
    private fn EnsureNoExtraTokens(group Group)
        for i = group.CurrentIndex, i < group.Tokens.Count, i += 1
            AddError("[code]", "extra token {group.Tokens[i]}", group.Tokens[i].Position)

    public fn Parse(fileName str) Core.SyntaxTree.File
        var builder = new TokenTreeBuilder(fileName, Settings, Result.Diagnostics)

        var file = ParseFile(builder.TokenTree, fileName)

        if Settings.PrintSyntaxTree
            file.Accept(new SyntaxTreePrinterVisitor())

        ret file
    
    private fn ParseAnonymousFunction(group Group) Expression
        ; "fn" "(" [params] ")" [type] ":" statement
        ; "fn" "(" [params] ")" [type]
        ;     {statements}
        ; "/fn"
        var anonFnExpr = new AnonymousFunction(group.Peek.Position)

        if next = group.Next(), next.Type == TokenType.Function
            ; parameters
            if !ParseParameters(group, anonFnExpr.Parameters)
                AddError("[code]", "missing parameters", anonFnExpr.Position)

            ; optional return type
            if group.More and group.Peek.Type != TokenType.Colon
                anonFnExpr.ReturnType = ParseType(group)
            
            ; ":" statement
            if group.Accept(TokenType.Colon).Success
                anonFnExpr.Statements.Add(ParseMethodStatement(group))
            
        else if next is Group fnBlock and fnBlock.Type == TokenType.FunctionBlock and fnBlock.Peek is Group line and line.Type == TokenType.Line
            ; parameters
            if !ParseParameters(line, anonFnExpr.Parameters)
                AddError("[code]", "missing parameters", anonFnExpr.Position)
            
            ; optional return type
            if line.More
                anonFnExpr.ReturnType = ParseType(line)

            ; {statements}
            AdvanceLine(line)
            ParseIndentBlock(line, anonFnExpr.Statements, ParseMethodStatement)
        else
            AddError("[code]", "missing fn", anonFnExpr.Position)

        ret anonFnExpr

    private fn ParseArrayLiteral(group Group) Expression
        ; "[" [expressions] "]"
        if next = group.Next(), next.Type == TokenType.BracketGroup and next is Group bracketGroup
            var arrayExpr = new ArrayLiteral(bracketGroup.Position)
            if bracketGroup.More
                arrayExpr.Values.Add(ParseExpression(bracketGroup))
                for bracketGroup.Accept(TokenType.Comma).Success and bracketGroup.More
                    arrayExpr.Values.Add(ParseExpression(bracketGroup))
            EnsureNoExtraTokens(bracketGroup)
            ret arrayExpr
        ret new BadExpressionToken()
    
    private fn ParseArgument(group Group) Expression
        ; [name "="] ["out" | "ref"] expression
        var startPos = group.Peek.Position
        var name ?Token = null
        if res = group.Accept(TokenType.Identifier, TokenType.Assign), res.Success
            name = group.Token(res)
        
        ; modifiers
        var modifiers = new List{ArgumentModifierToken}()
        for group.Peek.Type.IsArgumentModifier()
            modifiers.Add(group.Next().ToArgumentModifierToken())
        
        var argStmt = new Argument(startPos, modifiers, ParseExpression(group))
        if name != null
            argStmt.Name = name.ToIdentifierToken()
        
        ret argStmt

    private fn ParseArguments(group Group, args List{Expression}) bool
        ; "(" [arguments] ")"
        if next = group.Next(), next.Type == TokenType.ParenthesisGroup and next is Group parenthesisGroup
            if parenthesisGroup.More
                args.Add(ParseArgument(parenthesisGroup))
                for parenthesisGroup.Accept(TokenType.Comma).Success and parenthesisGroup.More
                    args.Add(ParseArgument(parenthesisGroup))
            EnsureNoExtraTokens(parenthesisGroup)
            ret true
        ret false

    private fn ParseArrayType(group Group) Expression
        ; "[]" type
        if next = group.Next(), next.Type == TokenType.BracketGroup and next is Group bracketGroup
            if !bracketGroup.Tokens.Any()
                ret new ArrayType(bracketGroup.Position, ParseType(group))
            else
                AddError("[code]", "an array type shouldn't have anything in the []s", bracketGroup.Position)
        ret new BadExpressionToken()

    private fn ParseAssignment(group Group, left Expression) Statement
        var op = group.Next().ToAssignmentOperatorToken()
        var right = ParseExpression(group)
        AdvanceLine(group)
        ret new Assignment(left.Position, left, op, right)

    private fn ParseBinaryOperatorRightSide(group Group, leftPrecedence int, left Expression) Expression
        for
            var tokenPrecedence = group.Peek.Precedence()

            ; If this is a binary operator that binds at least as tightly as the
            ; current operator then consume it, otherwise we're done.
            if tokenPrecedence < leftPrecedence
                ret left

            var op = group.Next()
            var right = op.Type.IsOperatorCanThrow() ? ParseThrowOr(ParsePrimaryExpression, group) : ParsePrimaryExpression(group)
            
            ; If it's a named expression (currently only 'is') then accept the
            ; next token as the name if it's a literal.
            if op.Type == TokenType.Is and group.Peek.Type == TokenType.Identifier
                right = new NamedExpression(right.Position, right, group.Next().ToIdentifierToken())

            ; If the binary operator binds less tightly with the right than the operator
            ; after the right, let the pending operator take the right as its left.
            if tokenPrecedence < group.Peek.Precedence()
                right = ParseBinaryOperatorRightSide(group, tokenPrecedence + 1, right)

            ; Merge left and right.
            left = new BinaryOperator(left.Position, left, op.ToBinaryOperatorToken(), right)

    private fn ParseBlock(group Group) Statement
        var blockStmt = new Core.SyntaxTree.Block(group.Peek.Position)
        if res = group.Accept(TokenType.DoubleColon), res.Failure
            InvalidToken(group, "block", res)
        AdvanceLine(group)
        ParseIndentBlock(group, blockStmt.Statements, ParseMethodStatement)
        ret blockStmt

    private fn ParseBreak(group Group) Statement
        if res = group.Accept(TokenType.Break), res.Success
            AdvanceLine(group)
            ret new BreakToken(group.Token(res).Position)
        else
            InvalidToken(group, "break", res)
            AdvanceLine(group)
            ret new BadStatementToken()

    private fn ParseContinue(group Group) Statement
        if res = group.Accept(TokenType.Continue), res.Success
            AdvanceLine(group)
            ret new ContinueToken(group.Token(res).Position)
        else
            InvalidToken(group, "continue", res)
            AdvanceLine(group)
            ret new BadStatementToken()

    private fn ParseClass(group Group) Statement
        ; "class" name "(" {params} ")" ["is" base] ["has" interfaces]
        var res = group.Accept(TokenType.Class, TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "class", res)
            group.Advance()
            ret new BadStatementToken()
        
        var classStmt = new Class(group.Token(res).Position, group.Token(res, 1).ToIdentifierToken())

        ; todo - ParseGenericNames(classResult.GenericNames)

        if group.Accept(TokenType.Is).Success
            classStmt.Base = ParseType(group)

        if group.Accept(TokenType.Has).Success
            classStmt.Interfaces.Add(ParseType(group))
            for group.Accept(TokenType.Comma).Success
                classStmt.Interfaces.Add(ParseType(group))

        AdvanceLine(group)

        ParseIndentBlock(group, classStmt.Statements, ParseClassStatement)

        ret classStmt
    
    private fn ParseClassStatement(group Group) Statement
        if !group.Tokens.Any()
            ret ParseSpace(group)
        if token = group.Tokens[0], token.Type
            is TokenType.Class
                ret ParseClass(group)
            is TokenType.Comment
                ret ParseComment(group)
            is TokenType.Function
                ret ParseMethodOrProperty(group)
            is TokenType.Value
                ret ParseConstant(group)
            is TokenType.Variable
                ret ParseField(group)
        
        ; var modifiers = new List{Modifier}()
        ; var modRes = ParseModifiers(modifiers)
        ; if modRes != null
        ;     ret modRes

        ; if Peek.Type
        ;     is TokenType.Interface
        ;         ret ParseInterface(modifiers)
        ;     is TokenType.Struct
        ;         ret ParseStruct(modifiers)
        ;     is TokenType.Delegate
        ;         ret ParseDelegate(modifiers)
        ;     is TokenType.Enum
        ;         ret ParseEnum(modifiers)

        AdvanceLine(group)
        ret new BadStatementToken()

    private fn ParseComment(group Group) Statement
        ; ";" comment
        if res = group.Accept(TokenType.Comment), res.Failure
            InvalidToken(group, "comment", res)
            AdvanceLine(group)
            ret new BadStatementToken()
        else
            var commentStmt = new CommentToken(group.Token(res).Position, group.Token(res).Value)
            if commentStmt.Value.StartsWith(";")
                commentStmt.Value = commentStmt.Value.Substring(1)
                commentStmt.IsDocumentation = true
            AdvanceLine(group)
            ret commentStmt
    
    private fn ParseCondition(group Group) Statement
        var expr = ParseExpression(group)

        if res = group.Accept(TokenType.Colon), res.Failure
            InvalidToken(group, "condition", res)
            group.Advance()
            ret new BadStatementToken()
        
        ; Condition results can be a throw.
        var result = ParseThrowOr(ParseExpression, group)

        ret new Condition(expr.Position, expr, result)
    
    private fn ParseConditional(group Group, expr Expression) Expression
        ; expr "?" true expr ":" false expr
        ; expr "?" "{" value ":" result {"," value ":" result} "}"
        if res = group.Accept(TokenType.Question), res.Failure
            InvalidToken(group, "conditional", res)
            group.Advance()
            ret new BadExpressionToken()
        
        var conditionalExpr = new Conditional(expr.Position, expr)

        if group.Peek.Type != TokenType.CurlyGroup
            ; Condition results can be a throw.
            var trueRes = ParseThrowOr(ParseExpression, group)
            conditionalExpr.Conditions.Add(new Condition(
                trueRes.Position,
                new LiteralToken(trueRes.Position, LiteralType.True),
                trueRes
            ))

            if res = group.Accept(TokenType.Colon), res.Failure
                InvalidToken(group, "conditional", res)
                group.Advance()
                ret conditionalExpr
            
            ; Condition results can be a throw.
            var falseRes = ParseThrowOr(ParseExpression, group)
            conditionalExpr.Conditions.Add(new Condition(
                falseRes.Position,
                new LiteralToken(falseRes.Position, LiteralType.False),
                falseRes
            ))
        else
            var curlyGroup = group.Next() as Group
            if curlyGroup.More
                conditionalExpr.Conditions.Add(ParseCondition(curlyGroup))
                for curlyGroup.Accept(TokenType.Comma).Success and curlyGroup.More
                    conditionalExpr.Conditions.Add(ParseCondition(curlyGroup))
            else
                AddError("[code]", "a conditional should have at least one condition", curlyGroup.Position)
            EnsureNoExtraTokens(curlyGroup)
        
        ret conditionalExpr

    private fn ParseConstant(group Group) Statement
        ; "val" name type ["=" expr]
        var res = group.Accept(TokenType.Value, TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "constant", res)
            AdvanceLine(group)
            ret new BadStatementToken()

        var constStmt = new Core.SyntaxTree.Constant(group.Token(res).Position,
            group.Token(res, 1).ToIdentifierToken(),
            ParseType(group)
        )

        if group.Accept(TokenType.Assign).Success
            constStmt.Value = ParseExpression(group)
        
        AdvanceLine(group)
        ret constStmt

    private fn ParseConstructorCall(group Group) Expression
        ; "new" [type] "(" [args] ")" ["{" [initializers] "}"]
        var res = group.Accept(TokenType.New)
        if res.Failure
            InvalidToken(group, "constructor call", res)
            group.Advance()
            ret new BadExpressionToken()
        
        var ctorExpr = new ConstructorCall(group.Token(res).Position)

        if group.Peek.Type != TokenType.CurlyGroup and group.Peek.Type != TokenType.ParenthesisGroup
            ctorExpr.Type = ParseType(group)
        
        ParseArguments(group, ctorExpr.Arguments)
        ParseInitializers(group, ctorExpr.Initializers)

        ret ctorExpr

    private fn ParseConstructorDefinition(group Group, start Token) Statement
        ; "fn" "new" "(" {params} ")" ["base" "(" {exprs} ")"] [":" statement]
        ; "fn" "new" "(" {params} ")" ["base" "(" {exprs} ")"]
        ;     {statements}
        if res = group.Accept(TokenType.New), res.Failure
            InvalidToken(group, "constructor", res)
            AdvanceLine(group)
            ret new BadStatementToken()
    
        var ctorStmt = new ConstructorDefinition(start.Position)

        if !ParseParameters(group, ctorStmt.Parameters)
            AddError("[code]", "missing parameters", start.Position)

        ; "base" "(" {exprs} ")"
        if group.Accept(TokenType.Base).Success
            if !ParseArguments(group, ctorStmt.BaseArguments)
                AddError("[code]", "missing base parameters", start.Position)
        
        ParseStatementOrBlock(group, ctorStmt.Statements)

        ret ctorStmt

    private fn ParseExpression(group Group) Expression
        var left = ParsePrimaryExpression(group)
        ret ParseBinaryOperatorRightSide(group, 0, left)
    
    private fn ParseExpressionStatement(group Group) Statement
        var expr = ParseExpression(group)

        if group.Peek.Type.IsAssignment()
            ret ParseAssignment(group, expr)

        AdvanceLine(group)
        ret new ExpressionStatement(expr.Position, expr)

    private fn ParseField(group Group) Statement
        ; "var" name type ["=" expr]
        var res = group.Accept(TokenType.Variable, TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "field", res)
            AdvanceLine(group)
            ret new BadStatementToken()

        var fieldStmt = new Field(group.Token(res).Position,
            group.Token(res, 1).ToIdentifierToken(),
            ParseType(group)
        )

        if group.Accept(TokenType.Assign).Success
            fieldStmt.Value = ParseExpression(group)
        
        AdvanceLine(group)
        ret fieldStmt

    private fn ParseFile(tokenTree Group, fileName str) Core.SyntaxTree.File
        var file = new Core.SyntaxTree.File(Path.GetFileName(fileName))

        ; A file can contain lines and blocks.
        ; However, a block on its own is an error.
        for tokenTree.More
            if tokenTree.Peek.Type == TokenType.Line
                file.Statements.Add(ParseFileStatement(tokenTree.Peek as Group))
            else
                AddError("[code]", "unused block", tokenTree.Peek.Position)
                tokenTree.Advance()

        ret file
    
    private fn ParseFileStatement(group Group) Statement
        if !group.Tokens.Any()
            ret ParseSpace(group)
        if token = group.Tokens[0], token.Type
            is TokenType.Class
                ret ParseClass(group)
            is TokenType.Comment
                ret ParseComment(group)
            is TokenType.Namespace
                ret ParseNamespace(group)
            is TokenType.Use
                ret ParseImport(group)
            
        ; is TokenType.Delegate
        ; is TokenType.Enum
        ; is TokenType.Interface
        ; is TokenType.Struct
        ;     file.Statements.Add(ParseFileModifiableStatement().Result)
        ; is _
        ;     if Peek.Type.IsModifier()
        ;         file.Statements.Add(ParseFileModifiableStatement().Result)

        AdvanceLine(group)
        ret new BadStatementToken()

    private fn ParseFor(group Group) Statement
        ; "for" [condition] [":" statement]
        ;     {statements}
        ; "for" name "in" expr [":" statement]
        ;     {statements}
        ; "for" name "=" expr "," condition "," statement [":" statement]
        ;     {statements}
        var start = group.Peek.Position

        if res = group.Accept(TokenType.For), res.Failure
            InvalidToken(group, "for", res)
            AdvanceLine(group)
            ret new BadStatementToken()
        
        if res = group.Accept(TokenType.Identifier, TokenType.In), res.Success
            ; "for" name "in" expr [":" statement]
            ;     {statements}
            var nameIdentifierToken = group.Token(res).ToIdentifierToken()
            var forEachStmt = new ForEach(start, nameIdentifierToken, ParseExpression(group))
            ParseStatementOrBlock(group, forEachStmt.Statements)
            ret forEachStmt
        else if res2 = group.Accept(TokenType.Identifier, TokenType.Assign), res2.Success
            ; "for" name "=" expr "," condition "," statement [":" statement]
            ;     {statements}
            var forStmt = new For(start)
            forStmt.Name = group.Token(res2).ToIdentifierToken()
            forStmt.Init = ParseExpression(group)

            if group.Accept(TokenType.Comma).Failure
                AdvanceLine(group)
                AddError("[code]", "incomplete for", forStmt.Position)
                ret forStmt

            forStmt.Condition = ParseExpression(group)

            if group.Accept(TokenType.Comma).Failure
                AdvanceLine(group)
                AddError("[code]", "incomplete for", forStmt.Position)
                ret forStmt
            
            forStmt.Post = ParseMethodStatement(group)

            ; todo - support : statement by passing a flag to the above to not move the line
            ; (or use the eventual method that only accepts expression statements and assignment?)

            ParseIndentBlock(group, forStmt.Statements, ParseMethodStatement)

            ret forStmt
        else
            ; "for" [condition] [":" statement]
            ;     {statements}
            var forStmt = new For(start)
            if group.More and group.Peek.Type != TokenType.Colon
                forStmt.Condition = ParseExpression(group)
            ParseStatementOrBlock(group, forStmt.Statements)
            ret forStmt

    private fn ParseGeneric(group Group, expr Expression) Expression
        ; "{" {arguments} "}"
        var argsExpr = new Arguments(group.Peek.Position, expr)
        if next = group.Next(), next.Type == TokenType.CurlyGroup and next is Group curlyGroup
            if curlyGroup.More
                argsExpr.Values.Add(ParseType(curlyGroup))
                for curlyGroup.Accept(TokenType.Comma).Success and curlyGroup.More
                    argsExpr.Values.Add(ParseType(curlyGroup))
            else
                AddError("[code]", "generics must have an argument", curlyGroup.Position)
            EnsureNoExtraTokens(curlyGroup)
        ret argsExpr

    private fn ParseIdentifier(group Group) Expression
        if res = group.Accept(TokenType.Identifier), res.Failure
            InvalidToken(group, "identifier", res)
            group.Advance()
            ret new BadExpressionToken()
        else
            ret group.Token(res).ToIdentifierToken()

    private fn ParseImport(group Group) ImportToken
        var importToken = new ImportToken(group.Position)

        if res = group.Accept(TokenType.Use, TokenType.Identifier), res.Failure
            InvalidToken(group, "use", res)
            group.Advance()
            ret importToken
        else
            importToken.Position = group.Token(res).Position
            importToken.NameParts.Add(group.Token(res, 1).Value)

        for res = group.Accept(TokenType.Dot, TokenType.Identifier),
                res.Success,
                res = group.Accept(TokenType.Dot, TokenType.Identifier)
            importToken.NameParts.Add(group.Token(res, 1).Value)

        AdvanceLine(group)

        ret importToken
    
    private fn ParseIndentBlock(group Group, statements List{Statement}, stmtFn Func{Group, Statement}) bool
        if group.Parent != null and group.Parent.Peek.Type == TokenType.IndentBlock and group.Parent.Peek is Group indentBlock
            for indentBlock.More
                if indentBlock.Peek.IsGroup()
                    statements.Add(stmtFn(indentBlock.Peek as Group))
                else
                    throw new InvalidItemException()
            group.Parent.Advance()
            ret true
        ret false

    private fn ParseIndexer(group Group, expr Expression) Expression
        ; "[" {arguments} "]"
        var argsExpr = new Arguments(group.Peek.Position, expr)
        if next = group.Next(), next.Type == TokenType.BracketGroup and next is Group bracketGroup
            if bracketGroup.More
                argsExpr.Values.Add(ParseExpression(bracketGroup))
                for bracketGroup.Accept(TokenType.Comma).Success and bracketGroup.More
                    argsExpr.Values.Add(ParseExpression(bracketGroup))
            else
                AddError("[code]", "indexer must have an argument", bracketGroup.Position)
            EnsureNoExtraTokens(bracketGroup)
        ret argsExpr

    private fn ParseInitializer(group Group) Statement
        ; name "=" expression
        if res = group.Accept(TokenType.Identifier, TokenType.Assign), res.Failure
            InvalidToken(group, "initializer", res)
            group.Advance()
            ret new BadStatementToken()
        else
            ret new Initializer(group.Token(res).Position, group.Token(res).ToIdentifierToken(), ParseExpression(group))

    private fn ParseInitializers(group Group, inits List{Statement})
        ; "{" {initializers} "}"
        if next = group.Next(), next.Type == TokenType.CurlyGroup and next is Group curlyGroup
            if curlyGroup.More
                inits.Add(ParseInitializer(curlyGroup))
                for curlyGroup.Accept(TokenType.Comma).Success and curlyGroup.More
                    inits.Add(ParseInitializer(curlyGroup))
            EnsureNoExtraTokens(curlyGroup)

    private fn ParseLocalConstant(group Group) Statement
        ; "val" name "=" expr
        var res = group.Accept(TokenType.Value, TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "val", res)
            AdvanceLine(group)
            ret new BadStatementToken()
        
        var position = group.Token(res).Position
        var nameIdentifierToken = group.Token(res, 1).ToIdentifierToken()

        if group.Accept(TokenType.Assign).Failure
            InvalidToken(group, "val", res)
            AdvanceLine(group)
            ret new BadStatementToken()
        
        var value = ParseExpression(group)

        AdvanceLine(group)
        ret new LocalConstant(position, nameIdentifierToken, value)

    private fn ParseLocalVariable(group Group) Statement
        ; "var" name [type] ["=" expr]
        var res = group.Accept(TokenType.Variable, TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "var", res)
            AdvanceLine(group)
            ret new BadStatementToken()
        
        var varStmt = new LocalVariable(group.Token(res).Position, group.Token(res, 1).ToIdentifierToken())

        if group.More and group.Peek.Type != TokenType.Assign
            varStmt.Type = ParseType(group)

        if group.Accept(TokenType.Assign).Success
            varStmt.Value = ParseExpression(group)

        AdvanceLine(group)
        ret varStmt

    private fn ParseMethodCall(group Group, expr Expression) Expression
        ; method "(" {arguments} ")"
        var argsExpr = new Arguments(group.Peek.Position, expr)
        if !ParseArguments(group, argsExpr.Values)
            AddError("[code]", "missing arguments", argsExpr.Position)
        ret argsExpr

    private fn ParseMethodDefinition(group Group, nameIdentifierToken IdentifierToken) Statement
        ; "fn" name "(" {params} ")" [type] [":" statement]
        ; "fn" name "(" {params} ")" [type]
        ;     {statements}
        var methodStmt = new Method(nameIdentifierToken.Position, nameIdentifierToken)

        ; todo - ParseGenericNames

        if !ParseParameters(group, methodStmt.Parameters)
            AddError("[code]", "missing parameters", nameIdentifierToken.Position)
        
        if group.More and group.Peek.Type != TokenType.Colon
            methodStmt.ReturnType = ParseType(group)
        
        ; ":" statement
        if group.Accept(TokenType.Colon).Success
            if methodStmt.ReturnType != null
                var expr = ParseExpression(group)
                methodStmt.Statements.Add(new Return(expr.Position){Value = expr})
                AdvanceLine(group)
            else
                methodStmt.Statements.Add(ParseMethodStatement(group))
        else
            ; {statements}
            AdvanceLine(group)
            ParseIndentBlock(group, methodStmt.Statements, ParseMethodStatement)
        
        ret methodStmt

    private fn ParseMethodOrProperty(group Group) Statement
        var start = group.Peek
        var res = group.Accept(TokenType.Function)
        if res.Failure
            InvalidToken(group, "method or property", res)
            AdvanceLine(group)
            ret new BadStatementToken()

        if group.Peek.Type == TokenType.New
            ret ParseConstructorDefinition(group, start)
        
        res = group.Accept(TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "method or property", res)
            AdvanceLine(group)
            ret new BadStatementToken()
        
        var nameIdentifierToken = group.Token(res).ToIdentifierToken()

        if group.Peek.Type == TokenType.ParenthesisGroup
            ret ParseMethodDefinition(group, nameIdentifierToken)
        
        ; todo - ret ParseProperty(group, nameIdentifierToken)

        AdvanceLine(group)
        ret new BadStatementToken()

    private fn ParseMethodStatement(group Group) Statement
        if !group.Tokens.Any()
            ret ParseSpace(group)
        ret group.Peek.Type ?
        {
            TokenType.Break is ParseBreak(group),
            TokenType.Comment is ParseComment(group),
            TokenType.Continue is ParseContinue(group),
            TokenType.DoubleColon is ParseBlock(group),
            TokenType.For is ParseFor(group),
            TokenType.Return is ParseReturn(group),
            TokenType.Value is ParseLocalConstant(group),
            TokenType.Variable is ParseLocalVariable(group),
            _ is ParseExpressionStatement(group),
        }
        ; TokenType.If is ParseIf(),
        ; TokenType.Try is ParseTry(),
        ; TokenType.Use is ParseUsing(),

    private fn ParseNamespace(group Group) NamespaceToken
        ; "ns" namespace
        var namespaceToken = new NamespaceToken(group.Position)

        if res = group.Accept(TokenType.Namespace, TokenType.Identifier), res.Failure
            InvalidToken(group, "namespace", res)
            group.Advance()
        else
            namespaceToken.Position = group.Token(res).Position
            namespaceToken.NameParts.Add(group.Token(res, 1).Value)
        
        for res = group.Accept(TokenType.Dot, TokenType.Identifier),
                res.Success,
                res = group.Accept(TokenType.Dot, TokenType.Identifier)
            namespaceToken.NameParts.Add(group.Token(res, 1).Value)
        
        AdvanceLine(group)

        ret namespaceToken
    
    private fn ParseNullableType(group Group) Expression
        ; "?" type
        if res = group.Accept(TokenType.Question), res.Failure
            InvalidToken(group, "nullable type", res)
            group.Advance()
            ret new BadExpressionToken()
        else
            ret new NullableType(group.Token(res).Position, ParseType(group))
    
    private fn ParseNumber(group Group) Expression
        if res = group.Accept(TokenType.NumberLiteral), res.Success
            var numVal = group.Token(res).Value
            var numType = NumberType.Decimal

            if numVal.StartsWith("0b")
                numVal = numVal.Substring(2)
                numType = NumberType.Binary
            else if numVal.StartsWith("0x")
                numVal = numVal.Substring(2)
                numType = NumberType.Hexadecimal
            
            ret new NumberToken(group.Token(res).Position, numType, numVal)
        
        group.Advance()
        ret new BadExpressionToken()

    private fn ParseParameter(group Group) Statement
        ; name {modifiers} [type] ["=" expression]
        var res = group.Accept(TokenType.Identifier)
        if res.Failure
            InvalidToken(group, "parameter", res)
        
        var paramStmt = new Parameter(group.Token(res).Position, group.Token(res).ToIdentifierToken())

        ; modifiers
        for group.Peek.Type.IsParameterModifier()
            paramStmt.Modifiers.Add(group.Next().ToParameterModifierToken())
        
        ; type
        if group.More and group.Peek.Type != TokenType.Comma and group.Peek.Type != TokenType.Assign
            paramStmt.Type = ParseType(group)
        
        ; default value
        if group.Accept(TokenType.Assign).Success
            paramStmt.Value = ParseExpression(group)
        
        ret paramStmt

    private fn ParseParameters(group Group, parameters List{Statement}) bool
        ; "(" {parameters} ")"
        if next = group.Next(), next.Type == TokenType.ParenthesisGroup and next is Group parenthesisGroup
            if parenthesisGroup.More
                parameters.Add(ParseParameter(parenthesisGroup))
                for parenthesisGroup.Accept(TokenType.Comma).Success and parenthesisGroup.More
                    parameters.Add(ParseParameter(parenthesisGroup))
            EnsureNoExtraTokens(parenthesisGroup)
            ret true
        ret false

    private fn ParseParenthesizedExpression(group Group) Expression
        if next = group.Next(), next.Type == TokenType.ParenthesisGroup
            ret ParseExpression(next as Group)
        ret new BadExpressionToken()
    
    private fn ParsePrimaryExpression(group Group) Expression
        var expr Expression
        if peekType = group.Peek.Type, peekType
            is TokenType.BracketGroup
                var bracketGroup = group.Peek as Group
                if bracketGroup.Tokens.Any()
                    expr = ParseArrayLiteral(group)
                else
                    expr = ParseArrayType(group)
            is TokenType.Function
            is TokenType.FunctionBlock
                expr = ParseAnonymousFunction(group)
            is TokenType.Identifier
                expr = ParseIdentifier(group)
            is TokenType.New
                expr = ParseConstructorCall(group)
            is TokenType.NumberLiteral
                expr = ParseNumber(group)
            is TokenType.ParenthesisGroup
                expr = ParseParenthesizedExpression(group)
            is TokenType.Question
                expr = ParseNullableType(group)
            is TokenType.StringGroup
                expr = ParseString(group)
            is _
                if peekType.IsType()
                    expr = ParseTypeToken(group)
                else if peekType.IsUnaryOperator()
                    expr = ParseUnaryOperator(group)
                else
                    var token = group.Next()
                    expr = token.Type ?
                    {
                        TokenType.CharacterLiteral is new CharacterToken(token.Position, token.Value),
                        TokenType.Default is new DefaultValueToken(token.Position),
                        TokenType.Discard is new DiscardToken(token.Position),
                        TokenType.False is new LiteralToken(token.Position, LiteralType.False),
                        TokenType.Null is new LiteralToken(token.Position, LiteralType.Null),
                        TokenType.This is new CurrentObjectInstanceToken(token.Position),
                        TokenType.True is new LiteralToken(token.Position, LiteralType.True),
                        _ is new BadExpressionToken()
                    }
        
        var loop = true
        for loop
            if res = group.Accept(TokenType.Dot, TokenType.Identifier), res.Success
                expr = new BinaryOperator(expr.Position, expr,
                    group.Token(res).ToBinaryOperatorToken(),
                    group.Token(res, 1).ToIdentifierToken())
            else if ndRes = group.Accept(TokenType.NullDot, TokenType.Identifier), ndRes.Success
                expr = new BinaryOperator(expr.Position, expr,
                    group.Token(res).ToBinaryOperatorToken(),
                    group.Token(res, 1).ToIdentifierToken())
            else
                if token = group.Peek, token.Type
                    is TokenType.BracketGroup
                        expr = ParseIndexer(group, expr)
                    is TokenType.CurlyGroup
                        expr = ParseGeneric(group, expr)
                    is TokenType.ParenthesisGroup
                        expr = ParseMethodCall(group, expr)
                    is TokenType.Question
                        expr = ParseConditional(group, expr)
                    is _
                        loop = false
        ret expr

    private fn ParseReturn(group Group) Statement
        ; "ret" [expr]
        if res = group.Accept(TokenType.Return), res.Failure
            InvalidToken(group, "return", res)
            AdvanceLine(group)
            ret new BadStatementToken()
        else
            var returnStmt = new Return(group.Token(res).Position)
            if group.More
                returnStmt.Value = ParseExpression(group)
            AdvanceLine(group)
            ret returnStmt

    private fn ParseSpace(group Group) Statement
        if group.Parent != null and group.Parent.IsBlock() and group.Parent is Group block
            var size = 1
            block.Advance()
            for block.Peek is Group line and line.Type == TokenType.Line and !line.Tokens.Any()
                size += 1
                block.Advance()
            ret new SpaceToken(group.Position, size)
        AddError("[code]", "wasn't a block while parsing space", group.Position)
        ret new BadStatementToken()
    
    private fn ParseStatementOrBlock(group Group, statements List{Statement})
        ; ":" statement
        if group.Accept(TokenType.Colon).Success
            statements.Add(ParseMethodStatement(group))
        else
            ; {statements}
            AdvanceLine(group)
            ParseIndentBlock(group, statements, ParseMethodStatement)

    private fn ParseString(group Group) Expression
        if next = group.Next(), next.Type == TokenType.StringGroup and next is Group stringGroup
            var stringExpr = new Core.SyntaxTree.String(group.Peek.Position)
            stringExpr.Lines.Add(ParseStringLine(stringGroup))
            for res = group.Accept(TokenType.DoubleDot, TokenType.StringGroup), res.Success,
                    res = group.Accept(TokenType.DoubleDot, TokenType.StringGroup)
                stringExpr.Lines.Add(ParseStringLine(group.Token(res, 1) as Group))
            ret stringExpr
        ret new BadExpressionToken()
    
    private fn ParseStringLine(group Group) List{Expression}
        var line = new List{Expression}()
        var loop = true
        for group.More and loop
            if token = group.Next(), token.Type
                is TokenType.StringLiteral
                    line.Add(new StringToken(token.Position, token.Value))
                is TokenType.CurlyGroup
                    var curlyGroup = token as Group
                    line.Add(ParseExpression(curlyGroup))
                    EnsureNoExtraTokens(curlyGroup)
                is _
                    loop = false
                    AddError("[code]", "invalid token in string: {token}", token.Position)
        EnsureNoExtraTokens(group)
        ret line

    private fn ParseThrowOr(parseFn Func{Group, Expression}, group Group) Expression
        if group.Peek.Type != TokenType.Throw
            ret parseFn(group)

        ; accept throw
        var start = group.Next()
        ret new Throw(start.Position, ParseExpression(group))

    private fn ParseType(group Group) Expression
        var typeExpr Expression
        if group.Peek.Type
            is TokenType.BracketGroup
                ret ParseArrayType(group)
            is TokenType.Identifier
                typeExpr = ParseIdentifier(group)
            is TokenType.Question
                ret ParseNullableType(group)
            is _
                if group.Peek.Type.IsType()
                    typeExpr = ParseTypeToken(group)
                else
                    AddError("code", "invalid token in type: {group.Peek}", group.Peek.Position)
                    ret new BadExpressionToken()
        
        var loop = true
        for loop
            if group.Peek.Type == TokenType.CurlyGroup
                typeExpr = ParseGeneric(group, typeExpr)
            else if res = group.Accept(TokenType.Dot, TokenType.Identifier), res.Success
                typeExpr = new BinaryOperator(
                    typeExpr.Position,
                    typeExpr,
                    new BinaryOperatorToken(group.Token(res).Position, BinaryOperatorType.Dot),
                    group.Token(res, 1).ToIdentifierToken()
                )
            else
                loop = false
        
        ret typeExpr

    private fn ParseTypeToken(group Group) Expression
        var pos = group.Peek.Position
        var ident = new IdentifierToken(pos, group.Peek.Type ?
            {
                TokenType.String is "String",
                TokenType.Character is "Char",
                TokenType.Boolean is "Boolean",
                TokenType.I8 is "SByte",
                TokenType.I16 is "Int16",
                TokenType.I32 is "Int32",
                TokenType.I64 is "Int64",
                TokenType.U8 is "Byte",
                TokenType.U16 is "UInt16",
                TokenType.U32 is "UInt32",
                TokenType.U64 is "UInt64",
                TokenType.F32 is "Single",
                TokenType.F64 is "Double",
                TokenType.Decimal is "Decimal",
                _ is "Error",
            })
        group.Advance()
        ret new BinaryOperator(pos, new IdentifierToken(pos, "System"), new BinaryOperatorToken(pos, BinaryOperatorType.Dot), ident)

    private fn ParseUnaryOperator(group Group) Expression
        ret new UnaryOperator(group.Peek.Position, group.Next().ToUnaryOperatorToken(), ParsePrimaryExpression(group))

;     private fn ParseDelegate(modifiers List{Modifier}) ParseResult{Statement}
;         ; [modifiers] del [name]([params])
;         ; [modifiers] del [name]([params]) [type]

;         ; accept del
;         Next()

;         var res = Accept(TokenType.Identifier)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in delegate", res)

;         var nameToken = GetToken(res)

;         var delegateDef = new DelegateDefinition(nameToken.Position, modifiers, nameToken.Value)

;         ParseGenericNames(delegateDef.GenericNames)
;         ParseParameters(delegateDef.Parameters)

;         if Peek.Type != TokenType.EOL
;             var retType = ParseType()
;             if !retType.Error
;                 delegateDef.ReturnType = retType.Result

;         res = Accept(TokenType.EOL)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in delegate", res)

;         ret new ParseResult{Statement}(delegateDef)

;     private fn ParseEnum(modifiers List{Modifier}) ParseResult{Statement}
;         ; [modifiers] enum [name]
;         ;     Val
;         ;     Val2 = 3
;         ;     Val3 ; comment
;         ;     Val4 = 5 ; comment

;         var res = Accept(TokenType.Enum, TokenType.Identifier, TokenType.EOL, TokenType.Indent)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in enum", res)

;         var enumDef = new Enumeration(GetToken(res).Position, modifiers, GetToken(res, 1).Value)

;         for Peek.Type != TokenType.Dedent
;             res = Accept(TokenType.Identifier)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in enum", res)
;             var enumItem = new EnumerationItem(GetToken(res).Position, GetToken(res).Value)

;             res = Accept(TokenType.Assign, TokenType.NumberLiteral)
;             if res.Success
;                 enumItem.Value = Convert.ToInt32(GetToken(res, 1).Value)

;             if Peek.Type == TokenType.Comment
;                 var commentResult = ParseComment()
;                 if commentResult.Error
;                     ret commentResult
;                 enumItem.Comment = commentResult.Result as Comment
;             else
;                 res = Accept(TokenType.EOL)
;                 if res.Failure
;                     ret InvalidTokenErrorStatement("Invalid token in enum", res)

;             enumDef.Values.Add(enumItem)

;         res = Accept(TokenType.Dedent)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in enum", res)

;         ret new ParseResult{Statement}(enumDef)

;     private fn ParseFileModifiableStatement() ParseResult{Statement}
;         var modifiers = new List{Modifier}()
;         var modRes = ParseModifiers(modifiers)
;         if modRes != null
;             ret modRes

;         ret Peek.Type ?
;         {
;             TokenType.Class is ParseClass(modifiers),
;             TokenType.Delegate is ParseDelegate(modifiers),
;             TokenType.Enum is ParseEnum(modifiers),
;             TokenType.Interface is ParseInterface(modifiers),
;             TokenType.Struct is ParseStruct(modifiers),
;             _ is ErrorStatement("Invalid token: {Peek}", Peek.Position),
;         }

;     private fn ParseGenericNames(genericNames List{str})
;         if Peek.Type != TokenType.LeftCurly
;             ret

;         if res = Accept(TokenType.LeftCurly, TokenType.Identifier), res.Success
;             genericNames.Add(GetToken(res, 1).Value)
;         else
;             LogError("generic", res)
;             ret

;         for res = Accept(TokenType.Comma, TokenType.Identifier), res.Success, res = Accept(TokenType.Comma, TokenType.Identifier)
;             genericNames.Add(GetToken(res, 1).Value)

;         if res = Accept(TokenType.RightCurly), res.Failure
;             LogError("generic", res)
;             To(TokenType.RightCurly)

;     ; Returns the error parse result, or null on success.
;     private fn ParseGetSet(propDef Property) ?ParseResult{Statement}
;         var res AcceptResult
;         if Peek.Type == TokenType.Get
;             if Accept(TokenType.Get, TokenType.Is).Success
;                 ; get is [expr]

;                 var exprResult = ParseExpression()
;                 if exprResult.Error and exprResult.Result is ErrorExpression exp
;                     ret ErrorStatement(exp)
;                 propDef.GetStatements.Add(new Return(exprResult.Result.Position) { Value = exprResult.Result })
;                 res = Accept(TokenType.EOL)
;                 if res.Failure
;                     ret InvalidTokenErrorStatement("Invalid token in get", res)
;             else
;                 ; get
;                 ;     [statements]

;                 res = Accept(TokenType.Get, TokenType.EOL, TokenType.Indent)
;                 if res.Failure
;                     ret InvalidTokenErrorStatement("Invalid token in get", res)

;                 for Peek.Type != TokenType.Dedent
;                     var stmt = ParseMethodStatement()
;                     if stmt.Error
;                         ret stmt
;                     propDef.GetStatements.Add(stmt.Result)

;                 res = Accept(TokenType.Dedent)
;                 if res.Failure
;                     ret InvalidTokenErrorStatement("Invalid token in get", res)
;         else
;             res = Accept(TokenType.Set, TokenType.LeftParenthesis, TokenType.Identifier, TokenType.RightParenthesis)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in set", res)
;             propDef.SetParameterName = GetToken(res, 2).Value

;             if Accept(TokenType.Is).Success
;                 ; set(v) is [statement]

;                 var stmtResult = ParseMethodStatement()
;                 if stmtResult.Error
;                     ret stmtResult
;                 propDef.SetStatements.Add(stmtResult.Result)
;             else
;                 ; set(v)
;                 ;     [statements]

;                 res = Accept(TokenType.EOL, TokenType.Indent)
;                 if res.Failure
;                     ret InvalidTokenErrorStatement("Invalid token in set", res)

;                 for Peek.Type != TokenType.Dedent
;                     var stmt = ParseMethodStatement()
;                     if stmt.Error
;                         ret stmt
;                     propDef.SetStatements.Add(stmt.Result)

;                 res = Accept(TokenType.Dedent)
;                 if res.Failure
;                     ret InvalidTokenErrorStatement("Invalid token in set", res)

;         ret null

;     private fn ParseIf(inElseIf bool = false) ParseResult{Statement}
;         ; accept if
;         var start = Next()
;         ; if [name] = [expr], [expr]
;         var res = Accept(TokenType.Identifier, TokenType.Assign)
;         var name ?str = null
;         var assignmentExpr ?ParseResult{Expression} = null
;         if res.Success
;             name = GetToken(res).Value
;             assignmentExpr = ParseExpression()
;             if assignmentExpr.Error and assignmentExpr.Result is ErrorExpression exp
;                 ret ErrorStatement(exp)
;             res = Accept(TokenType.Comma)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in if", res)

;         var condition = ParseExpression()
;         if condition.Error and condition.Result is ErrorExpression ex
;             ret ErrorStatement(ex)

;         res = Accept(TokenType.EOL, TokenType.Indent)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in if", res)

;         ; if [expr]
;         ;     is [expr]
;         ;         [statements]
;         ;     is [expr]
;         ;     is [expr]
;         ;         [statements]
;         if Peek.Type == TokenType.Is and !inElseIf
;             var switchStmt = new Switch(start.Position, condition.Result) { LocalName = name, LocalExpr = assignmentExpr?.Result }
;             var isRes = Accept(TokenType.Is)
;             for isRes.Success
;                 var exprRes = ParseExpression()
;                 if exprRes.Error and exprRes.Result is ErrorExpression exp
;                     ret ErrorStatement(exp)

;                 res = Accept(TokenType.EOL)
;                 if res.Failure
;                     ret InvalidTokenErrorStatement("Invalid token in if", res)

;                 var caseStmt = new Case(GetToken(isRes).Position, exprRes.Result)
;                 switchStmt.Statements.Add(caseStmt)

;                 if Accept(TokenType.Indent).Success
;                     for Peek.Type != TokenType.Dedent
;                         var stmtRes = ParseMethodStatement()
;                         if stmtRes.Error
;                             ret stmtRes
;                         caseStmt.Statements.Add(stmtRes.Result)

;                     res = Accept(TokenType.Dedent)
;                     if res.Failure
;                         ret InvalidTokenErrorStatement("Invalid token in if", res)

;                 isRes = Accept(TokenType.Is)

;             res = Accept(TokenType.Dedent)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in if", res)

;             ret new ParseResult{Statement}(switchStmt)

;         var ifStatement = new If(start.Position, condition.Result) { LocalName = name, LocalExpr = assignmentExpr?.Result }

;         for Peek.Type != TokenType.Dedent
;             var statement = ParseMethodStatement()
;             if statement.Error
;                 ret statement
;             ifStatement.Statements.Add(statement.Result)

;         res = Accept(TokenType.Dedent, TokenType.Else)
;         if res.Success
;             if Peek.Type == TokenType.If
;                 var elseIf = ParseIf(true)
;                 if elseIf.Error
;                     ret elseIf
;                 ifStatement.ElseStatements.Add(elseIf.Result)
;             else
;                 res = Accept(TokenType.EOL, TokenType.Indent)
;                 if res.Failure
;                     ret InvalidTokenErrorStatement("Invalid token in if", res)

;                 for Peek.Type != TokenType.Dedent
;                     var statement = ParseMethodStatement()
;                     if statement.Error
;                         ret statement
;                     ifStatement.ElseStatements.Add(statement.Result)

;         if !inElseIf
;             res = Accept(TokenType.Dedent)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in if", res)

;         ret new ParseResult{Statement}(ifStatement)

;     private fn ParseImplicitConstructorCall(start Token) ParseResult{Expression}
;         ; new([args])
;         ; new{[type args]}([args])
;         ; new([args]){[initializers]}
;         ; new{[type args]}([args]){[initializers]}

;         var res AcceptResult
;         var ctorDef = new ImplicitConstructorCall(start.Position)

;         ParseArguments(ctorDef.Arguments)

;         if Accept(TokenType.LeftCurly).Success
;             for Peek.Type != TokenType.RightCurly
;                 res = Accept(TokenType.Identifier, TokenType.Assign)
;                 if res.Failure
;                     ret InvalidTokenErrorExpression("Invalid token in implicit constructor", res)

;                 var prop = GetToken(res).Value

;                 var right = ParseExpression()
;                 if right.Error
;                     ret right

;                 ctorDef.InitNames.Add(prop)
;                 ctorDef.InitValues.Add(right.Result)

;                 Accept(TokenType.Comma)

;             res = Accept(TokenType.RightCurly)
;             if res.Failure
;                 ret InvalidTokenErrorExpression("Invalid token in implicit constructor", res)

;         ret new ParseResult{Expression}(ctorDef)

;         for Accept(TokenType.Comma).Success
;             argExpr = ParseExpression()
;             if argExpr.Error
;                 ret argExpr
;             indexer.Arguments.Add(argExpr.Result)

;         if res = Accept(TokenType.RightBracket), res.Failure
;             ret InvalidTokenErrorExpression("Invalid token in indexer", res)

;         ret new ParseResult{Expression}(indexer)

;     private fn ParseInterface(modifiers List{Modifier}) ParseResult{Statement}
;         var res = Accept(TokenType.Interface, TokenType.Identifier)

;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in interface", res)

;         var intf = new Interface(GetToken(res, 1).Position, modifiers, GetToken(res, 1).Value)

;         ParseGenericNames(intf.GenericNames)

;         if Accept(TokenType.Has).Success
;             var interfaceType = ParseType()
;             if !interfaceType.Error
;                 intf.Interfaces.Add(interfaceType.Result)

;             for Accept(TokenType.Comma).Success
;                 interfaceType = ParseType()
;                 if !interfaceType.Error
;                     intf.Interfaces.Add(interfaceType.Result)

;         res = Accept(TokenType.EOL, TokenType.Indent)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in interface", res)

;         for Peek.Type != TokenType.Dedent
;             var ist = ParseInterfaceStatement()
;             if ist.Error
;                 ret ist
;             intf.Statements.Add(ist.Result)

;         res = Accept(TokenType.Dedent)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in interface", res)

;         ret new ParseResult{Statement}(intf)

;     private fn ParseInterfaceStatement() ParseResult{Statement}
;         var startToken = Peek
;         var size = 0
;         for Peek.Type == TokenType.EOL
;             Next()
;             size += 1

;         if size > 0
;             ret new ParseResult{Statement}(new Space(startToken.Position, size))

;         if Peek.Type == TokenType.Comment
;             ret ParseComment()

;         var modifiers = new List{Modifier}()
;         var modRes = ParseModifiers(modifiers)
;         if modRes != null
;             ret modRes

;         var res = Accept(TokenType.Function, TokenType.Identifier)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in interface", res)

;         var fnPos = GetToken(res).Position
;         var name = GetToken(res, 1).Value

;         if Peek.Type == TokenType.LeftParenthesis or Peek.Type == TokenType.LeftCurly
;             ret ParseMethodSignature(modifiers, fnPos, name)

;         ret ParsePropertySignature(modifiers, fnPos, name)

;     private fn ParseMethodSignature(modifiers List{Modifier}, pos Position, name str) ParseResult{Statement}
;         ; [modifiers] fn [name]([params])
;         ; [modifiers] fn [name]([params]) [type]

;         var methodSig = new MethodSignature(pos, modifiers, name)

;         ParseGenericNames(methodSig.GenericNames)
;         ParseParameters(methodSig.Parameters)

;         ; return type
;         if Peek.Type != TokenType.EOL
;             var typeResult = ParseType()
;             if typeResult.Error and typeResult.Result is ErrorExpression ex
;                 ret ErrorStatement(ex)
;             methodSig.ReturnType = typeResult.Result

;         var res = Accept(TokenType.EOL)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in method signature", res)

;         ret new ParseResult{Statement}(methodSig)

;     ; Returns null on success, or the error statement.
;     private fn ParseModifiers(modifiers List{Modifier}) ?ParseResult{Statement}
;         for Peek.Type.IsModifier()
;             var mod = new Modifier(Peek.Position, Peek.Type.ToModifier())
;             modifiers.Add(mod)
;             Next()
;             if Accept(TokenType.LeftCurly).Success
;                 var typeRes = ParseType()
;                 if typeRes.Error and typeRes.Result is ErrorExpression ex
;                     ret ErrorStatement(ex)

;                 mod.Argument = typeRes.Result

;                 var res = Accept(TokenType.RightCurly)
;                 if res.Failure
;                     ret InvalidTokenErrorStatement("Invalid token in modifier", res)

;         ret null

;     private fn ParseNestedPrimaryExpression() ParseResult{Expression}
;         var leftResult ParseResult{Expression}
;         if Peek.Type == TokenType.Identifier
;             leftResult = ParseIdentifier()
;         else if Peek.Type == TokenType.LeftParenthesis
;             leftResult = ParseMethodCall(null)
;         else if Peek.Type == TokenType.LeftBracket
;             leftResult = ParseIndexer(null)
;         else if Peek.Type == TokenType.LeftCurly
;             leftResult = ParseGeneric(null)
;         else
;             var token = Next()
;             ret ErrorExpression("Invalid token in nested expression: " + token, token.Position)
        
;         if leftResult.Error
;             ret leftResult

;         var loop bool
;         for
;             loop = true
;             var res = Accept(TokenType.Dot, TokenType.Identifier)
;             if res.Success
;                 leftResult = new ParseResult{Expression}(new BinaryOperator(
;                     leftResult.Result.Position,
;                     leftResult.Result,
;                     BinaryOperatorType.Dot,
;                     new Identifier(GetToken(res, 1).Position, GetToken(res, 1).Value)
;                 ))
;             else
;                 res = Accept(TokenType.NullDot, TokenType.Identifier)
;                 if res.Success
;                     leftResult = new ParseResult{Expression}(new BinaryOperator(
;                         leftResult.Result.Position,
;                         leftResult.Result,
;                         BinaryOperatorType.NullDot,
;                         new Identifier(GetToken(res, 1).Position, GetToken(res, 1).Value)
;                     ))
;                 else if Peek.Type == TokenType.LeftParenthesis
;                     leftResult = ParseMethodCall(leftResult.Result)
;                 else if Peek.Type == TokenType.LeftBracket
;                     leftResult = ParseIndexer(leftResult.Result)
;                 else if Peek.Type == TokenType.LeftCurly
;                     leftResult = ParseGeneric(leftResult.Result)
;                 else if Peek.Type == TokenType.Question
;                     leftResult = ParseConditional(leftResult.Result)
;                 else
;                     loop = false
            
;             if !loop
;                 break

;         ret leftResult

;     private fn ParseNullable() ParseResult{Expression}
;         var start = Peek
;         var res = Accept(TokenType.Question)
;         if res.Failure
;             ret InvalidTokenErrorExpression("Invalid token in nullable type declaration", res)

;         var typeResult = ParseType()
;         if typeResult.Error
;             ret typeResult

;         ret new ParseResult{Expression}(new Core.Ast.Nullable(start.Position, typeResult.Result))

;     private fn ParseProperty(modifiers List{Modifier}, nameToken Token) ParseResult{Statement}
;         ; property
;         ; [modifiers] fn [name] [type] [= [expr]]
;         ; [modifiers] fn [name] [type] [get and/or set] [= [expr]]
;         ; [modifiers] fn [name] [type] is [expr]
;         ; [modifiers] fn [name] [type]
;         ;     [statements]
;         ; [modifiers] fn [name] [type] [= [expr]]
;         ;     get is [expr]
;         ;     set is [statement]
;         ; [modifiers] fn [name] [type] [= [expr]]
;         ;     get
;         ;         [statements]
;         ;     set(v)
;         ;         [statements]

;         var res AcceptResult

;         var typeResult = ParseType()
;         if typeResult.Error and typeResult.Result is ErrorExpression ex
;             ret ErrorStatement(ex)

;         var propDef = new Property(nameToken.Position, modifiers, nameToken.Value, typeResult.Result)

;         ; [modifiers] fn [name] [type] [get and/or set]
;         if Peek.Type == TokenType.Get or Peek.Type == TokenType.Set
;             var getSet = Next()
;             var other = TokenType.Set
;             if getSet.Type == TokenType.Get
;                 propDef.SetSpecified = false
;             else
;                 propDef.GetSpecified = false
;                 other = TokenType.Get

;             res = Accept(TokenType.Comma, other)
;             if res.Success
;                 if GetToken(res, 1).Type == TokenType.Get
;                     propDef.GetSpecified = true
;                 else
;                     propDef.SetSpecified = true
;         else if Accept(TokenType.Is).Success
;             ; [is [expr]]

;             var exprResult = ParseExpression()
;             if exprResult.Error and exprResult.Result is ErrorExpression exp
;                 ret ErrorStatement(exp)
;             propDef.GetStatements.Add(new Return(exprResult.Result.Position) { Value = exprResult.Result })
;             res = Accept(TokenType.EOL)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in property", res)
;             ret new ParseResult{Statement}(propDef)

;         ; [= [expr]]
;         if Accept(TokenType.Assign).Success
;             var exprResult = ParseExpression()
;             if exprResult.Error and exprResult.Result is ErrorExpression exp
;                 ret ErrorStatement(exp)
;             propDef.Value = exprResult.Result

;         res = Accept(TokenType.EOL)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in property", res)

;         if Accept(TokenType.Indent).Success
;             if Peek.Type == TokenType.Get or Peek.Type == TokenType.Set
;                 ; [modifiers] fn [name] [type]
;                 ;     get is [expr]
;                 ;     set(v) is [statement]
;                 ; [modifiers] fn [name] [type]
;                 ;     get
;                 ;         [statements]
;                 ;     set(v)
;                 ;         [statements]

;                 var other = Peek.Type == TokenType.Get ? TokenType.Set : TokenType.Get

;                 var getSetResult = ParseGetSet(propDef)
;                 if getSetResult != null
;                     ret getSetResult

;                 if Peek.Type == other
;                     getSetResult = ParseGetSet(propDef)
;                     if getSetResult != null
;                         ret getSetResult
;             else
;                 ; [modifiers] fn [name] [type]
;                 ;     [statements]

;                 for Peek.Type != TokenType.Dedent
;                     var stmt = ParseMethodStatement()
;                     if stmt.Error
;                         ret stmt
;                     propDef.GetStatements.Add(stmt.Result)

;             res = Accept(TokenType.Dedent)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in property", res)

;         ret new ParseResult{Statement}(propDef)

;     private fn ParsePropertySignature(modifiers List{Modifier}, pos Position, name str) ParseResult{Statement}
;         ; [modifiers] fn [name] [type]
;         ; [modifiers] fn [name] [type] [get and/or set]

;         var res AcceptResult

;         var typeResult = ParseType()
;         if typeResult.Error and typeResult.Result is ErrorExpression ex
;             ret ErrorStatement(ex)

;         var propSig = new PropertySignature(pos, modifiers, name, typeResult.Result)

;         if Peek.Type == TokenType.Get or Peek.Type == TokenType.Set
;             var getSet = Next()
;             var other = TokenType.Set
;             if getSet.Type == TokenType.Get
;                 propSig.SetSpecified = false
;             else
;                 propSig.GetSpecified = false
;                 other = TokenType.Get

;             res = Accept(TokenType.Comma, other)
;             if res.Success
;                 if GetToken(res, 1).Type == TokenType.Get
;                     propSig.GetSpecified = true
;                 else
;                     propSig.SetSpecified = true

;         res = Accept(TokenType.EOL)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in property signature", res)

;         ret new ParseResult{Statement}(propSig)

;     private fn ParseSpace() ParseResult{Statement}
;         var position = Peek.Position
;         var size = 0
;         for Peek.Type == TokenType.EOL
;             Next()
;             size += 1

;         ret new ParseResult{Statement}(new Space(position, size))

;     private fn ParseStruct(modifiers List{Modifier}) ParseResult{Statement}
;         var res = Accept(TokenType.Struct, TokenType.Identifier)

;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in struct", res)

;         var structRes = new Struct(GetToken(res, 1).Position, modifiers, GetToken(res, 1).Value)

;         ParseGenericNames(structRes.GenericNames)

;         if Accept(TokenType.Has).Success
;             var interfaceType = ParseType()
;             if !interfaceType.Error
;                 structRes.Interfaces.Add(interfaceType.Result)

;             for Accept(TokenType.Comma).Success
;                 interfaceType = ParseType()
;                 if !interfaceType.Error
;                     structRes.Interfaces.Add(interfaceType.Result)

;         res = Accept(TokenType.EOL, TokenType.Indent)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in struct", res)

;         for Peek.Type != TokenType.Dedent
;             var stmt = ParseClassStatement()
;             if stmt.Error
;                 ret stmt
;             structRes.Statements.Add(stmt.Result)

;         res = Accept(TokenType.Dedent)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in struct {structRes.Name}", res)

;         ret new ParseResult{Statement}(structRes)

;     private fn ParseTry() ParseResult{Statement}
;         ; try
;         ;     [statements]
;         ; catch
;         ; catch [type]
;         ; catch [type] [name]
;         ;     [statements]
;         ; fin
;         ;     [statements]

;         var res = Accept(TokenType.Try, TokenType.EOL, TokenType.Indent)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in try", res)

;         var tryDef = new Try(GetToken(res).Position)

;         for Peek.Type != TokenType.Dedent
;             var stmt = ParseMethodStatement()
;             if stmt.Error
;                 ret stmt
;             tryDef.Statements.Add(stmt.Result)

;         res = Accept(TokenType.Dedent)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in try", res)

;         var catchRes = Accept(TokenType.Catch)
;         for catchRes.Success
;             var catchStmt = new Catch(GetToken(catchRes).Position)
;             tryDef.Catches.Add(catchStmt)

;             if Peek.Type != TokenType.EOL
;                 var typeRes = ParseType()
;                 if typeRes.Error and typeRes.Result is ErrorExpression ex
;                     ret ErrorStatement(ex)

;                 catchStmt.Type = typeRes.Result
;                 res = Accept(TokenType.Identifier)
;                 if res.Success
;                     catchStmt.Name = GetToken(res).Value

;             res = Accept(TokenType.EOL, TokenType.Indent)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in catch", res)

;             for Peek.Type != TokenType.Dedent
;                 var stmt = ParseMethodStatement()
;                 if stmt.Error
;                     ret stmt
;                 catchStmt.Statements.Add(stmt.Result)

;             res = Accept(TokenType.Dedent)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in catch", res)

;             catchRes = Accept(TokenType.Catch)

;         if Accept(TokenType.Finally, TokenType.EOL, TokenType.Indent).Success
;             for Peek.Type != TokenType.Dedent
;                 var stmt = ParseMethodStatement()
;                 if stmt.Error
;                     ret stmt
;                 tryDef.FinallyStatements.Add(stmt.Result)

;             res = Accept(TokenType.Dedent)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in finally", res)

;         ret new ParseResult{Statement}(tryDef)

;     private fn ParseUsing() ParseResult{Statement}
;         ; use [name] = [expr]
;         ; use [name] = [expr]
;         ;     [statements]

;         var res = Accept(TokenType.Use, TokenType.Identifier, TokenType.Assign)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in use", res)

;         var pos = GetToken(res).Position
;         var name = GetToken(res, 1).Value

;         var exprRes = ParseExpression()
;         if exprRes.Error and exprRes.Result is ErrorExpression ex
;             ret ErrorStatement(ex)

;         res = Accept(TokenType.EOL)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in use", res)

;         var useRes = new Using(pos, name, exprRes.Result)

;         if Accept(TokenType.Indent).Success
;             for Peek.Type != TokenType.Dedent
;                 var stmtRes = ParseMethodStatement()
;                 if stmtRes.Error
;                     ret stmtRes
;                 useRes.Statements.Add(stmtRes.Result)

;             res = Accept(TokenType.Dedent)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in use", res)

;         ret new ParseResult{Statement}(useRes)
