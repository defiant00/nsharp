use NSharp.Core
use NSharp.Core.SyntaxTree
use NSharp.Language.Min.TokenTree

ns NSharp.Language.Min

public class Parser
    private fn Settings Settings
    private fn Result LoadResult
    private fn CurrentIndex int = 0

    public fn new(settings Settings, result LoadResult)
        Settings = settings
        Result = result
    
    private fn AddError(code str, message str, position Position)
        Result.Diagnostics.Add(new Diagnostic(Severity.Error, code, message, position))
    
    private fn InvalidToken(tokens ITokenList, type str, result AcceptResult)
        var token = tokens.ErrorToken(result)
        var missed = result.MissedTokenType
        var error = "Invalid token in {type} when looking for {missed}: {token}"
        AddError("[code]", error, token.Position)
    
    private fn AdvanceLine(tokens ITokenList)
        EnsureNoExtraTokens(tokens)
        tokens.AdvanceParent()
    
    private fn EnsureNoExtraTokens(tokens ITokenList)
        for i = tokens.CurrentIndex, i < tokens.Tokens.Count, i += 1
            AddError("[code]", "extra token {tokens.Tokens[i]}", tokens.Tokens[i].Position)

    public fn Parse(fileName str) Core.SyntaxTree.File
        var builder = new TokenTreeBuilder(fileName, Settings, Result.Diagnostics)

        var file = ParseFile(builder.TokenTree, fileName)

        if Settings.PrintSyntaxTree
            file.Accept(new SyntaxTreePrinterVisitor())

        ret file
    
    private fn ParseAnonymousFunction(tokens ITokenList) Expression
        ; "fn" "(" [params] ")" [type] ":" statement
        ; "fn" "(" [params] ")" [type]
        ;     {statements}
        ; "/fn"

        var anonFnExpr = new AnonymousFunction(tokens.Peek().Position)

        if res = tokens.Accept(TokenType.Function), res.Failure
            InvalidToken(tokens, "anonymous function", res)
            tokens.Advance()
            ret anonFnExpr

        ; parameters
        if !ParseParameters(tokens, anonFnExpr.Parameters)
            AddError("[code]", "missing parameters", anonFnExpr.Position)

        ; optional return type
        if tokens.More() and tokens.Peek().Type != TokenType.Colon
            anonFnExpr.ReturnType = ParseType(tokens)
        
        ; ":" statement
        if tokens.Accept(TokenType.Colon).Success
            anonFnExpr.Statements.Add(ParseMethodStatement(tokens))
            ret anonFnExpr
        
        ; {statements}

        ; todo - AdvanceLine(tokens)
        ; todo - use tokens.Parent?
        ; todo - ParseIndentBlock(tokens, classStmt.Statements, ParseClassLine)

        ; todo - advance the line again and then check for FunctionEnd

        ret anonFnExpr

    private fn ParseArrayLiteral(tokens ITokenList) Expression
        ; "[" [expressions] "]"
        if tokens.Next() is BracketGroup bracketGroup
            var arrayExpr = new ArrayLiteral(bracketGroup.Position)
            if bracketGroup.More()
                arrayExpr.Values.Add(ParseExpression(bracketGroup))
                for bracketGroup.Accept(TokenType.Comma).Success and bracketGroup.More()
                    arrayExpr.Values.Add(ParseExpression(bracketGroup))
            EnsureNoExtraTokens(bracketGroup)
            ret arrayExpr
        ret new BadExpressionToken()
    
    private fn ParseArgument(tokens ITokenList) Expression
        ; [name "="] ["out" | "ref"] expression
        var startPos = tokens.Peek().Position
        var name ?Token = null
        if res = tokens.Accept(TokenType.Identifier, TokenType.Assign), res.Success
            name = tokens.Token(res)
        
        ; modifiers
        var modifiers = new List{ArgumentModifierToken}()
        for tokens.Peek().Type.IsArgumentModifier()
            modifiers.Add(tokens.Next().ToArgumentModifierToken())
        
        var argStmt = new Argument(startPos, modifiers, ParseExpression(tokens))
        if name != null
            argStmt.Name = name.ToIdentifierToken()
        
        ret argStmt

    private fn ParseArguments(tokens ITokenList, args List{Expression}) bool
        ; "(" [arguments] ")"
        if tokens.Next() is ParenthesisGroup parenthesisGroup
            if parenthesisGroup.More()
                args.Add(ParseArgument(parenthesisGroup))
                for parenthesisGroup.Accept(TokenType.Comma).Success and parenthesisGroup.More()
                    args.Add(ParseArgument(parenthesisGroup))
            EnsureNoExtraTokens(parenthesisGroup)
            ret true
        ret false

    private fn ParseArrayType(tokens ITokenList) Expression
        ; "[]" type
        if tokens.Next() is BracketGroup bracketGroup
            if !bracketGroup.Tokens.Any()
                ret new ArrayType(bracketGroup.Position, ParseType(tokens))
            else
                AddError("[code]", "an array type shouldn't have anything in the []s", bracketGroup.Position)
        ret new BadExpressionToken()

    private fn ParseBinaryOperatorRightSide(tokens ITokenList, leftPrecedence int, left Expression) Expression
        for
            var tokenPrecedence = tokens.Peek().Precedence()

            ; If this is a binary operator that binds at least as tightly as the
            ; current operator then consume it, otherwise we're done.
            if tokenPrecedence < leftPrecedence
                ret left

            var op = tokens.Next()
            var right = op.Type.IsOperatorCanThrow() ? ParseThrowOr(ParsePrimaryExpression, tokens) : ParsePrimaryExpression(tokens)
            
            ; If it's a named expression (currently only 'is') then accept the
            ; next token as the name if it's a literal.
            if op.Type == TokenType.Is and tokens.Peek().Type == TokenType.Identifier
                right = new NamedExpression(right.Position, right, tokens.Next().ToIdentifierToken())

            ; If the binary operator binds less tightly with the right than the operator
            ; after the right, let the pending operator take the right as its left.
            if tokenPrecedence < tokens.Peek().Precedence()
                right = ParseBinaryOperatorRightSide(tokens, tokenPrecedence + 1, right)

            ; Merge left and right.
            left = new BinaryOperator(left.Position, left, op.ToBinaryOperatorToken(), right)

    private fn ParseBlock(tokens ITokenList) Statement
        var blockStmt = new Core.SyntaxTree.Block(tokens.Peek().Position)
        if res = tokens.Accept(TokenType.DoubleColon), res.Failure
            InvalidToken(tokens, "block", res)
        AdvanceLine(tokens)
        ParseIndentBlock(tokens, blockStmt.Statements, ParseMethodStatement)
        ret blockStmt

    private fn ParseBreak(tokens ITokenList) Statement
        if res = tokens.Accept(TokenType.Break), res.Success
            AdvanceLine(tokens)
            ret new BreakToken(tokens.Token(res).Position)
        else
            InvalidToken(tokens, "break", res)
            AdvanceLine(tokens)
            ret new BadStatementToken()

    private fn ParseContinue(tokens ITokenList) Statement
        if res = tokens.Accept(TokenType.Continue), res.Success
            AdvanceLine(tokens)
            ret new ContinueToken(tokens.Token(res).Position)
        else
            InvalidToken(tokens, "continue", res)
            AdvanceLine(tokens)
            ret new BadStatementToken()

    private fn ParseClass(tokens ITokenList) Statement
        ; "class" name "(" [params] ")" ["is" base] ["has" interfaces]
        var res = tokens.Accept(TokenType.Class, TokenType.Identifier)
        if res.Failure
            InvalidToken(tokens, "class", res)
            tokens.Advance()
            ret new BadStatementToken()
        
        var classStmt = new Class(tokens.Token(res).Position, tokens.Token(res, 1).ToIdentifierToken())

        ; todo - ParseGenericNames(classResult.GenericNames)

        if tokens.Accept(TokenType.Is).Success
            classStmt.Base = ParseType(tokens)

        if tokens.Accept(TokenType.Has).Success
            classStmt.Interfaces.Add(ParseType(tokens))
            for tokens.Accept(TokenType.Comma).Success
                classStmt.Interfaces.Add(ParseType(tokens))

        AdvanceLine(tokens)

        ParseIndentBlock(tokens, classStmt.Statements, ParseClassStatement)

        ret classStmt
    
    private fn ParseClassStatement(tokens ITokenList) Statement
        if !tokens.Tokens.Any()
            ret ParseSpace(tokens)
        if token = tokens.Tokens[0], token.Type
            is TokenType.Class
                ret ParseClass(tokens)
            is TokenType.Comment
                ret ParseComment(tokens)
            is TokenType.Function
                ret ParseMethodOrProperty(tokens)
            is TokenType.Value
                ret ParseConstant(tokens)
            is TokenType.Variable
                ret ParseField(tokens)
        
        ; var modifiers = new List{Modifier}()
        ; var modRes = ParseModifiers(modifiers)
        ; if modRes != null
        ;     ret modRes

        ; if Peek.Type
        ;     is TokenType.Interface
        ;         ret ParseInterface(modifiers)
        ;     is TokenType.Struct
        ;         ret ParseStruct(modifiers)
        ;     is TokenType.Delegate
        ;         ret ParseDelegate(modifiers)
        ;     is TokenType.Enum
        ;         ret ParseEnum(modifiers)

        AdvanceLine(tokens)
        ret new BadStatementToken()

    private fn ParseComment(tokens ITokenList) Statement
        ; ";" comment
        if res = tokens.Accept(TokenType.Comment), res.Failure
            InvalidToken(tokens, "comment", res)
            AdvanceLine(tokens)
            ret new BadStatementToken()
        else
            var commentStmt = new CommentToken(tokens.Token(res).Position, tokens.Token(res).Value)
            if commentStmt.Value.StartsWith(";")
                commentStmt.Value = commentStmt.Value.Substring(1)
                commentStmt.IsDocumentation = true
            AdvanceLine(tokens)
            ret commentStmt
    
    private fn ParseCondition(tokens ITokenList) Statement
        var expr = ParseExpression(tokens)

        if res = tokens.Accept(TokenType.Colon), res.Failure
            InvalidToken(tokens, "condition", res)
            tokens.Advance()
            ret new BadStatementToken()
        
        ; Condition results can be a throw.
        var result = ParseThrowOr(ParseExpression, tokens)

        ret new Condition(expr.Position, expr, result)
    
    private fn ParseConditional(tokens ITokenList, expr Expression) Expression
        ; expr "?" true expr ":" false expr
        ; expr "?" "{" value ":" result {"," value ":" result} "}"
        if res = tokens.Accept(TokenType.Question), res.Failure
            InvalidToken(tokens, "conditional", res)
            tokens.Advance()
            ret new BadExpressionToken()
        
        var conditionalExpr = new Conditional(expr.Position, expr)

        if tokens.Peek().Type != TokenType.CurlyGroup
            ; Condition results can be a throw.
            var trueRes = ParseThrowOr(ParseExpression, tokens)
            conditionalExpr.Conditions.Add(new Condition(
                trueRes.Position,
                new LiteralToken(trueRes.Position, LiteralType.True),
                trueRes
            ))

            if res = tokens.Accept(TokenType.Colon), res.Failure
                InvalidToken(tokens, "conditional", res)
                tokens.Advance()
                ret conditionalExpr
            
            ; Condition results can be a throw.
            var falseRes = ParseThrowOr(ParseExpression, tokens)
            conditionalExpr.Conditions.Add(new Condition(
                falseRes.Position,
                new LiteralToken(falseRes.Position, LiteralType.False),
                falseRes
            ))
        else
            var curlyGroup = tokens.Next() as CurlyGroup
            if curlyGroup.More()
                conditionalExpr.Conditions.Add(ParseCondition(curlyGroup))
                for curlyGroup.Accept(TokenType.Comma).Success and curlyGroup.More()
                    conditionalExpr.Conditions.Add(ParseCondition(curlyGroup))
            else
                AddError("[code]", "a conditional should have at least one condition", curlyGroup.Position)
            EnsureNoExtraTokens(curlyGroup)
        
        ret conditionalExpr

    private fn ParseConstant(tokens ITokenList) Statement
        ; "val" name type ["=" expr]
        var res = tokens.Accept(TokenType.Value, TokenType.Identifier)
        if res.Failure
            InvalidToken(tokens, "constant", res)
            AdvanceLine(tokens)
            ret new BadStatementToken()

        var constStmt = new Core.SyntaxTree.Constant(tokens.Token(res).Position,
            tokens.Token(res, 1).ToIdentifierToken(),
            ParseType(tokens)
        )

        if tokens.Accept(TokenType.Assign).Success
            constStmt.Value = ParseExpression(tokens)
        
        AdvanceLine(tokens)
        ret constStmt

    private fn ParseConstructorCall(tokens ITokenList) Expression
        ; "new" [type] "(" [args] ")" ["{" [initializers] "}"]
        var res = tokens.Accept(TokenType.New)
        if res.Failure
            InvalidToken(tokens, "constructor call", res)
            tokens.Advance()
            ret new BadExpressionToken()
        
        var ctorExpr = new ConstructorCall(tokens.Token(res).Position)

        if tokens.Peek().Type != TokenType.CurlyGroup and tokens.Peek().Type != TokenType.ParenthesisGroup
            ctorExpr.Type = ParseType(tokens)
        
        ParseArguments(tokens, ctorExpr.Arguments)
        ParseInitializers(tokens, ctorExpr.Initializers)

        ret ctorExpr

    private fn ParseConstructorDefinition(tokens ITokenList, start Token) Statement
        ; "fn" "new" "(" {params} ")" ["base" "(" {exprs} ")"] [":" statement]
        ; "fn" "new" "(" {params} ")" ["base" "(" {exprs} ")"]
        ;     {statements}
        if res = tokens.Accept(TokenType.New), res.Failure
            InvalidToken(tokens, "constructor", res)
            AdvanceLine(tokens)
            ret new BadStatementToken()
    
        var ctorStmt = new ConstructorDefinition(start.Position)

        if !ParseParameters(tokens, ctorStmt.Parameters)
            AddError("[code]", "missing parameters", start.Position)

        ; "base" "(" {exprs} ")"
        if tokens.Accept(TokenType.Base).Success
            if !ParseArguments(tokens, ctorStmt.BaseArguments)
                AddError("[code]", "missing base parameters", start.Position)
        
        ; ":" statement
        if tokens.Accept(TokenType.Colon).Success
            ctorStmt.Statements.Add(ParseMethodStatement(tokens))
        else
            ; {statements}
            AdvanceLine(tokens)
            ParseIndentBlock(tokens, ctorStmt.Statements, ParseMethodStatement)

        ret ctorStmt

    private fn ParseExpressionStatement(tokens ITokenList) Statement
        var exprStmt = new ExpressionStatement(tokens.Peek().Position, ParseExpression(tokens))
        AdvanceLine(tokens)
        ret exprStmt

    private fn ParseField(tokens ITokenList) Statement
        ; "var" name type ["=" expr]

        var res = tokens.Accept(TokenType.Variable, TokenType.Identifier)
        if res.Failure
            InvalidToken(tokens, "field", res)
            AdvanceLine(tokens)
            ret new BadStatementToken()

        var fieldStmt = new Field(tokens.Token(res).Position,
            tokens.Token(res, 1).ToIdentifierToken(),
            ParseType(tokens)
        )

        if tokens.Accept(TokenType.Assign).Success
            fieldStmt.Value = ParseExpression(tokens)
        
        AdvanceLine(tokens)
        ret fieldStmt

    private fn ParseExpression(tokens ITokenList) Expression
        var left = ParsePrimaryExpression(tokens)
        ret ParseBinaryOperatorRightSide(tokens, 0, left)

    private fn ParseFile(tokenTree TokenTree.File, fileName str) Core.SyntaxTree.File
        var file = new Core.SyntaxTree.File(Path.GetFileName(fileName))

        ; A file can contain lines and blocks.
        ; However, a block on its own is an error.
        for node = tokenTree.Peek(), node != null, node = tokenTree.Peek()
            if node is Line line
                file.Statements.Add(ParseFileStatement(line))
            else
                AddError("[code]", "unused block", node.Position)
                tokenTree.Advance()

        ret file
    
    private fn ParseFileStatement(tokens ITokenList) Statement
        if !tokens.Tokens.Any()
            ret ParseSpace(tokens)
        if token = tokens.Tokens[0], token.Type
            is TokenType.Class
                ret ParseClass(tokens)
            is TokenType.Comment
                ret ParseComment(tokens)
            is TokenType.Namespace
                ret ParseNamespace(tokens)
            is TokenType.Use
                ret ParseImport(tokens)
            
        ; is TokenType.Delegate
        ; is TokenType.Enum
        ; is TokenType.Interface
        ; is TokenType.Struct
        ;     file.Statements.Add(ParseFileModifiableStatement().Result)
        ; is _
        ;     if Peek.Type.IsModifier()
        ;         file.Statements.Add(ParseFileModifiableStatement().Result)

        AdvanceLine(tokens)
        ret new BadStatementToken()

    private fn ParseGeneric(tokens ITokenList, expr Expression) Expression
        ; "{" {arguments} "}"
        var argsExpr = new Arguments(tokens.Peek().Position, expr)
        if tokens.Next() is CurlyGroup curlyGroup
            if curlyGroup.More()
                argsExpr.Values.Add(ParseType(curlyGroup))
                for curlyGroup.Accept(TokenType.Comma).Success and curlyGroup.More()
                    argsExpr.Values.Add(ParseType(curlyGroup))
            else
                AddError("[code]", "generics must have an argument", curlyGroup.Position)
            EnsureNoExtraTokens(curlyGroup)
        ret argsExpr

    private fn ParseIdentifier(tokens ITokenList) Expression
        if res = tokens.Accept(TokenType.Identifier), res.Failure
            InvalidToken(tokens, "identifier", res)
            tokens.Advance()
            ret new BadExpressionToken()
        else
            ret tokens.Token(res).ToIdentifierToken()

    private fn ParseImport(tokens ITokenList) ImportToken
        var importToken = new ImportToken(tokens.Position)

        if res = tokens.Accept(TokenType.Use, TokenType.Identifier), res.Failure
            InvalidToken(tokens, "use", res)
            tokens.Advance()
            ret importToken
        else
            importToken.Position = tokens.Token(res).Position
            importToken.NameParts.Add(tokens.Token(res, 1).Value)

        for res = tokens.Accept(TokenType.Dot, TokenType.Identifier),
                res.Success,
                res = tokens.Accept(TokenType.Dot, TokenType.Identifier)
            importToken.NameParts.Add(tokens.Token(res, 1).Value)

        AdvanceLine(tokens)

        ret importToken
    
    private fn ParseIndentBlock(tokens ITokenList, statements List{Statement}, stmtFn Func{ITokenList, Statement}) bool
        if tokens.Parent is IBlock block and block.Peek() is IndentBlock indentBlock
            for node = indentBlock.Peek(), node != null, node = indentBlock.Peek()
                if node is ITokenList tokenList
                    statements.Add(stmtFn(tokenList))
                else
                    throw new InvalidItemException()
            block.Advance()
            ret true
        ret false

    private fn ParseIndexer(tokens ITokenList, expr Expression) Expression
        ; "[" {arguments} "]"
        var argsExpr = new Arguments(tokens.Peek().Position, expr)
        if tokens.Next() is BracketGroup bracketGroup
            if bracketGroup.More()
                argsExpr.Values.Add(ParseExpression(bracketGroup))
                for bracketGroup.Accept(TokenType.Comma).Success and bracketGroup.More()
                    argsExpr.Values.Add(ParseExpression(bracketGroup))
            else
                AddError("[code]", "indexer must have an argument", bracketGroup.Position)
            EnsureNoExtraTokens(bracketGroup)
        ret argsExpr

    private fn ParseInitializer(tokens ITokenList) Statement
        ; name "=" expression
        if res = tokens.Accept(TokenType.Identifier, TokenType.Assign), res.Failure
            InvalidToken(tokens, "initializer", res)
            tokens.Advance()
            ret new BadStatementToken()
        else
            ret new Initializer(tokens.Token(res).Position, tokens.Token(res).ToIdentifierToken(), ParseExpression(tokens))

    private fn ParseInitializers(tokens ITokenList, inits List{Statement})
        ; "{" {initializers} "}"
        if tokens.Next() is CurlyGroup curlyGroup
            if curlyGroup.More()
                inits.Add(ParseInitializer(curlyGroup))
                for curlyGroup.Accept(TokenType.Comma).Success and curlyGroup.More()
                    inits.Add(ParseInitializer(curlyGroup))
            EnsureNoExtraTokens(curlyGroup)

    private fn ParseLocalConstant(tokens ITokenList) Statement
        ; "val" name "=" expr
        var res = tokens.Accept(TokenType.Value, TokenType.Identifier)
        if res.Failure
            InvalidToken(tokens, "val", res)
            AdvanceLine(tokens)
            ret new BadStatementToken()
        
        var position = tokens.Token(res).Position
        var nameIdentifierToken = tokens.Token(res, 1).ToIdentifierToken()

        if tokens.Accept(TokenType.Assign).Failure
            InvalidToken(tokens, "val", res)
            AdvanceLine(tokens)
            ret new BadStatementToken()
        
        var value = ParseExpression(tokens)

        AdvanceLine(tokens)
        ret new LocalConstant(position, nameIdentifierToken, value)

    private fn ParseLocalVariable(tokens ITokenList) Statement
        ; "var" name [type] ["=" expr]
        var res = tokens.Accept(TokenType.Variable, TokenType.Identifier)
        if res.Failure
            InvalidToken(tokens, "var", res)
            AdvanceLine(tokens)
            ret new BadStatementToken()
        
        var varStmt = new LocalVariable(tokens.Token(res).Position, tokens.Token(res, 1).ToIdentifierToken())

        if tokens.More() and tokens.Peek().Type != TokenType.Assign
            varStmt.Type = ParseType(tokens)

        if tokens.Accept(TokenType.Assign).Success
            varStmt.Value = ParseExpression(tokens)

        AdvanceLine(tokens)
        ret varStmt

    private fn ParseMethodCall(tokens ITokenList expr Expression) Expression
        ; method "(" {arguments} ")"
        var argsExpr = new Arguments(tokens.Peek().Position, expr)
        if !ParseArguments(tokens, argsExpr.Values)
            AddError("[code]", "missing arguments", argsExpr.Position)
        ret argsExpr

    private fn ParseMethodDefinition(tokens ITokenList, nameIdentifierToken IdentifierToken) Statement
        ; "fn" name "(" {params} ")" [type] [":" statement]
        ; "fn" name "(" {params} ")" [type]
        ;     {statements}
        var methodStmt = new Method(nameIdentifierToken.Position, nameIdentifierToken)

        ; todo - ParseGenericNames

        if !ParseParameters(tokens, methodStmt.Parameters)
            AddError("[code]", "missing parameters", nameIdentifierToken.Position)
        
        if tokens.More() and tokens.Peek().Type != TokenType.Colon
            methodStmt.ReturnType = ParseType(tokens)
        
        ; ":" statement
        if tokens.Accept(TokenType.Colon).Success
            if methodStmt.ReturnType != null
                var expr = ParseExpression(tokens)
                methodStmt.Statements.Add(new Return(expr.Position){Value = expr})
                AdvanceLine(tokens)
            else
                methodStmt.Statements.Add(ParseMethodStatement(tokens))
        else
            ; {statements}
            AdvanceLine(tokens)
            ParseIndentBlock(tokens, methodStmt.Statements, ParseMethodStatement)
        
        ret methodStmt

    private fn ParseMethodOrProperty(tokens ITokenList) Statement
        var start = tokens.Peek()
        var res = tokens.Accept(TokenType.Function)
        if res.Failure
            InvalidToken(tokens, "method or property", res)
            AdvanceLine(tokens)
            ret new BadStatementToken()

        if tokens.Peek().Type == TokenType.New
            ret ParseConstructorDefinition(tokens, start)
        
        res = tokens.Accept(TokenType.Identifier)
        if res.Failure
            InvalidToken(tokens, "method or property", res)
            AdvanceLine(tokens)
            ret new BadStatementToken()
        
        var nameIdentifierToken = tokens.Token(res).ToIdentifierToken()

        if tokens.Peek().Type == TokenType.ParenthesisGroup
            ret ParseMethodDefinition(tokens, nameIdentifierToken)
        
        ; todo - ret ParseProperty(tokens, nameIdentifierToken)

        AdvanceLine(tokens)
        ret new BadStatementToken()

    private fn ParseMethodStatement(tokens ITokenList) Statement
        if !tokens.Tokens.Any()
            ret ParseSpace(tokens)
        ret tokens.Peek().Type ?
        {
            TokenType.Break is ParseBreak(tokens),
            TokenType.Comment is ParseComment(tokens),
            TokenType.Continue is ParseContinue(tokens),
            TokenType.DoubleColon is ParseBlock(tokens),
            TokenType.Return is ParseReturn(tokens),
            TokenType.Value is ParseLocalConstant(tokens),
            TokenType.Variable is ParseLocalVariable(tokens),
            _ is ParseExpressionStatement(tokens),
        }
        ; TokenType.For is ParseFor(),
        ; TokenType.If is ParseIf(),
        ; TokenType.Try is ParseTry(),
        ; TokenType.Use is ParseUsing(),

    private fn ParseNamespace(tokens ITokenList) NamespaceToken
        ; "ns" namespace
        var namespaceToken = new NamespaceToken(tokens.Position)

        if res = tokens.Accept(TokenType.Namespace, TokenType.Identifier), res.Failure
            InvalidToken(tokens, "namespace", res)
            tokens.Advance()
        else
            namespaceToken.Position = tokens.Token(res).Position
            namespaceToken.NameParts.Add(tokens.Token(res, 1).Value)
        
        for res = tokens.Accept(TokenType.Dot, TokenType.Identifier),
                res.Success,
                res = tokens.Accept(TokenType.Dot, TokenType.Identifier)
            namespaceToken.NameParts.Add(tokens.Token(res, 1).Value)
        
        AdvanceLine(tokens)

        ret namespaceToken
    
    private fn ParseNullableType(tokens ITokenList) Expression
        ; "?" type
        if res = tokens.Accept(TokenType.Question), res.Failure
            InvalidToken(tokens, "nullable type", res)
            tokens.Advance()
            ret new BadExpressionToken()
        else
            ret new NullableType(tokens.Token(res).Position, ParseType(tokens))
    
    private fn ParseNumber(tokens ITokenList) Expression
        if res = tokens.Accept(TokenType.NumberLiteral), res.Success
            var numVal = tokens.Token(res).Value
            var numType = NumberType.Decimal

            if numVal.StartsWith("0b")
                numVal = numVal.Substring(2)
                numType = NumberType.Binary
            else if numVal.StartsWith("0x")
                numVal = numVal.Substring(2)
                numType = NumberType.Hexadecimal
            
            ret new NumberToken(tokens.Token(res).Position, numType, numVal)
        
        tokens.Advance()
        ret new BadExpressionToken()

    private fn ParseParameter(tokens ITokenList) Statement
        ; name [modifiers] [type] ["=" expression]
        var res = tokens.Accept(TokenType.Identifier)
        if res.Failure
            InvalidToken(tokens, "parameter", res)
        
        var paramStmt = new Parameter(tokens.Token(res).Position, tokens.Token(res).ToIdentifierToken())

        ; modifiers
        for tokens.Peek().Type.IsParameterModifier()
            paramStmt.Modifiers.Add(tokens.Next().ToParameterModifierToken())
        
        ; type
        if tokens.More() and tokens.Peek().Type != TokenType.Comma and tokens.Peek().Type != TokenType.Assign
            paramStmt.Type = ParseType(tokens)
        
        ; default value
        if tokens.Accept(TokenType.Assign).Success
            paramStmt.Value = ParseExpression(tokens)
        
        ret paramStmt

    private fn ParseParameters(tokens ITokenList, parameters List{Statement}) bool
        ; "(" {parameters} ")"
        if tokens.Next() is ParenthesisGroup parenthesisGroup
            if parenthesisGroup.More()
                parameters.Add(ParseParameter(parenthesisGroup))
                for parenthesisGroup.Accept(TokenType.Comma).Success and parenthesisGroup.More()
                    parameters.Add(ParseParameter(parenthesisGroup))
            EnsureNoExtraTokens(parenthesisGroup)
            ret true
        ret false

    private fn ParseParenthesizedExpression(tokens ITokenList) Expression
        if tokens.Next() is ParenthesisGroup parenthesisGroup
            ret ParseExpression(parenthesisGroup)
        ret new BadExpressionToken()
    
    private fn ParsePrimaryExpression(tokens ITokenList) Expression
        var expr Expression
        if peekType = tokens.Peek().Type, peekType
            is TokenType.BracketGroup
                var bracketGroup = tokens.Peek() as BracketGroup
                if bracketGroup.Tokens.Any()
                    expr = ParseArrayLiteral(tokens)
                else
                    expr = ParseArrayType(tokens)
            is TokenType.Function
                expr = ParseAnonymousFunction(tokens)
            is TokenType.Identifier
                expr = ParseIdentifier(tokens)
            is TokenType.New
                expr = ParseConstructorCall(tokens)
            is TokenType.NumberLiteral
                expr = ParseNumber(tokens)
            is TokenType.ParenthesisGroup
                expr = ParseParenthesizedExpression(tokens)
            is TokenType.Question
                expr = ParseNullableType(tokens)
            is TokenType.StringGroup
                expr = ParseString(tokens)
            is _
                if peekType.IsType()
                    expr = ParseTypeToken(tokens)
                else if peekType.IsUnaryOperator()
                    expr = ParseUnaryOperator(tokens)
                else
                    var token = tokens.Next()
                    expr = token.Type ?
                    {
                        TokenType.CharacterLiteral is new CharacterToken(token.Position, token.Value),
                        TokenType.Default is new DefaultValueToken(token.Position),
                        TokenType.Discard is new DiscardToken(token.Position),
                        TokenType.False is new LiteralToken(token.Position, LiteralType.False),
                        TokenType.Null is new LiteralToken(token.Position, LiteralType.Null),
                        TokenType.This is new CurrentObjectInstanceToken(token.Position),
                        TokenType.True is new LiteralToken(token.Position, LiteralType.True),
                        _ is new BadExpressionToken()
                    }
        
        var loop = true
        for loop
            if res = tokens.Accept(TokenType.Dot, TokenType.Identifier), res.Success
                expr = new BinaryOperator(expr.Position, expr,
                    tokens.Token(res).ToBinaryOperatorToken(),
                    tokens.Token(res, 1).ToIdentifierToken())
            else if ndRes = tokens.Accept(TokenType.NullDot, TokenType.Identifier), ndRes.Success
                expr = new BinaryOperator(expr.Position, expr,
                    tokens.Token(res).ToBinaryOperatorToken(),
                    tokens.Token(res, 1).ToIdentifierToken())
            else
                if token = tokens.Peek(), token.Type
                    is TokenType.BracketGroup
                        expr = ParseIndexer(tokens, expr)
                    is TokenType.CurlyGroup
                        expr = ParseGeneric(tokens, expr)
                    is TokenType.ParenthesisGroup
                        expr = ParseMethodCall(tokens, expr)
                    is TokenType.Question
                        expr = ParseConditional(tokens, expr)
                    is _
                        loop = false

        ret expr

    private fn ParseReturn(tokens ITokenList) Statement
        ; "ret" [expr]
        if res = tokens.Accept(TokenType.Return), res.Failure
            InvalidToken(tokens, "return", res)
            AdvanceLine(tokens)
            ret new BadStatementToken()
        else
            var returnStmt = new Return(tokens.Token(res).Position)
            if tokens.More()
                returnStmt.Value = ParseExpression(tokens)
            AdvanceLine(tokens)
            ret returnStmt

    private fn ParseSpace(tokens ITokenList) Statement
        if tokens.Parent is IBlock block
            var size = 1
            block.Advance()
            for block.Peek() is Line curLine and !curLine.Tokens.Any()
                size += 1
                block.Advance()
            ret new SpaceToken(tokens.Position, size)
        AddError("[code]", "wasn't a block while parsing space", tokens.Position)
        ret new BadStatementToken()
    
    private fn ParseString(tokens ITokenList) Expression
        if tokens.Next() is StringGroup stringGroup
            var stringExpr = new Core.SyntaxTree.String(tokens.Peek().Position)
            stringExpr.Lines.Add(ParseStringLine(stringGroup))
            for res = tokens.Accept(TokenType.DoubleDot, TokenType.StringGroup), res.Success,
                    res = tokens.Accept(TokenType.DoubleDot, TokenType.StringGroup)
                stringExpr.Lines.Add(ParseStringLine(tokens.Token(res, 1) as StringGroup))
            ret stringExpr
        ret new BadExpressionToken()
    
    private fn ParseStringLine(tokens ITokenList) List{Expression}
        var line = new List{Expression}()
        var loop = true
        for tokens.More() and loop
            if token = tokens.Next(), token.Type
                is TokenType.StringLiteral
                    line.Add(new StringToken(token.Position, token.Value))
                is TokenType.CurlyGroup
                    var curlyGroup = token as CurlyGroup
                    line.Add(ParseExpression(curlyGroup))
                    EnsureNoExtraTokens(curlyGroup)
                is _
                    loop = false
                    AddError("[code]", "invalid token in string: {token}", token.Position)
        EnsureNoExtraTokens(tokens)
        ret line

    private fn ParseThrowOr(parseFn Func{ITokenList, Expression}, tokens ITokenList) Expression
        if tokens.Peek().Type != TokenType.Throw
            ret parseFn(tokens)

        ; accept throw
        var start = tokens.Next()
        ret new Throw(start.Position, ParseExpression(tokens))

    private fn ParseType(tokens ITokenList) Expression
        var typeExpr Expression
        if tokens.Peek().Type
            is TokenType.BracketGroup
                ret ParseArrayType(tokens)
            is TokenType.Identifier
                typeExpr = ParseIdentifier(tokens)
            is TokenType.Question
                ret ParseNullableType(tokens)
            is _
                if tokens.Peek().Type.IsType()
                    typeExpr = ParseTypeToken(tokens)
                else
                    AddError("code", "invalid token in type: {tokens.Peek()}", tokens.Peek().Position)
                    ret new BadExpressionToken()
        
        var loop = true
        for loop
            if tokens.Peek().Type == TokenType.CurlyGroup
                typeExpr = ParseGeneric(tokens, typeExpr)
            else if res = tokens.Accept(TokenType.Dot, TokenType.Identifier), res.Success
                typeExpr = new BinaryOperator(
                    typeExpr.Position,
                    typeExpr,
                    new BinaryOperatorToken(tokens.Token(res).Position, BinaryOperatorType.Dot),
                    tokens.Token(res, 1).ToIdentifierToken()
                )
            else
                loop = false
        
        ret typeExpr

    private fn ParseTypeToken(tokens ITokenList) Expression
        var pos = tokens.Peek().Position
        var ident = new IdentifierToken(pos, tokens.Peek().Type ?
            {
                TokenType.String is "String",
                TokenType.Character is "Char",
                TokenType.Boolean is "Boolean",
                TokenType.I8 is "SByte",
                TokenType.I16 is "Int16",
                TokenType.I32 is "Int32",
                TokenType.I64 is "Int64",
                TokenType.U8 is "Byte",
                TokenType.U16 is "UInt16",
                TokenType.U32 is "UInt32",
                TokenType.U64 is "UInt64",
                TokenType.F32 is "Single",
                TokenType.F64 is "Double",
                TokenType.Decimal is "Decimal",
                _ is "Error",
            })
        tokens.Advance()
        ret new BinaryOperator(pos, new IdentifierToken(pos, "System"), new BinaryOperatorToken(pos, BinaryOperatorType.Dot), ident)

    private fn ParseUnaryOperator(tokens ITokenList) Expression
        ret new UnaryOperator(tokens.Peek().Position, tokens.Next().ToUnaryOperatorToken(), ParsePrimaryExpression(tokens))

;     private fn ParseAssignment(left Expression) ParseResult{Statement}
;         var op = Next().Type.ToAssignmentOperator()
;         var right = ParseExpression()
;         if right.Error
;             ToNextLine()
;         else if res = Accept(TokenType.EOL), res.Failure
;             LogError("assignment", res)
;             ToNextLine()
;         ret new ParseResult{Statement}(new Assignment(left.Position, left, op, right.Result))

;     private fn ParseDelegate(modifiers List{Modifier}) ParseResult{Statement}
;         ; [modifiers] del [name]([params])
;         ; [modifiers] del [name]([params]) [type]

;         ; accept del
;         Next()

;         var res = Accept(TokenType.Identifier)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in delegate", res)

;         var nameToken = GetToken(res)

;         var delegateDef = new DelegateDefinition(nameToken.Position, modifiers, nameToken.Value)

;         ParseGenericNames(delegateDef.GenericNames)
;         ParseParameters(delegateDef.Parameters)

;         if Peek.Type != TokenType.EOL
;             var retType = ParseType()
;             if !retType.Error
;                 delegateDef.ReturnType = retType.Result

;         res = Accept(TokenType.EOL)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in delegate", res)

;         ret new ParseResult{Statement}(delegateDef)

;     private fn ParseEnum(modifiers List{Modifier}) ParseResult{Statement}
;         ; [modifiers] enum [name]
;         ;     Val
;         ;     Val2 = 3
;         ;     Val3 ; comment
;         ;     Val4 = 5 ; comment

;         var res = Accept(TokenType.Enum, TokenType.Identifier, TokenType.EOL, TokenType.Indent)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in enum", res)

;         var enumDef = new Enumeration(GetToken(res).Position, modifiers, GetToken(res, 1).Value)

;         for Peek.Type != TokenType.Dedent
;             res = Accept(TokenType.Identifier)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in enum", res)
;             var enumItem = new EnumerationItem(GetToken(res).Position, GetToken(res).Value)

;             res = Accept(TokenType.Assign, TokenType.NumberLiteral)
;             if res.Success
;                 enumItem.Value = Convert.ToInt32(GetToken(res, 1).Value)

;             if Peek.Type == TokenType.Comment
;                 var commentResult = ParseComment()
;                 if commentResult.Error
;                     ret commentResult
;                 enumItem.Comment = commentResult.Result as Comment
;             else
;                 res = Accept(TokenType.EOL)
;                 if res.Failure
;                     ret InvalidTokenErrorStatement("Invalid token in enum", res)

;             enumDef.Values.Add(enumItem)

;         res = Accept(TokenType.Dedent)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in enum", res)

;         ret new ParseResult{Statement}(enumDef)

;     private fn ParseFileModifiableStatement() ParseResult{Statement}
;         var modifiers = new List{Modifier}()
;         var modRes = ParseModifiers(modifiers)
;         if modRes != null
;             ret modRes

;         ret Peek.Type ?
;         {
;             TokenType.Class is ParseClass(modifiers),
;             TokenType.Delegate is ParseDelegate(modifiers),
;             TokenType.Enum is ParseEnum(modifiers),
;             TokenType.Interface is ParseInterface(modifiers),
;             TokenType.Struct is ParseStruct(modifiers),
;             _ is ErrorStatement("Invalid token: {Peek}", Peek.Position),
;         }



;     private fn ParseFor() ParseResult{Statement}
;         var res = Accept(TokenType.For)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in for", res)

;         var pos = GetToken(res).Position

;         ; for [name] in [expr]
;         ;     [statements]
;         ; bet
;         ;     [statements]
;         res = Accept(TokenType.Identifier, TokenType.In)
;         if res.Success
;             ; for [name] in [expr]
;             ;     [statements]

;             var name = GetToken(res).Value

;             var exprRes = ParseExpression()
;             if exprRes.Error and exprRes.Result is ErrorExpression ex
;                 ret ErrorStatement(ex)

;             var foreachDef = new ForEach(pos, name, exprRes.Result)

;             res = Accept(TokenType.EOL, TokenType.Indent)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in for", res)

;             for Peek.Type != TokenType.Dedent
;                 var stmtRes = ParseMethodStatement()
;                 if stmtRes.Error
;                     ret stmtRes
;                 foreachDef.Statements.Add(stmtRes.Result)

;             res = Accept(TokenType.Dedent)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in for", res)

;             ret new ParseResult{Statement}(foreachDef)


;         var forDef = new For(pos)

;         res = Accept(TokenType.Identifier, TokenType.Assign)
;         if res.Success
;             ; for [name] = [expr], [expr], [stmt]

;             forDef.LocalName = GetToken(res).Value
;             var exprRes = ParseExpression()
;             if exprRes.Error and exprRes.Result is ErrorExpression ex1
;                 ret ErrorStatement(ex1)

;             forDef.Init = exprRes.Result

;             res = Accept(TokenType.Comma)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in for", res)

;             exprRes = ParseExpression()
;             if exprRes.Error and exprRes.Result is ErrorExpression ex2
;                 ret ErrorStatement(ex2)

;             forDef.Condition = exprRes.Result

;             res = Accept(TokenType.Comma)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in for", res)

;             var stmtRes = ParseMethodStatement()
;             if stmtRes.Error
;                 ret stmtRes

;             forDef.Post = stmtRes.Result
;         else if Peek.Type != TokenType.EOL
;             ; for [expr]

;             var exprRes = ParseExpression()
;             if exprRes.Error and exprRes.Result is ErrorExpression ex
;                 ret ErrorStatement(ex)

;             forDef.Condition = exprRes.Result

;             res = Accept(TokenType.EOL)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in for", res)
;         else
;             res = Accept(TokenType.EOL)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in for", res)

;         ; for
;         ;     [statements]
;         res = Accept(TokenType.Indent)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in for", res)

;         for Peek.Type != TokenType.Dedent
;             var stmtRes = ParseMethodStatement()
;             if stmtRes.Error
;                 ret stmtRes
;             forDef.Statements.Add(stmtRes.Result)

;         res = Accept(TokenType.Dedent)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in for", res)

;         ret new ParseResult{Statement}(forDef)

;     private fn ParseGenericNames(genericNames List{str})
;         if Peek.Type != TokenType.LeftCurly
;             ret

;         if res = Accept(TokenType.LeftCurly, TokenType.Identifier), res.Success
;             genericNames.Add(GetToken(res, 1).Value)
;         else
;             LogError("generic", res)
;             ret

;         for res = Accept(TokenType.Comma, TokenType.Identifier), res.Success, res = Accept(TokenType.Comma, TokenType.Identifier)
;             genericNames.Add(GetToken(res, 1).Value)

;         if res = Accept(TokenType.RightCurly), res.Failure
;             LogError("generic", res)
;             To(TokenType.RightCurly)

;     ; Returns the error parse result, or null on success.
;     private fn ParseGetSet(propDef Property) ?ParseResult{Statement}
;         var res AcceptResult
;         if Peek.Type == TokenType.Get
;             if Accept(TokenType.Get, TokenType.Is).Success
;                 ; get is [expr]

;                 var exprResult = ParseExpression()
;                 if exprResult.Error and exprResult.Result is ErrorExpression exp
;                     ret ErrorStatement(exp)
;                 propDef.GetStatements.Add(new Return(exprResult.Result.Position) { Value = exprResult.Result })
;                 res = Accept(TokenType.EOL)
;                 if res.Failure
;                     ret InvalidTokenErrorStatement("Invalid token in get", res)
;             else
;                 ; get
;                 ;     [statements]

;                 res = Accept(TokenType.Get, TokenType.EOL, TokenType.Indent)
;                 if res.Failure
;                     ret InvalidTokenErrorStatement("Invalid token in get", res)

;                 for Peek.Type != TokenType.Dedent
;                     var stmt = ParseMethodStatement()
;                     if stmt.Error
;                         ret stmt
;                     propDef.GetStatements.Add(stmt.Result)

;                 res = Accept(TokenType.Dedent)
;                 if res.Failure
;                     ret InvalidTokenErrorStatement("Invalid token in get", res)
;         else
;             res = Accept(TokenType.Set, TokenType.LeftParenthesis, TokenType.Identifier, TokenType.RightParenthesis)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in set", res)
;             propDef.SetParameterName = GetToken(res, 2).Value

;             if Accept(TokenType.Is).Success
;                 ; set(v) is [statement]

;                 var stmtResult = ParseMethodStatement()
;                 if stmtResult.Error
;                     ret stmtResult
;                 propDef.SetStatements.Add(stmtResult.Result)
;             else
;                 ; set(v)
;                 ;     [statements]

;                 res = Accept(TokenType.EOL, TokenType.Indent)
;                 if res.Failure
;                     ret InvalidTokenErrorStatement("Invalid token in set", res)

;                 for Peek.Type != TokenType.Dedent
;                     var stmt = ParseMethodStatement()
;                     if stmt.Error
;                         ret stmt
;                     propDef.SetStatements.Add(stmt.Result)

;                 res = Accept(TokenType.Dedent)
;                 if res.Failure
;                     ret InvalidTokenErrorStatement("Invalid token in set", res)

;         ret null

;     private fn ParseIf(inElseIf bool = false) ParseResult{Statement}
;         ; accept if
;         var start = Next()
;         ; if [name] = [expr], [expr]
;         var res = Accept(TokenType.Identifier, TokenType.Assign)
;         var name ?str = null
;         var assignmentExpr ?ParseResult{Expression} = null
;         if res.Success
;             name = GetToken(res).Value
;             assignmentExpr = ParseExpression()
;             if assignmentExpr.Error and assignmentExpr.Result is ErrorExpression exp
;                 ret ErrorStatement(exp)
;             res = Accept(TokenType.Comma)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in if", res)

;         var condition = ParseExpression()
;         if condition.Error and condition.Result is ErrorExpression ex
;             ret ErrorStatement(ex)

;         res = Accept(TokenType.EOL, TokenType.Indent)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in if", res)

;         ; if [expr]
;         ;     is [expr]
;         ;         [statements]
;         ;     is [expr]
;         ;     is [expr]
;         ;         [statements]
;         if Peek.Type == TokenType.Is and !inElseIf
;             var switchStmt = new Switch(start.Position, condition.Result) { LocalName = name, LocalExpr = assignmentExpr?.Result }
;             var isRes = Accept(TokenType.Is)
;             for isRes.Success
;                 var exprRes = ParseExpression()
;                 if exprRes.Error and exprRes.Result is ErrorExpression exp
;                     ret ErrorStatement(exp)

;                 res = Accept(TokenType.EOL)
;                 if res.Failure
;                     ret InvalidTokenErrorStatement("Invalid token in if", res)

;                 var caseStmt = new Case(GetToken(isRes).Position, exprRes.Result)
;                 switchStmt.Statements.Add(caseStmt)

;                 if Accept(TokenType.Indent).Success
;                     for Peek.Type != TokenType.Dedent
;                         var stmtRes = ParseMethodStatement()
;                         if stmtRes.Error
;                             ret stmtRes
;                         caseStmt.Statements.Add(stmtRes.Result)

;                     res = Accept(TokenType.Dedent)
;                     if res.Failure
;                         ret InvalidTokenErrorStatement("Invalid token in if", res)

;                 isRes = Accept(TokenType.Is)

;             res = Accept(TokenType.Dedent)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in if", res)

;             ret new ParseResult{Statement}(switchStmt)

;         var ifStatement = new If(start.Position, condition.Result) { LocalName = name, LocalExpr = assignmentExpr?.Result }

;         for Peek.Type != TokenType.Dedent
;             var statement = ParseMethodStatement()
;             if statement.Error
;                 ret statement
;             ifStatement.Statements.Add(statement.Result)

;         res = Accept(TokenType.Dedent, TokenType.Else)
;         if res.Success
;             if Peek.Type == TokenType.If
;                 var elseIf = ParseIf(true)
;                 if elseIf.Error
;                     ret elseIf
;                 ifStatement.ElseStatements.Add(elseIf.Result)
;             else
;                 res = Accept(TokenType.EOL, TokenType.Indent)
;                 if res.Failure
;                     ret InvalidTokenErrorStatement("Invalid token in if", res)

;                 for Peek.Type != TokenType.Dedent
;                     var statement = ParseMethodStatement()
;                     if statement.Error
;                         ret statement
;                     ifStatement.ElseStatements.Add(statement.Result)

;         if !inElseIf
;             res = Accept(TokenType.Dedent)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in if", res)

;         ret new ParseResult{Statement}(ifStatement)

;     private fn ParseImplicitConstructorCall(start Token) ParseResult{Expression}
;         ; new([args])
;         ; new{[type args]}([args])
;         ; new([args]){[initializers]}
;         ; new{[type args]}([args]){[initializers]}

;         var res AcceptResult
;         var ctorDef = new ImplicitConstructorCall(start.Position)

;         ParseArguments(ctorDef.Arguments)

;         if Accept(TokenType.LeftCurly).Success
;             for Peek.Type != TokenType.RightCurly
;                 res = Accept(TokenType.Identifier, TokenType.Assign)
;                 if res.Failure
;                     ret InvalidTokenErrorExpression("Invalid token in implicit constructor", res)

;                 var prop = GetToken(res).Value

;                 var right = ParseExpression()
;                 if right.Error
;                     ret right

;                 ctorDef.InitNames.Add(prop)
;                 ctorDef.InitValues.Add(right.Result)

;                 Accept(TokenType.Comma)

;             res = Accept(TokenType.RightCurly)
;             if res.Failure
;                 ret InvalidTokenErrorExpression("Invalid token in implicit constructor", res)

;         ret new ParseResult{Expression}(ctorDef)

;         for Accept(TokenType.Comma).Success
;             argExpr = ParseExpression()
;             if argExpr.Error
;                 ret argExpr
;             indexer.Arguments.Add(argExpr.Result)

;         if res = Accept(TokenType.RightBracket), res.Failure
;             ret InvalidTokenErrorExpression("Invalid token in indexer", res)

;         ret new ParseResult{Expression}(indexer)

;     private fn ParseInterface(modifiers List{Modifier}) ParseResult{Statement}
;         var res = Accept(TokenType.Interface, TokenType.Identifier)

;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in interface", res)

;         var intf = new Interface(GetToken(res, 1).Position, modifiers, GetToken(res, 1).Value)

;         ParseGenericNames(intf.GenericNames)

;         if Accept(TokenType.Has).Success
;             var interfaceType = ParseType()
;             if !interfaceType.Error
;                 intf.Interfaces.Add(interfaceType.Result)

;             for Accept(TokenType.Comma).Success
;                 interfaceType = ParseType()
;                 if !interfaceType.Error
;                     intf.Interfaces.Add(interfaceType.Result)

;         res = Accept(TokenType.EOL, TokenType.Indent)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in interface", res)

;         for Peek.Type != TokenType.Dedent
;             var ist = ParseInterfaceStatement()
;             if ist.Error
;                 ret ist
;             intf.Statements.Add(ist.Result)

;         res = Accept(TokenType.Dedent)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in interface", res)

;         ret new ParseResult{Statement}(intf)

;     private fn ParseInterfaceStatement() ParseResult{Statement}
;         var startToken = Peek
;         var size = 0
;         for Peek.Type == TokenType.EOL
;             Next()
;             size += 1

;         if size > 0
;             ret new ParseResult{Statement}(new Space(startToken.Position, size))

;         if Peek.Type == TokenType.Comment
;             ret ParseComment()

;         var modifiers = new List{Modifier}()
;         var modRes = ParseModifiers(modifiers)
;         if modRes != null
;             ret modRes

;         var res = Accept(TokenType.Function, TokenType.Identifier)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in interface", res)

;         var fnPos = GetToken(res).Position
;         var name = GetToken(res, 1).Value

;         if Peek.Type == TokenType.LeftParenthesis or Peek.Type == TokenType.LeftCurly
;             ret ParseMethodSignature(modifiers, fnPos, name)

;         ret ParsePropertySignature(modifiers, fnPos, name)

;     private fn ParseMethodSignature(modifiers List{Modifier}, pos Position, name str) ParseResult{Statement}
;         ; [modifiers] fn [name]([params])
;         ; [modifiers] fn [name]([params]) [type]

;         var methodSig = new MethodSignature(pos, modifiers, name)

;         ParseGenericNames(methodSig.GenericNames)
;         ParseParameters(methodSig.Parameters)

;         ; return type
;         if Peek.Type != TokenType.EOL
;             var typeResult = ParseType()
;             if typeResult.Error and typeResult.Result is ErrorExpression ex
;                 ret ErrorStatement(ex)
;             methodSig.ReturnType = typeResult.Result

;         var res = Accept(TokenType.EOL)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in method signature", res)

;         ret new ParseResult{Statement}(methodSig)

;     ; Returns null on success, or the error statement.
;     private fn ParseModifiers(modifiers List{Modifier}) ?ParseResult{Statement}
;         for Peek.Type.IsModifier()
;             var mod = new Modifier(Peek.Position, Peek.Type.ToModifier())
;             modifiers.Add(mod)
;             Next()
;             if Accept(TokenType.LeftCurly).Success
;                 var typeRes = ParseType()
;                 if typeRes.Error and typeRes.Result is ErrorExpression ex
;                     ret ErrorStatement(ex)

;                 mod.Argument = typeRes.Result

;                 var res = Accept(TokenType.RightCurly)
;                 if res.Failure
;                     ret InvalidTokenErrorStatement("Invalid token in modifier", res)

;         ret null

;     private fn ParseNestedPrimaryExpression() ParseResult{Expression}
;         var leftResult ParseResult{Expression}
;         if Peek.Type == TokenType.Identifier
;             leftResult = ParseIdentifier()
;         else if Peek.Type == TokenType.LeftParenthesis
;             leftResult = ParseMethodCall(null)
;         else if Peek.Type == TokenType.LeftBracket
;             leftResult = ParseIndexer(null)
;         else if Peek.Type == TokenType.LeftCurly
;             leftResult = ParseGeneric(null)
;         else
;             var token = Next()
;             ret ErrorExpression("Invalid token in nested expression: " + token, token.Position)
        
;         if leftResult.Error
;             ret leftResult

;         var loop bool
;         for
;             loop = true
;             var res = Accept(TokenType.Dot, TokenType.Identifier)
;             if res.Success
;                 leftResult = new ParseResult{Expression}(new BinaryOperator(
;                     leftResult.Result.Position,
;                     leftResult.Result,
;                     BinaryOperatorType.Dot,
;                     new Identifier(GetToken(res, 1).Position, GetToken(res, 1).Value)
;                 ))
;             else
;                 res = Accept(TokenType.NullDot, TokenType.Identifier)
;                 if res.Success
;                     leftResult = new ParseResult{Expression}(new BinaryOperator(
;                         leftResult.Result.Position,
;                         leftResult.Result,
;                         BinaryOperatorType.NullDot,
;                         new Identifier(GetToken(res, 1).Position, GetToken(res, 1).Value)
;                     ))
;                 else if Peek.Type == TokenType.LeftParenthesis
;                     leftResult = ParseMethodCall(leftResult.Result)
;                 else if Peek.Type == TokenType.LeftBracket
;                     leftResult = ParseIndexer(leftResult.Result)
;                 else if Peek.Type == TokenType.LeftCurly
;                     leftResult = ParseGeneric(leftResult.Result)
;                 else if Peek.Type == TokenType.Question
;                     leftResult = ParseConditional(leftResult.Result)
;                 else
;                     loop = false
            
;             if !loop
;                 break

;         ret leftResult

;     private fn ParseNullable() ParseResult{Expression}
;         var start = Peek
;         var res = Accept(TokenType.Question)
;         if res.Failure
;             ret InvalidTokenErrorExpression("Invalid token in nullable type declaration", res)

;         var typeResult = ParseType()
;         if typeResult.Error
;             ret typeResult

;         ret new ParseResult{Expression}(new Core.Ast.Nullable(start.Position, typeResult.Result))

;     private fn ParseProperty(modifiers List{Modifier}, nameToken Token) ParseResult{Statement}
;         ; property
;         ; [modifiers] fn [name] [type] [= [expr]]
;         ; [modifiers] fn [name] [type] [get and/or set] [= [expr]]
;         ; [modifiers] fn [name] [type] is [expr]
;         ; [modifiers] fn [name] [type]
;         ;     [statements]
;         ; [modifiers] fn [name] [type] [= [expr]]
;         ;     get is [expr]
;         ;     set is [statement]
;         ; [modifiers] fn [name] [type] [= [expr]]
;         ;     get
;         ;         [statements]
;         ;     set(v)
;         ;         [statements]

;         var res AcceptResult

;         var typeResult = ParseType()
;         if typeResult.Error and typeResult.Result is ErrorExpression ex
;             ret ErrorStatement(ex)

;         var propDef = new Property(nameToken.Position, modifiers, nameToken.Value, typeResult.Result)

;         ; [modifiers] fn [name] [type] [get and/or set]
;         if Peek.Type == TokenType.Get or Peek.Type == TokenType.Set
;             var getSet = Next()
;             var other = TokenType.Set
;             if getSet.Type == TokenType.Get
;                 propDef.SetSpecified = false
;             else
;                 propDef.GetSpecified = false
;                 other = TokenType.Get

;             res = Accept(TokenType.Comma, other)
;             if res.Success
;                 if GetToken(res, 1).Type == TokenType.Get
;                     propDef.GetSpecified = true
;                 else
;                     propDef.SetSpecified = true
;         else if Accept(TokenType.Is).Success
;             ; [is [expr]]

;             var exprResult = ParseExpression()
;             if exprResult.Error and exprResult.Result is ErrorExpression exp
;                 ret ErrorStatement(exp)
;             propDef.GetStatements.Add(new Return(exprResult.Result.Position) { Value = exprResult.Result })
;             res = Accept(TokenType.EOL)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in property", res)
;             ret new ParseResult{Statement}(propDef)

;         ; [= [expr]]
;         if Accept(TokenType.Assign).Success
;             var exprResult = ParseExpression()
;             if exprResult.Error and exprResult.Result is ErrorExpression exp
;                 ret ErrorStatement(exp)
;             propDef.Value = exprResult.Result

;         res = Accept(TokenType.EOL)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in property", res)

;         if Accept(TokenType.Indent).Success
;             if Peek.Type == TokenType.Get or Peek.Type == TokenType.Set
;                 ; [modifiers] fn [name] [type]
;                 ;     get is [expr]
;                 ;     set(v) is [statement]
;                 ; [modifiers] fn [name] [type]
;                 ;     get
;                 ;         [statements]
;                 ;     set(v)
;                 ;         [statements]

;                 var other = Peek.Type == TokenType.Get ? TokenType.Set : TokenType.Get

;                 var getSetResult = ParseGetSet(propDef)
;                 if getSetResult != null
;                     ret getSetResult

;                 if Peek.Type == other
;                     getSetResult = ParseGetSet(propDef)
;                     if getSetResult != null
;                         ret getSetResult
;             else
;                 ; [modifiers] fn [name] [type]
;                 ;     [statements]

;                 for Peek.Type != TokenType.Dedent
;                     var stmt = ParseMethodStatement()
;                     if stmt.Error
;                         ret stmt
;                     propDef.GetStatements.Add(stmt.Result)

;             res = Accept(TokenType.Dedent)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in property", res)

;         ret new ParseResult{Statement}(propDef)

;     private fn ParsePropertySignature(modifiers List{Modifier}, pos Position, name str) ParseResult{Statement}
;         ; [modifiers] fn [name] [type]
;         ; [modifiers] fn [name] [type] [get and/or set]

;         var res AcceptResult

;         var typeResult = ParseType()
;         if typeResult.Error and typeResult.Result is ErrorExpression ex
;             ret ErrorStatement(ex)

;         var propSig = new PropertySignature(pos, modifiers, name, typeResult.Result)

;         if Peek.Type == TokenType.Get or Peek.Type == TokenType.Set
;             var getSet = Next()
;             var other = TokenType.Set
;             if getSet.Type == TokenType.Get
;                 propSig.SetSpecified = false
;             else
;                 propSig.GetSpecified = false
;                 other = TokenType.Get

;             res = Accept(TokenType.Comma, other)
;             if res.Success
;                 if GetToken(res, 1).Type == TokenType.Get
;                     propSig.GetSpecified = true
;                 else
;                     propSig.SetSpecified = true

;         res = Accept(TokenType.EOL)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in property signature", res)

;         ret new ParseResult{Statement}(propSig)

;     private fn ParseSpace() ParseResult{Statement}
;         var position = Peek.Position
;         var size = 0
;         for Peek.Type == TokenType.EOL
;             Next()
;             size += 1

;         ret new ParseResult{Statement}(new Space(position, size))

;     private fn ParseStruct(modifiers List{Modifier}) ParseResult{Statement}
;         var res = Accept(TokenType.Struct, TokenType.Identifier)

;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in struct", res)

;         var structRes = new Struct(GetToken(res, 1).Position, modifiers, GetToken(res, 1).Value)

;         ParseGenericNames(structRes.GenericNames)

;         if Accept(TokenType.Has).Success
;             var interfaceType = ParseType()
;             if !interfaceType.Error
;                 structRes.Interfaces.Add(interfaceType.Result)

;             for Accept(TokenType.Comma).Success
;                 interfaceType = ParseType()
;                 if !interfaceType.Error
;                     structRes.Interfaces.Add(interfaceType.Result)

;         res = Accept(TokenType.EOL, TokenType.Indent)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in struct", res)

;         for Peek.Type != TokenType.Dedent
;             var stmt = ParseClassStatement()
;             if stmt.Error
;                 ret stmt
;             structRes.Statements.Add(stmt.Result)

;         res = Accept(TokenType.Dedent)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in struct {structRes.Name}", res)

;         ret new ParseResult{Statement}(structRes)

;     private fn ParseTry() ParseResult{Statement}
;         ; try
;         ;     [statements]
;         ; catch
;         ; catch [type]
;         ; catch [type] [name]
;         ;     [statements]
;         ; fin
;         ;     [statements]

;         var res = Accept(TokenType.Try, TokenType.EOL, TokenType.Indent)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in try", res)

;         var tryDef = new Try(GetToken(res).Position)

;         for Peek.Type != TokenType.Dedent
;             var stmt = ParseMethodStatement()
;             if stmt.Error
;                 ret stmt
;             tryDef.Statements.Add(stmt.Result)

;         res = Accept(TokenType.Dedent)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in try", res)

;         var catchRes = Accept(TokenType.Catch)
;         for catchRes.Success
;             var catchStmt = new Catch(GetToken(catchRes).Position)
;             tryDef.Catches.Add(catchStmt)

;             if Peek.Type != TokenType.EOL
;                 var typeRes = ParseType()
;                 if typeRes.Error and typeRes.Result is ErrorExpression ex
;                     ret ErrorStatement(ex)

;                 catchStmt.Type = typeRes.Result
;                 res = Accept(TokenType.Identifier)
;                 if res.Success
;                     catchStmt.Name = GetToken(res).Value

;             res = Accept(TokenType.EOL, TokenType.Indent)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in catch", res)

;             for Peek.Type != TokenType.Dedent
;                 var stmt = ParseMethodStatement()
;                 if stmt.Error
;                     ret stmt
;                 catchStmt.Statements.Add(stmt.Result)

;             res = Accept(TokenType.Dedent)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in catch", res)

;             catchRes = Accept(TokenType.Catch)

;         if Accept(TokenType.Finally, TokenType.EOL, TokenType.Indent).Success
;             for Peek.Type != TokenType.Dedent
;                 var stmt = ParseMethodStatement()
;                 if stmt.Error
;                     ret stmt
;                 tryDef.FinallyStatements.Add(stmt.Result)

;             res = Accept(TokenType.Dedent)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in finally", res)

;         ret new ParseResult{Statement}(tryDef)

;     private fn ParseUsing() ParseResult{Statement}
;         ; use [name] = [expr]
;         ; use [name] = [expr]
;         ;     [statements]

;         var res = Accept(TokenType.Use, TokenType.Identifier, TokenType.Assign)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in use", res)

;         var pos = GetToken(res).Position
;         var name = GetToken(res, 1).Value

;         var exprRes = ParseExpression()
;         if exprRes.Error and exprRes.Result is ErrorExpression ex
;             ret ErrorStatement(ex)

;         res = Accept(TokenType.EOL)
;         if res.Failure
;             ret InvalidTokenErrorStatement("Invalid token in use", res)

;         var useRes = new Using(pos, name, exprRes.Result)

;         if Accept(TokenType.Indent).Success
;             for Peek.Type != TokenType.Dedent
;                 var stmtRes = ParseMethodStatement()
;                 if stmtRes.Error
;                     ret stmtRes
;                 useRes.Statements.Add(stmtRes.Result)

;             res = Accept(TokenType.Dedent)
;             if res.Failure
;                 ret InvalidTokenErrorStatement("Invalid token in use", res)

;         ret new ParseResult{Statement}(useRes)
