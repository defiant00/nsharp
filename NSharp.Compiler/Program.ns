use System.Diagnostics
use NSharp.Core
use NSharp.Language.Min

ns NSharp.Compiler

public static class Program
    private val SAVE_EXT str = ".ns"
    private val EDIT_EXT str = ".edit"
    private val SAVE_SETTINGS str = ".nssave"
    private val EDIT_SETTINGS str = ".nsedit"
    private val LANGUAGE_KEY str = "language"

    public static fn Main(args []str)
        Console.WriteLine("N# Compiler v0.1.1")

        var stopwatch = new Stopwatch()
        stopwatch.Start()

        var arguments = new Arguments(args)

        try
            if args.Length < 2 or arguments.Flags.ContainsKey("help")
                Console.WriteLine()
                Console.WriteLine("Usage: nsc [command] [file(s)]")
                Console.WriteLine()
                Console.WriteLine("Commands:")
                Console.WriteLine("    /build [project paths] - build projects")
                Console.WriteLine("    /compile [files]       - compile the specified files")
                Console.WriteLine("    /edit [files]          - create a file.ns.edit file per input file for editing per the .nsedit settings")
                Console.WriteLine("    /format [files]        - format the specified files per the .nsedit and .nssave settings")
                Console.WriteLine("    /save [files]          - save the specified files per the .nssave settings")
                Console.WriteLine("    /validate [files]      - validate the specified files' syntax")
            else if arguments.Flags.ContainsKey("build")
                Console.WriteLine("Build not yet supported.")
            else if arguments.Flags.ContainsKey("compile")
                Compile(arguments)
            else if arguments.Flags.ContainsKey("edit")
                Edit(arguments)
            else if arguments.Flags.ContainsKey("format")
                Format(arguments)
            else if arguments.Flags.ContainsKey("save")
                Save(arguments)
            else if arguments.Flags.ContainsKey("validate")
                Validate(arguments)
            else
                Console.WriteLine("No command found.")
        catch Exception ex
            SetConsoleColor(Severity.Fatal)
            Console.WriteLine(ex)

        ResetConsoleColor()
        Console.WriteLine("Elapsed: {stopwatch.Elapsed}")
    
    private static fn Compile(args Arguments)
        if args.Flags.ContainsKey("tocs")
            ; Transpile to C#
            for path in args.Paths
                for file in Directory.EnumerateFiles(path, "*{SAVE_EXT}", SearchOption.AllDirectories)
                    if !File.Exists(file)
                        throw new Exception("File '{file}' does not exist.")
                    if !file.EndsWith(SAVE_EXT, StringComparison.OrdinalIgnoreCase)
                        throw new Exception("File '{file}' does not end with {SAVE_EXT}")

                    var loadLang = GetLanguage(args, SAVE_SETTINGS, file)

                    var loadResult = loadLang.Load(file)
                    HandleResult(loadResult)
                    if loadResult.Ast != null
                        use visitor = new ToCsVisitor("{file}.cs")
                        loadResult.Ast.Accept(visitor)

        else
            var outFile = args.Flags.ContainsKey("out") ? args.Flags["out"],
                throw new Exception("/out must be specified to compile.")
            
            var files = new List{str}()
            for path in args.Paths
                if Directory.Exists(path)
                    files.AddRange(Directory.EnumerateFiles(path, "*{SAVE_EXT}", SearchOption.AllDirectories))
                else if File.Exists(path)
                    files.Add(path)

            var compiler = new Compiler()
            for file in files
                var language ILanguage

                if file.EndsWith(SAVE_EXT, StringComparison.OrdinalIgnoreCase)
                    language = GetLanguage(args, SAVE_SETTINGS, file)
                else if file.EndsWith("{SAVE_EXT}{EDIT_EXT}", StringComparison.OrdinalIgnoreCase)
                    language = GetLanguage(args, EDIT_SETTINGS, file)
                else
                    throw new Exception("File '{file}' does not end with {SAVE_EXT} or {SAVE_EXT}{EDIT_EXT}")

                var loadResult LoadResult = language.Load(file)
                HandleResult(loadResult)
                if loadResult.Ast != null
                    compiler.Add(loadResult.Ast)

            HandleCompileResult(compiler.Compile())
            compiler.Save(outFile)

    private static fn Edit(args Arguments)
        for file in args.Paths
            if !File.Exists(file)
                throw new Exception("File '{file}' does not exist.")
            if !file.EndsWith(SAVE_EXT, StringComparison.OrdinalIgnoreCase)
                throw new Exception("File '{file}' does not end with {SAVE_EXT}")

            var loadLang = GetLanguage(args, SAVE_SETTINGS, file)
            var saveLang = GetLanguage(args, EDIT_SETTINGS, file)

            var loadResult = loadLang.Load(file)
            HandleResult(loadResult)
            if loadResult.Ast != null
                HandleResult(saveLang.Save("{file}{EDIT_EXT}", loadResult.Ast))

    private static fn Format(args Arguments)
        for file in args.Paths
            if !File.Exists(file)
                throw new Exception("File '{file}' does not exist.")

            var language ILanguage

            if file.EndsWith(SAVE_EXT, StringComparison.OrdinalIgnoreCase)
                language = GetLanguage(args, SAVE_SETTINGS, file)
            else if file.EndsWith("{SAVE_EXT}{EDIT_EXT}", StringComparison.OrdinalIgnoreCase)
                language = GetLanguage(args, EDIT_SETTINGS, file)
            else
                throw new Exception("File '{file}' does not end with {SAVE_EXT} or {SAVE_EXT}{EDIT_EXT}")

            var loadResult = language.Load(file)
            HandleResult(loadResult)
            if loadResult.Ast != null
                HandleResult(language.Save(file, loadResult.Ast))

    private static fn Save(args Arguments)
        for file in args.Paths
            if !File.Exists(file)
                throw new Exception("File '{file}' does not exist.")
            if !file.EndsWith("{SAVE_EXT}{EDIT_EXT}", StringComparison.OrdinalIgnoreCase)
                throw new Exception("File '{file}' does not end with {SAVE_EXT}{EDIT_EXT}")

            var loadLang = GetLanguage(args, EDIT_SETTINGS, file)
            var saveLang = GetLanguage(args, SAVE_SETTINGS, file)

            var loadResult = loadLang.Load(file)
            HandleResult(loadResult)
            if loadResult.Ast != null
                HandleResult(saveLang.Save(file.Substring(0, file.Length - EDIT_EXT.Length), loadResult.Ast))

    private static fn Validate(args Arguments)
        for file in args.Paths
            if !File.Exists(file)
                throw new Exception("File '{file}' does not exist.")

            var language ILanguage

            if file.EndsWith(SAVE_EXT, StringComparison.OrdinalIgnoreCase)
                language = GetLanguage(args, SAVE_SETTINGS, file)
            else if file.EndsWith("{SAVE_EXT}{EDIT_EXT}", StringComparison.OrdinalIgnoreCase)
                language = GetLanguage(args, EDIT_SETTINGS, file)
            else
                throw new Exception("File '{file}' does not end with {SAVE_EXT} or {SAVE_EXT}{EDIT_EXT}")

            var loadResult = language.Load(file)
            HandleResult(loadResult)

    private static fn HandleResult(result Result)
        if result.Diagnostics.Any()
            ResetConsoleColor()
            Console.WriteLine(result.FileName)
            for diagnostic in result.Diagnostics
                SetConsoleColor(diagnostic.Severity)
                Console.WriteLine("  [{diagnostic.Severity}] {diagnostic.Code}: {diagnostic.Message} ({diagnostic.Position})")

    private static fn ResetConsoleColor() is Console.ForegroundColor = ConsoleColor.White

    private static fn SetConsoleColor(severity Severity)
        Console.ForegroundColor = severity ? {
            Severity.Message is ConsoleColor.Cyan,
            Severity.Warning is ConsoleColor.Yellow,
            Severity.Error is ConsoleColor.Red,
            Severity.Fatal is ConsoleColor.Red,
            _ is ConsoleColor.White,
        }

    private static fn HandleCompileResult(diagnostics List{Diagnostic})
        for diagnostic in diagnostics
            SetConsoleColor(diagnostic.Severity)
            Console.WriteLine("[{diagnostic.Severity}] {diagnostic.Code}: {diagnostic.Message} ({diagnostic.Position})")
        if diagnostics.All(fn(d) is d.Severity < Severity.Error)
            ResetConsoleColor()
            Console.WriteLine("Compile successful")

    private static fn GetLanguage(args Arguments, configFileName str, startingPath str) ILanguage
        var config ?Dictionary{str, str} = null

        var dirName ?str = Path.GetDirectoryName(startingPath)
        if dirName != null
            var dir ?DirectoryInfo = new(dirName)
            for config == null and dir != null
                var configPath str = Path.Combine(dir.FullName, configFileName)
                if File.Exists(configPath)
                    config = Configuration.Load(configPath)
                dir = dir.Parent

        if config == null
            SetConsoleColor(Severity.Warning)
            Console.WriteLine("'{configFileName}' not found, using default configuration.")
            config = new()

        var lang ?ILanguage = null
        if config.ContainsKey(LANGUAGE_KEY)
            if config[LANGUAGE_KEY]
                is "Min"
                    lang = new Min(args.Flags, config)
        
        if lang == null
            lang = new Min(args.Flags, config)

        ret lang
