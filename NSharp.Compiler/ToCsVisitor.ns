use NSharp.Core
use NSharp.Core.SyntaxTree

ns NSharp.Compiler

public class ToCsVisitor has ISyntaxTreeVisitor, IDisposable
    private fn Buffer StreamWriter
    private fn Indent int = 0
    private fn Attributes Stack{Expression} = new()
    
    private fn Write(line str) is Buffer.Write(line)
    private fn WriteLine() is Buffer.WriteLine()
    private fn WriteLine(line str) is Buffer.WriteLine(line)

    private fn WriteIndent()
        for i = 0, i < Indent, i += 1
            Write("    ")

    private fn WriteIndented(line str)
        WriteIndent()
        Write(line)

    private fn WriteLineIndented(line str)
        WriteIndent()
        WriteLine(line)

    ; private fn CurrentObject str = str.Empty
    ; private fn BinopParentPrecedence Stack{int} = new()
    ; private fn InFor bool
    ; private fn InExtension bool
    ; private fn ExprStmtVarStack Stack{str} = new()

    private fn WriteAttributes()
        for a in Attributes
            a.Accept(this)
            Write(" ")
    ; private fn WriteModifiersIndented(modifiers List{Modifier}, canBeSealed bool = false, canOverride bool = false)
    ;     WriteIndented(str.Join(" ", modifiers.Select(fn(m) is m.Type ?
    ;     {
    ;         ModifierType.Abstract is "abstract",
    ;         ModifierType.Extension is "",
    ;         ModifierType.Internal is "internal",
    ;         ModifierType.Open is "",
    ;         ModifierType.Override is "override",
    ;         ModifierType.Private is "private",
    ;         ModifierType.Protected is "protected",
    ;         ModifierType.Public is "public",
    ;         ModifierType.Static is "static",
    ;         _ is " [modifier] ",
    ;     })))
    ;     if modifiers.Any(fn(m) is m.Type == ModifierType.Open)
    ;         if canOverride
    ;                 and !modifiers.Any(fn(m) is m.Type == ModifierType.Override)
    ;                 and !modifiers.Any(fn(m) is m.Type == ModifierType.Static)
    ;             Write(" virtual")
    ;     else if canBeSealed
    ;             and !modifiers.Any(fn(m) is m.Type == ModifierType.Abstract)
    ;             and !modifiers.Any(fn(m) is m.Type == ModifierType.Static)
    ;         Write(" sealed")
    ;     else if canOverride
    ;             and modifiers.Any(fn(m) is m.Type == ModifierType.Override)
    ;             and !modifiers.Any(fn(m) is m.Type == ModifierType.Open)
    ;         Write(" sealed")

    private fn WriteStatementBlock(statements List{Statement})
        WriteLineIndented("{{")
        Indent += 1
        for stmt in statements
            stmt.Accept(this)
        Indent -= 1
        WriteLineIndented("}}")
    
    ; private fn IsNestedHandled(expr Expression) bool is (expr is Generic g and g.Expr == null)
    ;     or (expr is Indexer i and i.Expr == null)
    ;     or (expr is MethodCall m and m.Expr == null)
    ;     or (expr is BinaryOperator b and IsNestedHandled(b.Left))
    
    ; private fn AddNestedVarStack(expr Expression)
    ;     if ExprStmtVarStack.Any() and !IsNestedHandled(expr)
    ;         Write("{ExprStmtVarStack.Peek()}.")
    
    private fn JoinItems(items IEnumerable{Node}, separator str = ", ")
        var first = true
        for item in items
            if first
                first = false
            else
                Write(separator)
            item.Accept(this)
    
    ; private fn Escape(value str) str is new StringBuilder(value)
    ;     .Replace("{{", "{{{{")
    ;     .Replace("}}", "}}}}")
    ;     .Replace("\\", "\\\\")
    ;     .Replace("\"", "\\\"")
    ;     .Replace("\n", "\\n")
    ;     .Replace("\r", "\\r")
    ;     .Replace("\t", "\\t")
    ;     .ToString()

    public fn new(fileName str) is Buffer = new StreamWriter(fileName)

    public fn Dispose() is Buffer?.Dispose()

    public fn Visit(item AnonymousFunction) is throw new NotImplementedException()
    ; public fn Visit(item AnonymousFunction)
    ;     Write("(")
    ;     JoinItems(item.Parameters)
    ;     Write(") => ")
    ;     Indent += 1
    ;     if item.Statements.Count == 1 and item.Statements[0] is ExpressionStatement es
    ;         es.Expr.Accept(this)
    ;     else
    ;         WriteLine()
    ;         WriteStatementBlock(item.Statements)
    ;     Indent -= 1

    public fn Visit(item Argument) is throw new NotImplementedException()
    ; public fn Visit(item Argument)
    ;     if item.Name != null
    ;         Write("{item.Name}: ")

    ;     var mods = str.Join(" ", item.Modifiers.Select(fn(m) is m ?
    ;     {
    ;         ArgumentModifierType.Out is "out",
    ;         ArgumentModifierType.Reference is "ref",
    ;         _ is "[{m}]"
    ;     }))
    ;     Write("{mods} ")

    ;     item.Value.Accept(this)

    public fn Visit(item ArgumentModifierToken) is throw new NotImplementedException()

    public fn Visit(item Core.SyntaxTree.Arguments) is throw new NotImplementedException()
    ; public fn Visit(item MethodCall)
    ;     if item.Expr == null and ExprStmtVarStack.Any()
    ;         Write(ExprStmtVarStack.Peek())
    ;     else
    ;         item.Expr?.Accept(this)
    ;     Write("(")
    ;     JoinItems(item.Arguments)
    ;     Write(")")

    public fn Visit(item ArrayLiteral) is throw new NotImplementedException()
    ; public fn Visit(item ArrayLiteral)
    ;     Write("{{")
    ;     JoinItems(item.Values)
    ;     Write("}}")

    public fn Visit(item ArrayType) is throw new NotImplementedException()
    ; public fn Visit(item Core.Ast.Array)
    ;     item.Type.Accept(this)
    ;     Write("[]")

    public fn Visit(item Assignment) is throw new NotImplementedException()
    ; public fn Visit(item Assignment)
    ;     if !InFor
    ;         WriteIndent()
    ;     AddNestedVarStack(item.Left)
    ;     item.Left.Accept(this)
    ;     Write(item.Operator ?
    ;     {
    ;         AssignmentOperatorType.Add is " += ",
    ;         AssignmentOperatorType.Assign is " = ",
    ;         AssignmentOperatorType.BitwiseAnd is " &= ",
    ;         AssignmentOperatorType.BitwiseOr is " |= ",
    ;         AssignmentOperatorType.BitwiseXor is " ^= ",
    ;         AssignmentOperatorType.Divide is " /= ",
    ;         AssignmentOperatorType.LeftShift is " <<= ",
    ;         AssignmentOperatorType.Modulus is " %= ",
    ;         AssignmentOperatorType.Multiply is " *= ",
    ;         AssignmentOperatorType.NullCoalesce is " ??= ",
    ;         AssignmentOperatorType.RightShift is " >>= ",
    ;         AssignmentOperatorType.Subtract is " -= ",
    ;         _ is " [none] ",
    ;     })
    ;     item.Right.Accept(this)
    ;     if !InFor
    ;         WriteLine(";")

    public fn Visit(item AssignmentOperatorToken) is throw new NotImplementedException()

    public fn Visit(item Core.SyntaxTree.Attribute)
        if item.Qualifier != null
            Write("[")
            item.Qualifier.Accept(this)
            Write(":")
            item.Type.Accept(this)
            Write("]")
        else
            item.Type.Accept(this)

    public fn Visit(item AttributeBlock)
        for a in item.Attributes
            Attributes.Push(a)
        for s in item.Statements
            s.Accept(this)
        for i = 0, i < item.Attributes.Count, i += 1
            Attributes.Pop()

    public fn Visit(item BadExpressionToken) is Write("/* bad expression */")

    public fn Visit(item BadStatementToken) is WriteLineIndented("/* bad statement */")

    public fn Visit(item BaseClassToken) is throw new NotImplementedException()

    public fn Visit(item BinaryOperator)
        var parens = false
        if item.Parent is BinaryOperator parent
            parens = item.Operator.Value.Precedence() < parent.Operator.Value.Precedence() + (parent.LeftOperand == item ? 0 : 1)
        if parens
            Write("(")
        
        if item.Operator.Value == BinaryOperatorType.As
            Write("(")
            item.RightOperand.Accept(this)
            Write(")")

        item.LeftOperand.Accept(this)

        if item.Operator.Value != BinaryOperatorType.As
            item.Operator.Accept(this)
            item.RightOperand.Accept(this)

        if parens
            Write(")")

    public fn Visit(item BinaryOperatorToken)
        Write(item.Value ?
        {
            BinaryOperatorType.Add is " + ",
            BinaryOperatorType.And is " && ",
            BinaryOperatorType.As is " as ",
            BinaryOperatorType.BitwiseAnd is " & ",
            BinaryOperatorType.BitwiseOr is " | ",
            BinaryOperatorType.BitwiseXor is " ^ ",
            BinaryOperatorType.Divide is " / ",
            BinaryOperatorType.Dot is ".",
            BinaryOperatorType.Equal is " == ",
            BinaryOperatorType.GreaterThan is " > ",
            BinaryOperatorType.GreaterThanOrEqual is " >= ",
            BinaryOperatorType.Is is " is ",
            BinaryOperatorType.LeftShift is " << ",
            BinaryOperatorType.LessThan is " < ",
            BinaryOperatorType.LessThanOrEqual is " <= ",
            BinaryOperatorType.Modulus is " % ",
            BinaryOperatorType.Multiply is " * ",
            BinaryOperatorType.NotEqual is " != ",
            BinaryOperatorType.NullCoalesce is " ?? ",
            BinaryOperatorType.NullDot is "?.",
            BinaryOperatorType.Or is " || ",
            BinaryOperatorType.RightShift is " >> ",
            BinaryOperatorType.Subtract is " - ",
            _ is " [none] ",
        })

    public fn Visit(item Block) is throw new NotImplementedException()
    ; public fn Visit(item Block) is WriteStatementBlock(item.Statements)

    public fn Visit(item BreakToken) is WriteLineIndented("break;")

    public fn Visit(item Case) is throw new NotImplementedException()
    ; public fn Visit(item Case)
    ;     if item.Value is Discard
    ;         WriteLineIndented("default:")
    ;     else
    ;         WriteIndented("case ")
    ;         item.Value.Accept(this)
    ;         WriteLine(":")
    ;     if item.Statements.Any()
    ;         Indent += 1
    ;         WriteStatementBlock(item.Statements)
    ;         if !(item.Statements[item.Statements.Count - 1] is Return)
    ;             WriteLineIndented("break;")
    ;         Indent -= 1

    public fn Visit(item Catch) is throw new NotImplementedException()
    ; public fn Visit(item Catch)
    ;     WriteIndented("catch")
    ;     if item.Type != null
    ;         Write(" (")
    ;         item.Type.Accept(this)
    ;         if item.Name != null
    ;             Write(" {item.Name}")
    ;         Write(")")
    ;     WriteLine()
    ;     WriteStatementBlock(item.Statements)

    public fn Visit(item CharacterToken) is throw new NotImplementedException()
    ; public fn Visit(item Character) is Write("'{item.Value}'")

    public fn Visit(item Class)
        WriteAttributes()
        Write(" class ")
        item.Name.Accept(this)
        if item.Generics.Any()
            Write("<")
            JoinItems(item.Generics)
            Write(">")
        if item.Base != null
            Write(" : ")
            item.Base.Accept(this)
            for intf in item.Interfaces
                Write(", ")
                intf.Accept(this)
        else if item.Interfaces.Any()
            Write(" : ")
            JoinItems(item.Interfaces)
        WriteLine()
        WriteStatementBlock(item.Statements)

    public fn Visit(item CommentToken) is WriteLineIndented("//{item.IsDocumentation ? "/" : ""}{item.Value}")

    public fn Visit(item Condition) is throw new NotImplementedException()
    ; public fn Visit(item Condition)
    ;     WriteIndent()
    ;     item.Value.Accept(this)
    ;     Write(" => ")
    ;     item.Result.Accept(this)
    ;     WriteLine(",")

    public fn Visit(item Conditional) is throw new NotImplementedException()
    ; public fn Visit(item Conditional)
    ;     item.Value.Accept(this)
    ;     if item.Conditions.Count == 2 and
    ;             item.Conditions[0] is Condition c1 and
    ;             c1.Value is LiteralToken lt1 and
    ;             lt1.Token == LiteralType.True and
    ;             item.Conditions[1] is Condition c2 and
    ;             c2.Value is LiteralToken lt2 and
    ;             lt2.Token == LiteralType.False
    ;         ; Ternary
    ;         Write(" ? ")
    ;         c1.Result.Accept(this)
    ;         Write(" : ")
    ;         c2.Result.Accept(this)
    ;     else
    ;         WriteLine(" switch")
    ;         WriteLineIndented("{{")
    ;         Indent += 1
    ;         for condition in item.Conditions
    ;             condition.Accept(this)
    ;         Indent -= 1
    ;         WriteIndented("}}")

    public fn Visit(item Constant) is throw new NotImplementedException()
    ; public fn Visit(item Constant)
    ;     WriteModifiersIndented(item.Modifiers)
    ;     Write(" const ")
    ;     item.Type.Accept(this)
    ;     Write(" {item.Name}")
    ;     if item.Value != null
    ;         Write(" = ")
    ;         item.Value.Accept(this)
    ;     WriteLine(";")

    public fn Visit(item ConstructorCall) is throw new NotImplementedException()
    ; public fn Visit(item ConstructorCall)
    ;     Write("new ")
    ;     item.Expr.Accept(this)
    ;     Write("(")
    ;     JoinItems(item.Arguments)
    ;     Write(")")
    ;     if item.InitNames.Any()
    ;         Write("{{")
    ;         for i = 0, i < item.InitNames.Count, i += 1
    ;             if i > 0
    ;                 Write(", ")
    ;             Write("{item.InitNames[i]} = ")
    ;             item.InitValues[i].Accept(this)
    ;         Write("}}")

    public fn Visit(item ConstructorDefinition) is throw new NotImplementedException()
    ; public fn Visit(item ConstructorDefinition)
    ;     WriteModifiersIndented(item.Modifiers)
    ;     Write(" {CurrentObject}(")
    ;     JoinItems(item.Parameters)
    ;     Write(")")
    ;     if item.BaseArguments.Any()
    ;         Write(" : base(")
    ;         JoinItems(item.BaseArguments)
    ;         Write(")")
    ;     WriteLine()
    ;     WriteStatementBlock(item.Statements)

    public fn Visit(item ContinueToken) is WriteLineIndented("continue;")

    public fn Visit(item CurrentObjectInstanceToken) is throw new NotImplementedException()
    ; public fn Visit(item CurrentObjectInstance) is Write(InExtension ? "__this" : "this")

    public fn Visit(item DefaultValueToken) is throw new NotImplementedException()
    ; public fn Visit(item DefaultValue) is Write("default")

    public fn Visit(item Core.SyntaxTree.Delegate) is throw new NotImplementedException()
    ; public fn Visit(item DelegateDefinition)
    ;     WriteModifiersIndented(item.Modifiers)
    ;     Write(" delegate ")
    ;     if item.ReturnType == null
    ;         Write("void")
    ;     else
    ;         item.ReturnType.Accept(this)
    ;     Write(" {item.Name}")
    ;     if item.GenericNames.Any()
    ;         Write("<{str.Join(", ", item.GenericNames)}>")
    ;     Write("(")
    ;     JoinItems(item.Parameters)
    ;     WriteLine(");")

    public fn Visit(item DiscardToken) is throw new NotImplementedException()
    ; public fn Visit(item Discard) is Write("_")

    public fn Visit(item Enumeration)
        WriteAttributes()
        Write(" enum ")
        item.Name.Accept(this)
        WriteLine()
        WriteStatementBlock(item.Statements)

    public fn Visit(item EnumerationItem)
        WriteIndent()
        item.Name.Accept(this)
        if item.Value != null
            Write(" = ")
            item.Value.Accept(this)
        Write(",")
        if item.Comment != null
            item.Comment.Accept(this)
        else
            WriteLine()

    public fn Visit(item Expression) is throw new InvalidItemException()

    public fn Visit(item ExpressionStatement)
        WriteIndent()
        item.Value.Accept(this)
        WriteLine(";")

    public fn Visit(item Field) is throw new NotImplementedException()
    ; public fn Visit(item Field)
    ;     WriteModifiersIndented(item.Modifiers)
    ;     Write(" ")
    ;     item.Type.Accept(this)
    ;     Write(" {item.Name}")
    ;     if item.Value != null
    ;         Write(" = ")
    ;         item.Value.Accept(this)
    ;     WriteLine(";")

    public fn Visit(item Core.SyntaxTree.File)
        WriteLineIndented("// {DateTime.Now}")
        WriteLine()
        for statement in item.Statements
            statement.Accept(this)

    public fn Visit(item For) is throw new NotImplementedException()
    ; public fn Visit(item For)
    ;     if item.Init == null and item.Post == null
    ;         if item.Condition == null
    ;             WriteLineIndented("while (true)")
    ;         else
    ;             WriteIndented("while (")
    ;             item.Condition.Accept(this)
    ;             WriteLine(")")
    ;         WriteStatementBlock(item.Statements)
    ;     else
    ;         WriteIndented("for (var {item.LocalName} = ")
    ;         item.Init?.Accept(this)
    ;         Write("; ")
    ;         item.Condition?.Accept(this)
    ;         Write("; ")
    ;         InFor = true
    ;         item.Post?.Accept(this)
    ;         InFor = false
    ;         WriteLine(")")
    ;         WriteStatementBlock(item.Statements)

    public fn Visit(item ForEach) is throw new NotImplementedException()
    ; public fn Visit(item ForEach)
    ;     WriteIndented("foreach (var {item.LocalName} in ")
    ;     item.Expr.Accept(this)
    ;     WriteLine(")")
    ;     WriteStatementBlock(item.Statements)

    ; generic constraints are not supported
    public fn Visit(item Generic) is item.Name.Accept(this)

    ; generic constraints are not supported
    public fn Visit(item GenericConstraintToken) is throw new InvalidItemException()

    public fn Visit(item IdentifierToken) is Write(item.Value)
    
    public fn Visit(item If) is throw new NotImplementedException()
    ; public fn Visit(item If)
    ;     WriteLineIndented("{{")
    ;     Indent += 1
    ;     if item.LocalName != null and item.LocalExpr != null
    ;         WriteIndented("var {item.LocalName} = ")
    ;         item.LocalExpr.Accept(this)
    ;         WriteLine(";")
    ;     WriteIndented("if (")
    ;     item.Condition.Accept(this)
    ;     WriteLine(")")
    ;     WriteStatementBlock(item.Statements)
    ;     if item.ElseStatements.Any()
    ;         WriteLineIndented("else")
    ;         WriteStatementBlock(item.ElseStatements)
    ;     Indent -= 1
    ;     WriteLineIndented("}}")

    public fn Visit(item ImportToken) is WriteLineIndented("using {str.Join(".", item.NameParts)};")
    
    public fn Visit(item Initializer) is throw new NotImplementedException()
    
    public fn Visit(item Interface) is throw new NotImplementedException()
    ; public fn Visit(item Interface)
    ;     WriteModifiersIndented(item.Modifiers)
    ;     Write(" interface {item.Name}")
    ;     if item.GenericNames.Any()
    ;         Write("<{str.Join(", ", item.GenericNames)}>")
    ;     if item.Interfaces.Any()
    ;         Write(": ")
    ;         JoinItems(item.Interfaces)
    ;     WriteLine()
    ;     WriteStatementBlock(item.Statements)

    public fn Visit(item LiteralToken) is throw new NotImplementedException()
    ; public fn Visit(item LiteralToken) is Write(item.Token ?
    ;     {
    ;         LiteralType.False is "false",
    ;         LiteralType.Null is "null",
    ;         LiteralType.True is "true",
    ;         _ is "[literal]",
    ;     })

    public fn Visit(item LocalConstant) is throw new NotImplementedException()
    ; public fn Visit(item LocalConstant)
    ;     WriteIndented("const ")
    ;     item.Type.Accept(this)
    ;     Write(" {item.Name}")
    ;     if item.Value != null
    ;         Write(" = ")
    ;         item.Value.Accept(this)
    ;     WriteLine(";")
    
    public fn Visit(item LocalVariable) is throw new NotImplementedException()
    ; public fn Visit(item LocalVariable)
    ;     WriteIndent()
    ;     if item.Type == null
    ;         Write("var")
    ;     else
    ;         item.Type.Accept(this)
    ;     Write(" {item.Name}")
    ;     if item.Value != null
    ;         Write(" = ")
    ;         item.Value.Accept(this)
    ;     WriteLine(";")
    
    public fn Visit(item MethodDefinition)
        WriteAttributes()
        Write(" ")
        if item.ReturnType == null
            Write("void")
        else
            item.ReturnType.Accept(this)
        Write(" ")
        item.Name.Accept(this)
        if item.Generics.Any()
            Write("<")
            JoinItems(item.Generics)
            Write(">")
        Write("(")
        var first = true
        ; var extension = item.Modifiers.FirstOrDefault(fn(m) is m.Type == ModifierType.Extension)
        ; if extension is Modifier mod and mod.Argument != null
        ;     first = false
        ;     Write("this ")
        ;     mod.Argument.Accept(this)
        ;     Write(" __this")
        ;     InExtension = true
        for p in item.Parameters
            if first
                first = false
            else
                Write(", ")
            p.Accept(this)
        WriteLine(")")
        WriteStatementBlock(item.Statements)
        ; InExtension = false
    
    public fn Visit(item MethodSignature) is throw new NotImplementedException()
    ; public fn Visit(item MethodSignature)
    ;     WriteModifiersIndented(item.Modifiers)
    ;     Write(" ")
    ;     if item.ReturnType == null
    ;         Write("void")
    ;     else
    ;         item.ReturnType.Accept(this)
    ;     Write(" {item.Name}")
    ;     if item.GenericNames.Any()
    ;         Write("<{str.Join(", ", item.GenericNames)}>")
    ;     Write("(")
    ;     JoinItems(item.Parameters)
    ;     WriteLine(");")

    public fn Visit(item NamedExpression) is throw new NotImplementedException()
    ; public fn Visit(item NamedExpression)
    ;     item.Expr.Accept(this)
    ;     Write(" {item.Name}")

    public fn Visit(item NamespaceToken) is WriteLineIndented("namespace {str.Join(".", item.NameParts)};")

    public fn Visit(item Node) is throw new InvalidItemException()

    public fn Visit(item NullableType) is throw new NotImplementedException()
    ; public fn Visit(item Core.Ast.Nullable)
    ;     item.Type.Accept(this)
    ;     Write("?")

    public fn Visit(item NumberToken) is Write(item.Type ? {
        NumberType.Binary is "0b{item.Value}",
        NumberType.Decimal is item.Value,
        NumberType.Hexadecimal is "0x{item.Value}",
        _ is "[{item.Type}:{item.Value}]",
    })

    public fn Visit(item Parameter)
        JoinItems(item.Modifiers, " ")
        item.Type?.Accept(this)
        Write(" ")
        item.Name.Accept(this)
        if item.Value != null
            Write(" = ")
            item.Value.Accept(this)

    public fn Visit(item ParameterModifierToken) is Write(item.Value ? {
        ParameterModifierType.Out is "out",
        ParameterModifierType.Parameters is "params",
        ParameterModifierType.Reference is "ref",
        _ is "[{item.Value}]",
    })

    public fn Visit(item PropertyDefinition) is throw new NotImplementedException()
    ; public fn Visit(item Property)
    ;     WriteModifiersIndented(item.Modifiers, canOverride = true)
    ;     Write(" ")
    ;     item.Type.Accept(this)
    ;     WriteLine(" {item.Name}")

    ;     WriteLineIndented("{{")
    ;     Indent += 1

    ;     if item.GetStatements.Any()
    ;         WriteLineIndented("get")
    ;         WriteStatementBlock(item.GetStatements)
    ;     else if item.GetSpecified and !item.SetStatements.Any()
    ;         WriteLineIndented("get;")
        
    ;     if item.SetStatements.Any()
    ;         WriteLineIndented("set")
    ;         WriteStatementBlock(item.SetStatements)
    ;     else if item.SetSpecified and !item.GetStatements.Any()
    ;         WriteLineIndented("set;")
        
    ;     Indent -= 1
    ;     WriteIndented("}}")

    ;     if item.Value != null
    ;         Write(" = ")
    ;         item.Value.Accept(this)
    ;         Write(";")
    ;     WriteLine()

    public fn Visit(item PropertySignature) is throw new NotImplementedException()
    ; public fn Visit(item PropertySignature)
    ;     WriteModifiersIndented(item.Modifiers)
    ;     Write(" ")
    ;     item.Type.Accept(this)
    ;     Write(" {item.Name} {{")
    ;     if item.GetSpecified
    ;         Write("get;")
    ;     if item.SetSpecified
    ;         Write("set;")
    ;     WriteLine("}}")

    public fn Visit(item Return)
        WriteIndented("return ")
        item.Value?.Accept(this)
        WriteLine(";")

    public fn Visit(item SpaceToken)
        for i = 0, i < item.Size, i += 1
            WriteLine()

    public fn Visit(item Statement) is throw new InvalidItemException()

    public fn Visit(item Core.SyntaxTree.String) is throw new NotImplementedException()
    ; public fn Visit(item Core.Ast.String)
    ;     Write("$\"")

    ;     var first = true
    ;     for line in item.Lines
    ;         if first
    ;             first = false
    ;         else
    ;             Write("{{System.Environment.NewLine}}")
    ;         for expr in line
    ;             var curlies = !(expr is StringLiteral)
    ;             if curlies
    ;                 Write("{{(")
    ;             expr.Accept(this)
    ;             if curlies
    ;                 Write(")}}")
        
    ;     Write("\"")

    public fn Visit(item StringToken) is throw new NotImplementedException()
    ; public fn Visit(item StringLiteral) is Write(Escape(item.Value))

    public fn Visit(item Struct) is throw new NotImplementedException()
    ; public fn Visit(item Struct)
    ;     CurrentObject = item.Name

    ;     WriteModifiersIndented(item.Modifiers)
    ;     Write(" struct {item.Name}")
    ;     if item.GenericNames.Any()
    ;         Write("<{str.Join(", ", item.GenericNames)}>")
    ;     if item.Interfaces.Any()
    ;         Write(" : ")
    ;         JoinItems(item.Interfaces)
    ;     WriteLine()
    ;     WriteStatementBlock(item.Statements)

    public fn Visit(item Switch) is throw new NotImplementedException()
    ; public fn Visit(item Switch)
    ;     WriteLineIndented("{{")
    ;     Indent += 1
    ;     if item.LocalName != null and item.LocalExpr != null
    ;         WriteIndented("var {item.LocalName} = ")
    ;         item.LocalExpr.Accept(this)
    ;         WriteLine(";")
    ;     WriteIndented("switch (")
    ;     item.Expr.Accept(this)
    ;     WriteLine(")")
    ;     WriteStatementBlock(item.Statements)
    ;     Indent -= 1
    ;     WriteLineIndented("}}")

    public fn Visit(item Throw) is throw new NotImplementedException()
    ; public fn Visit(item Throw)
    ;     Write("throw ")
    ;     item.Exception.Accept(this)

    public fn Visit(item Try) is throw new NotImplementedException()
    ; public fn Visit(item Try)
    ;     WriteLineIndented("try")
    ;     WriteStatementBlock(item.Statements)
    ;     for cat in item.Catches
    ;         cat.Accept(this)
    ;     if item.FinallyStatements.Any()
    ;         WriteLineIndented("finally")
    ;         WriteStatementBlock(item.FinallyStatements)

    public fn Visit(item UnaryOperator) is throw new NotImplementedException()
    ; public fn Visit(item UnaryOperator)
    ;     Write(item.Operator ?
    ;     {
    ;         UnaryOperatorType.BitwiseNot is "~",
    ;         UnaryOperatorType.Negate is "-",
    ;         UnaryOperatorType.Not is "!",
    ;         _ is "[unary op]",
    ;     })
    ;     Write("(")
    ;     item.Expr.Accept(this)
    ;     Write(")")

    public fn Visit(item UnaryOperatorToken) is throw new NotImplementedException()

    public fn Visit(item Using) is throw new NotImplementedException()
    ; public fn Visit(item Using)
    ;     if item.Statements.Any()
    ;         WriteIndented("using (var {item.LocalName} = ")
    ;         item.LocalExpr.Accept(this)
    ;         WriteLine(")")
    ;         WriteStatementBlock(item.Statements)
    ;     else
    ;         WriteIndented("using var {item.LocalName} = ")
    ;         item.LocalExpr.Accept(this)
    ;         WriteLine(";")
