use System.Text
use NSharp.Core
use NSharp.Core.SyntaxTree

ns NSharp.Compiler

public class ToCsVisitor has ISyntaxTreeVisitor, IDisposable
    private fn Buffer StreamWriter
    private fn Indent int = 0
    private fn Attributes Stack{Expression} = new()
    
    private fn Write(line str) : Buffer.Write(line)
    private fn WriteLine() : Buffer.WriteLine()
    private fn WriteLine(line str) : Buffer.WriteLine(line)

    private fn GenericNames HashSet{str} = new()
    private fn IndexerNames HashSet{str} = new()

    private fn WriteIndent()
        for i = 0, i < Indent, i += 1
            Write("    ")

    private fn WriteIndented(line str)
        WriteIndent()
        Write(line)

    private fn WriteLineIndented(line str)
        WriteIndent()
        WriteLine(line)

    ; private fn InFor bool
    ; private fn InExtension bool

    private fn WriteAttributes()
        WriteIndent()
        for a in Attributes
            a.Accept(this)
            Write(" ")
    ; private fn WriteModifiersIndented(modifiers List{Modifier}, canBeSealed bool = false, canOverride bool = false)
    ;     WriteIndented(str.Join(" ", modifiers.Select(fn(m) is m.Type ?
    ;     {
    ;         ModifierType.Abstract is "abstract",
    ;         ModifierType.Extension is "",
    ;         ModifierType.Internal is "internal",
    ;         ModifierType.Open is "",
    ;         ModifierType.Override is "override",
    ;         ModifierType.Private is "private",
    ;         ModifierType.Protected is "protected",
    ;         ModifierType.Public is "public",
    ;         ModifierType.Static is "static",
    ;         _ is " [modifier] ",
    ;     })))
    ;     if modifiers.Any(fn(m) is m.Type == ModifierType.Open)
    ;         if canOverride
    ;                 and !modifiers.Any(fn(m) is m.Type == ModifierType.Override)
    ;                 and !modifiers.Any(fn(m) is m.Type == ModifierType.Static)
    ;             Write(" virtual")
    ;     else if canBeSealed
    ;             and !modifiers.Any(fn(m) is m.Type == ModifierType.Abstract)
    ;             and !modifiers.Any(fn(m) is m.Type == ModifierType.Static)
    ;         Write(" sealed")
    ;     else if canOverride
    ;             and modifiers.Any(fn(m) is m.Type == ModifierType.Override)
    ;             and !modifiers.Any(fn(m) is m.Type == ModifierType.Open)
    ;         Write(" sealed")

    private fn WriteStatementBlock(statements List{Statement})
        WriteLineIndented("{{")
        Indent += 1
        for stmt in statements
            stmt.Accept(this)
        Indent -= 1
        WriteLineIndented("}}")
    
    private fn JoinItems(items IEnumerable{Node}, separator str = ", ")
        var first = true
        for item in items
            if first
                first = false
            else
                Write(separator)
            item.Accept(this)
    
    private fn Escape(value str) str : new StringBuilder(value)
        .Replace("{{", "{{{{")
        .Replace("}}", "}}}}")
        .Replace("\\", "\\\\")
        .Replace("\"", "\\\"")
        .Replace("\n", "\\n")
        .Replace("\r", "\\r")
        .Replace("\t", "\\t")
        .ToString()

    public fn new(fileName str)
        Buffer = new StreamWriter(fileName)

        ; Hard-coded list of generic classes
        GenericNames.Add("HashSet")
        GenericNames.Add("Dictionary")
        GenericNames.Add("List")
        GenericNames.Add("Stack")
        GenericNames.Add("Queue")
        GenericNames.Add("IEnumerable")
        GenericNames.Add("Func")
        GenericNames.Add("Action")

        ; Hard-coded list of variables that use indexers
        IndexerNames.Add("arg")
        IndexerNames.Add("args")
        IndexerNames.Add("Assemblies")
        IndexerNames.Add("Conditions")
        IndexerNames.Add("config")
        IndexerNames.Add("Flags")
        IndexerNames.Add("sb")
        IndexerNames.Add("SearchItems")
        IndexerNames.Add("settings")
        IndexerNames.Add("Statements")
        IndexerNames.Add("Tokens")
        IndexerNames.Add("Types")

    public fn Dispose() : Buffer?.Dispose()

    public fn Visit(item AnonymousFunction)
        Write("(")
        JoinItems(item.Parameters)
        Write(") => ")
        if item.Statements.Count == 1 and item.Statements[0] is ExpressionStatement es
            es.Value.Accept(this)
        else
            WriteLine()
            Indent += 1
            WriteStatementBlock(item.Statements)
            Indent -= 1

    public fn Visit(item Argument)
        if item.Name != null
            item.Name.Accept(this)
            Write(": ")
        JoinItems(item.Modifiers, " ")
        item.Value.Accept(this)

    public fn Visit(item ArgumentModifierToken) : Write(item.Value ?
    {
        ArgumentModifierType.Out : "out ",
        ArgumentModifierType.Reference : "ref ",
        _ : "[{item.Value}] ",
    })

    public fn Visit(item Core.SyntaxTree.Arguments)
        ; THIS IS AN AWFUL HACK TO RESOLVE ARGUMENTS TO THE
        ; CORRECT METHOD CALL / INDEXER / GENERIC

        item.Value.Accept(this)

        if item.Value is IdentifierToken it and GenericNames.Contains(it.Value)
            Write("<")
            JoinItems(item.Values)
            Write(">")
        else if (item.Value is IdentifierToken it2 and IndexerNames.Contains(it2.Value)) or
                (
                    item.Value is BinaryOperator bo and
                    (bo.Operator.Value == BinaryOperatorType.Dot or bo.Operator.Value == BinaryOperatorType.NullDot) and
                    bo.RightOperand is IdentifierToken it3 and IndexerNames.Contains(it3.Value)
                )
            Write("[")
            JoinItems(item.Values)
            Write("]")
        else
            Write("(")
            JoinItems(item.Values)
            Write(")")

    public fn Visit(item ArrayLiteral)
        Write("{{")
        JoinItems(item.Values)
        Write("}}")

    public fn Visit(item ArrayType)
        item.Type.Accept(this)
        Write("[")
        for i = 1, i < item.Dimension, i += 1
            Write(",")
        Write("]")

    public fn Visit(item Assignment)
        WriteIndent()
        item.LeftOperand.Accept(this)
        item.Operator.Accept(this)
        item.RightOperand.Accept(this)
        WriteLine(";")

    public fn Visit(item AssignmentOperatorToken) : Write(item.Value ?
        {
            AssignmentOperatorType.Add : " += ",
            AssignmentOperatorType.Assign : " = ",
            AssignmentOperatorType.BitwiseAnd : " &= ",
            AssignmentOperatorType.BitwiseOr : " |= ",
            AssignmentOperatorType.BitwiseXor : " ^= ",
            AssignmentOperatorType.Divide : " /= ",
            AssignmentOperatorType.LeftShift : " <<= ",
            AssignmentOperatorType.Modulus : " %= ",
            AssignmentOperatorType.Multiply : " *= ",
            AssignmentOperatorType.NullCoalesce : " ??= ",
            AssignmentOperatorType.RightShift : " >>= ",
            AssignmentOperatorType.Subtract : " -= ",
            _ : " [none] ",
        })

    public fn Visit(item Core.SyntaxTree.Attribute)
        if item.Qualifier != null
            Write("[")
            item.Qualifier.Accept(this)
            Write(":")
            item.Type.Accept(this)
            Write("]")
        else
            item.Type.Accept(this)

    public fn Visit(item AttributeBlock)
        for a in item.Attributes
            Attributes.Push(a)
        for s in item.Statements
            s.Accept(this)
        for i = 0, i < item.Attributes.Count, i += 1
            Attributes.Pop()

    public fn Visit(item BadExpressionToken) : Write("/* bad expression */")

    public fn Visit(item BadStatementToken) : WriteLineIndented("/* bad statement */")

    public fn Visit(item BaseClassToken) : throw new NotImplementedException()

    public fn Visit(item BinaryOperator)
        var parens = false
        if item.Parent is BinaryOperator parent
            parens = item.Operator.Value.Precedence() < parent.Operator.Value.Precedence() + (parent.LeftOperand == item ? 0 : 1)
        if parens
            Write("(")
        
        if item.Operator.Value == BinaryOperatorType.As
            Write("(")
            item.RightOperand.Accept(this)
            Write(")")

        item.LeftOperand.Accept(this)

        if item.Operator.Value != BinaryOperatorType.As
            item.Operator.Accept(this)
            item.RightOperand.Accept(this)

        if parens
            Write(")")

    public fn Visit(item BinaryOperatorToken) : Write(item.Value ?
        {
            BinaryOperatorType.Add : " + ",
            BinaryOperatorType.And : " && ",
            BinaryOperatorType.As : " as ",
            BinaryOperatorType.BitwiseAnd : " & ",
            BinaryOperatorType.BitwiseOr : " | ",
            BinaryOperatorType.BitwiseXor : " ^ ",
            BinaryOperatorType.Divide : " / ",
            BinaryOperatorType.Dot : ".",
            BinaryOperatorType.Equal : " == ",
            BinaryOperatorType.GreaterThan : " > ",
            BinaryOperatorType.GreaterThanOrEqual : " >= ",
            BinaryOperatorType.Is : " is ",
            BinaryOperatorType.LeftShift : " << ",
            BinaryOperatorType.LessThan : " < ",
            BinaryOperatorType.LessThanOrEqual : " <= ",
            BinaryOperatorType.Modulus : " % ",
            BinaryOperatorType.Multiply : " * ",
            BinaryOperatorType.NotEqual : " != ",
            BinaryOperatorType.NullCoalesce : " ?? ",
            BinaryOperatorType.NullDot : "?.",
            BinaryOperatorType.Or : " || ",
            BinaryOperatorType.RightShift : " >> ",
            BinaryOperatorType.Subtract : " - ",
            _ : " [none] ",
        })

    public fn Visit(item Block) : WriteStatementBlock(item.Statements)

    public fn Visit(item BreakToken) : WriteLineIndented("break;")

    public fn Visit(item Case)
        if item.Value is DiscardToken
            WriteLineIndented("default:")
        else
            WriteIndented("case ")
            item.Value.Accept(this)
            WriteLine(":")
        if item.Statements.Any()
            Indent += 1
            WriteStatementBlock(item.Statements)
            if !(item.Statements[item.Statements.Count - 1] is Return)
                WriteLineIndented("break;")
            Indent -= 1

    public fn Visit(item Catch)
        WriteIndented("catch")
        if item.Value != null
            Write(" (")
            item.Value.Accept(this)
            Write(")")
        WriteLine()
        WriteStatementBlock(item.Statements)

    public fn Visit(item CharacterToken) : Write("'{item.Value}'")

    public fn Visit(item Class)
        WriteAttributes()
        Write(" class ")
        item.Name.Accept(this)
        if item.Generics.Any()
            Write("<")
            JoinItems(item.Generics)
            Write(">")
        if item.Base != null
            Write(" : ")
            item.Base.Accept(this)
            for intf in item.Interfaces
                Write(", ")
                intf.Accept(this)
        else if item.Interfaces.Any()
            Write(" : ")
            JoinItems(item.Interfaces)
        WriteLine()
        WriteStatementBlock(item.Statements)

    public fn Visit(item CommentToken) : WriteLineIndented("//{item.IsDocumentation ? "/" : ""}{item.Value}")

    public fn Visit(item Condition)
        WriteIndent()
        item.Value.Accept(this)
        Write(" => ")
        item.Result.Accept(this)
        WriteLine(",")

    public fn Visit(item Conditional)
        item.Value.Accept(this)
        if item.Conditions.Count == 2 and
                item.Conditions[0] is Condition c1 and
                c1.Value is LiteralToken lt1 and
                lt1.Value == LiteralType.True and
                item.Conditions[1] is Condition c2 and
                c2.Value is LiteralToken lt2 and
                lt2.Value == LiteralType.False
            ; ternary
            Write(" ? (")
            c1.Result.Accept(this)
            Write(") : (")
            c2.Result.Accept(this)
            Write(")")
        else
            WriteLine(" switch")
            WriteLineIndented("{{")
            Indent += 1
            for c in item.Conditions
                c.Accept(this)
            Indent -= 1
            WriteIndented("}}")

    public fn Visit(item Constant)
        WriteAttributes()
        Write(" const ")
        item.Type.Accept(this)
        Write(" ")
        item.Name.Accept(this)
        if item.Value != null
            Write(" = ")
            item.Value.Accept(this)
        WriteLine(";")

    public fn Visit(item ConstructorCall)
        Write("new ")
        item.Type?.Accept(this)
        Write("(")
        JoinItems(item.Arguments)
        Write(")")
        if item.Initializers.Any()
            Write("{{")
            JoinItems(item.Initializers)
            Write("}}")

    public fn Visit(item ConstructorDefinition)
        WriteAttributes()
        Write(" ")
        var parent = item.ParentSkipAttributes
        if parent is Class cl
            cl.Name.Accept(this)
        else if parent is Struct st
            st.Name.Accept(this)
        else
            throw new InvalidItemException("Constructor can only be defined on a class or struct.")
        Write("(")
        JoinItems(item.Parameters)
        Write(")")
        if item.BaseArguments.Any()
            Write(" : base(")
            JoinItems(item.BaseArguments)
            Write(")")
        WriteLine()
        WriteStatementBlock(item.Statements)

    public fn Visit(item ContinueToken) : WriteLineIndented("continue;")

    public fn Visit(item CurrentObjectInstanceToken) : throw new NotImplementedException()
    ; public fn Visit(item CurrentObjectInstance) is Write(InExtension ? "__this" : "this")

    public fn Visit(item DefaultValueToken) : Write("default")

    public fn Visit(item Core.SyntaxTree.Delegate) : throw new NotImplementedException()
    ; public fn Visit(item DelegateDefinition)
    ;     WriteModifiersIndented(item.Modifiers)
    ;     Write(" delegate ")
    ;     if item.ReturnType == null
    ;         Write("void")
    ;     else
    ;         item.ReturnType.Accept(this)
    ;     Write(" {item.Name}")
    ;     if item.GenericNames.Any()
    ;         Write("<{str.Join(", ", item.GenericNames)}>")
    ;     Write("(")
    ;     JoinItems(item.Parameters)
    ;     WriteLine(");")

    public fn Visit(item DiscardToken) : Write("_")

    public fn Visit(item Enumeration)
        WriteAttributes()
        Write(" enum ")
        item.Name.Accept(this)
        WriteLine()
        WriteStatementBlock(item.Statements)

    public fn Visit(item EnumerationItem)
        WriteIndent()
        item.Name.Accept(this)
        if item.Value != null
            Write(" = ")
            item.Value.Accept(this)
        Write(",")
        if item.Comment != null
            item.Comment.Accept(this)
        else
            WriteLine()

    public fn Visit(item Expression) : throw new InvalidItemException()

    public fn Visit(item ExpressionStatement)
        WriteIndent()
        item.Value.Accept(this)
        WriteLine(";")

    public fn Visit(item Field)
        WriteAttributes()
        Write(" ")
        item.Type.Accept(this)
        Write(" ")
        item.Name.Accept(this)
        if item.Value != null
            Write(" = ")
            item.Value.Accept(this)
        WriteLine(";")

    public fn Visit(item Core.SyntaxTree.File)
        WriteLineIndented("// {DateTime.Now}")
        WriteLine()
        for statement in item.Statements
            statement.Accept(this)

    public fn Visit(item For) : throw new NotImplementedException()
    ; public fn Visit(item For)
    ;     if item.Init == null and item.Post == null
    ;         if item.Condition == null
    ;             WriteLineIndented("while (true)")
    ;         else
    ;             WriteIndented("while (")
    ;             item.Condition.Accept(this)
    ;             WriteLine(")")
    ;         WriteStatementBlock(item.Statements)
    ;     else
    ;         WriteIndented("for (var {item.LocalName} = ")
    ;         item.Init?.Accept(this)
    ;         Write("; ")
    ;         item.Condition?.Accept(this)
    ;         Write("; ")
    ;         InFor = true
    ;         item.Post?.Accept(this)
    ;         InFor = false
    ;         WriteLine(")")
    ;         WriteStatementBlock(item.Statements)

    public fn Visit(item ForEach) : throw new NotImplementedException()
    ; public fn Visit(item ForEach)
    ;     WriteIndented("foreach (var {item.LocalName} in ")
    ;     item.Expr.Accept(this)
    ;     WriteLine(")")
    ;     WriteStatementBlock(item.Statements)

    ; generic constraints are not supported
    public fn Visit(item Generic) : item.Name.Accept(this)

    ; generic constraints are not supported
    public fn Visit(item GenericConstraintToken) : throw new InvalidItemException()

    public fn Visit(item IdentifierToken) : Write(item.Value)
    
    public fn Visit(item If)
        WriteLineIndented("{{")
        Indent += 1
        if item.LocalName != null and item.LocalValue != null
            WriteIndented("var ")
            item.LocalName.Accept(this)
            Write(" = ")
            item.LocalValue.Accept(this)
            WriteLine(";")
        WriteIndented("if (")
        item.Condition.Accept(this)
        WriteLine(")")
        WriteStatementBlock(item.Statements)
        if item.ElseStatements.Any()
            WriteLineIndented("else")
            WriteStatementBlock(item.ElseStatements)
        Indent -= 1
        WriteLineIndented("}}")

    public fn Visit(item ImportToken) : WriteLineIndented("using {str.Join(".", item.NameParts)};")
    
    public fn Visit(item Initializer)
        item.Name.Accept(this)
        Write(" = ")
        item.Value.Accept(this)
    
    public fn Visit(item Interface) : throw new NotImplementedException()
    ; public fn Visit(item Interface)
    ;     WriteModifiersIndented(item.Modifiers)
    ;     Write(" interface {item.Name}")
    ;     if item.GenericNames.Any()
    ;         Write("<{str.Join(", ", item.GenericNames)}>")
    ;     if item.Interfaces.Any()
    ;         Write(": ")
    ;         JoinItems(item.Interfaces)
    ;     WriteLine()
    ;     WriteStatementBlock(item.Statements)

    public fn Visit(item LiteralToken) : Write(item.Value ? {
        LiteralType.False : "false",
        LiteralType.Null : "null",
        LiteralType.True : "true",
        _ : "[literal]",
    })

    public fn Visit(item LocalConstant)
        WriteIndented("const var ")
        item.Name.Accept(this)
        Write(" = ")
        item.Value.Accept(this)
        WriteLine(";")
    
    public fn Visit(item LocalVariable)
        WriteIndent()
        if item.Type == null
            Write("var")
        else
            item.Type.Accept(this)
        Write(" ")
        item.Name.Accept(this)
        if item.Value != null
            Write(" = ")
            item.Value.Accept(this)
        WriteLine(";")
    
    public fn Visit(item MethodDefinition)
        WriteAttributes()
        Write(" ")
        if item.ReturnType == null
            Write("void")
        else
            item.ReturnType.Accept(this)
        Write(" ")
        item.Name.Accept(this)
        if item.Generics.Any()
            Write("<")
            JoinItems(item.Generics)
            Write(">")
        Write("(")
        var first = true
        ; var extension = item.Modifiers.FirstOrDefault(fn(m) is m.Type == ModifierType.Extension)
        ; if extension is Modifier mod and mod.Argument != null
        ;     first = false
        ;     Write("this ")
        ;     mod.Argument.Accept(this)
        ;     Write(" __this")
        ;     InExtension = true
        for p in item.Parameters
            if first
                first = false
            else
                Write(", ")
            p.Accept(this)
        WriteLine(")")
        WriteStatementBlock(item.Statements)
        ; InExtension = false
    
    public fn Visit(item MethodSignature) : throw new NotImplementedException()
    ; public fn Visit(item MethodSignature)
    ;     WriteModifiersIndented(item.Modifiers)
    ;     Write(" ")
    ;     if item.ReturnType == null
    ;         Write("void")
    ;     else
    ;         item.ReturnType.Accept(this)
    ;     Write(" {item.Name}")
    ;     if item.GenericNames.Any()
    ;         Write("<{str.Join(", ", item.GenericNames)}>")
    ;     Write("(")
    ;     JoinItems(item.Parameters)
    ;     WriteLine(");")

    public fn Visit(item NamedExpression)
        item.Value.Accept(this)
        Write(" ")
        item.Name.Accept(this)

    public fn Visit(item NamespaceToken) : WriteLineIndented("namespace {str.Join(".", item.NameParts)};")

    public fn Visit(item Node) : throw new InvalidItemException()

    public fn Visit(item NullableType)
        item.Type.Accept(this)
        Write("?")

    public fn Visit(item NumberToken) : Write(item.Type ? {
        NumberType.Binary : "0b{item.Value}",
        NumberType.Decimal : item.Value,
        NumberType.Hexadecimal : "0x{item.Value}",
        _ : "[{item.Type}:{item.Value}]",
    })

    public fn Visit(item Parameter)
        JoinItems(item.Modifiers, " ")
        item.Type?.Accept(this)
        Write(" ")
        item.Name.Accept(this)
        if item.Value != null
            Write(" = ")
            item.Value.Accept(this)

    public fn Visit(item ParameterModifierToken) : Write(item.Value ? {
        ParameterModifierType.Out : "out",
        ParameterModifierType.Parameters : "params",
        ParameterModifierType.Reference : "ref",
        _ : "[{item.Value}]",
    })

    public fn Visit(item PropertyDefinition) : throw new NotImplementedException()
    ; public fn Visit(item Property)
    ;     WriteModifiersIndented(item.Modifiers, canOverride = true)
    ;     Write(" ")
    ;     item.Type.Accept(this)
    ;     WriteLine(" {item.Name}")

    ;     WriteLineIndented("{{")
    ;     Indent += 1

    ;     if item.GetStatements.Any()
    ;         WriteLineIndented("get")
    ;         WriteStatementBlock(item.GetStatements)
    ;     else if item.GetSpecified and !item.SetStatements.Any()
    ;         WriteLineIndented("get;")
        
    ;     if item.SetStatements.Any()
    ;         WriteLineIndented("set")
    ;         WriteStatementBlock(item.SetStatements)
    ;     else if item.SetSpecified and !item.GetStatements.Any()
    ;         WriteLineIndented("set;")
        
    ;     Indent -= 1
    ;     WriteIndented("}}")

    ;     if item.Value != null
    ;         Write(" = ")
    ;         item.Value.Accept(this)
    ;         Write(";")
    ;     WriteLine()

    public fn Visit(item PropertySignature) : throw new NotImplementedException()
    ; public fn Visit(item PropertySignature)
    ;     WriteModifiersIndented(item.Modifiers)
    ;     Write(" ")
    ;     item.Type.Accept(this)
    ;     Write(" {item.Name} {{")
    ;     if item.GetSpecified
    ;         Write("get;")
    ;     if item.SetSpecified
    ;         Write("set;")
    ;     WriteLine("}}")

    public fn Visit(item Return)
        WriteIndented("return ")
        item.Value?.Accept(this)
        WriteLine(";")

    public fn Visit(item SpaceToken)
        for i = 0, i < item.Size, i += 1
            WriteLine()

    public fn Visit(item Statement) : throw new InvalidItemException()

    public fn Visit(item Core.SyntaxTree.String)
        Write("$\"")

        var first = true
        for line in item.Lines
            if first
                first = false
            else
                Write("{{System.Environment.NewLine}}")
            for expr in line
                var curlies = !(expr is StringToken)
                if curlies
                    Write("{{(")
                expr.Accept(this)
                if curlies
                    Write(")}}")
        
        Write("\"")

    public fn Visit(item StringToken) : Write(Escape(item.Value))

    public fn Visit(item Struct) : throw new NotImplementedException()
    ; public fn Visit(item Struct)
    ;     CurrentObject = item.Name

    ;     WriteModifiersIndented(item.Modifiers)
    ;     Write(" struct {item.Name}")
    ;     if item.GenericNames.Any()
    ;         Write("<{str.Join(", ", item.GenericNames)}>")
    ;     if item.Interfaces.Any()
    ;         Write(" : ")
    ;         JoinItems(item.Interfaces)
    ;     WriteLine()
    ;     WriteStatementBlock(item.Statements)

    public fn Visit(item Switch)
        WriteLineIndented("{{")
        Indent += 1
        if item.LocalName != null and item.LocalValue != null
            WriteIndented("var ")
            item.LocalName.Accept(this)
            Write(" = ")
            item.LocalValue.Accept(this)
            WriteLine(";")
        WriteIndented("switch (")
        item.Value.Accept(this)
        WriteLine(")")
        WriteStatementBlock(item.Cases)
        Indent -= 1
        WriteLineIndented("}}")

    public fn Visit(item Throw)
        Write("throw ")
        item.Value.Accept(this)

    public fn Visit(item Try)
        WriteLineIndented("try")
        WriteStatementBlock(item.Statements)
        for c in item.Catches
            c.Accept(this)
        if item.FinallyStatements.Any()
            WriteLineIndented("finally")
            WriteStatementBlock(item.FinallyStatements)

    public fn Visit(item UnaryOperator)
        item.Operator.Accept(this)
        Write("(")
        item.Value.Accept(this)
        Write(")")

    public fn Visit(item UnaryOperatorToken) : Write(item.Value ?
    {
        UnaryOperatorType.BitwiseNot : "~",
        UnaryOperatorType.Negate : "-",
        UnaryOperatorType.Not : "!",
        _ : "[unary op]",
    })

    public fn Visit(item Using)
        if item.Statements.Any()
            WriteIndented("using (var ")
            item.Name.Accept(this)
            Write(" = ")
            item.Value.Accept(this)
            WriteLine(")")
            WriteStatementBlock(item.Statements)
        else
            WriteIndented("using var ")
            item.Name.Accept(this)
            Write(" = ")
            item.Value.Accept(this)
            WriteLine(";")
